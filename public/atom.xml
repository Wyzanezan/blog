<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wyzane&#39;s Blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://wyzane.gitee.io/blog/"/>
  <updated>2024-02-02T07:03:06.393Z</updated>
  <id>http://wyzane.gitee.io/blog/</id>
  
  <author>
    <name>Wyzane</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过cloudflare的tunnel技术实现内网穿透</title>
    <link href="http://wyzane.gitee.io/blog/2024/02/02/%E9%80%9A%E8%BF%87cloudflare%E7%9A%84tunnel%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://wyzane.gitee.io/blog/2024/02/02/%E9%80%9A%E8%BF%87cloudflare%E7%9A%84tunnel%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2024-02-02T06:25:31.000Z</published>
    <updated>2024-02-02T07:03:06.393Z</updated>
    
    <content type="html"><![CDATA[<p>cloudflare是一家提供一系列面向网站、应用程序和API的互联网安全性和性能增强服务的公司，它提供的服务主要包括内容分发网络（CDN）、分布式域名系统（DNS）服务、防御分布式拒绝服务（DDoS）攻击的解决方案和安全防护措施等。</p><p>我们在cloudflare上购买域名后，可以使用它的 tunnel 技术实现内网穿透，将我们的域名绑定到一个本地服务上。</p><p>下面分享一下操作步骤。</p><a id="more"></a><p>操作步骤（以windows为例）：</p><ol><li><p>安装 cloudflared（在官网或者github下载并安装，<a href="https://github.com/cloudflare/cloudflared/releases）" target="_blank" rel="noopener">https://github.com/cloudflare/cloudflared/releases）</a></p></li><li><p>执行以下命令，登录到cloudflare进行授权</p><p>cloudflared tunnel login<br>执行后会弹出一个页面，进行授权即可。授权完成后，会在 .cloudflare 目录下生成一个 cert.pem 文件</p></li><li><p>创建隧道 tunnel</p><p>cloudflared tunnel create &lt;隧道名字&gt;<br>创建完成后，会在 .cloudflare 目录中生成一个 uuid.json 的文件</p></li><li><p>把域名指向对应的隧道</p><p>cloudflared tunnel route dns &lt;隧道名字&gt; &lt;域名&gt;<br>完成后，cloudflare 会自动添加一条 CNAME 记录到对应的域名</p></li><li><p>配置 cloudflared</p><p>编辑文件 .\cloudflared\config.yml，添加如下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tunnel:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">credentials-file:</span> <span class="string">C:\Users\10579\.cloudflared\e9e54272-7145-485d-af9f-d620558d5c7a.json</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">blog.wangzan.net</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">service:</span> <span class="string">http_status:404</span></span><br></pre></td></tr></table></figure><p>配置完成后，可以测试一下文件是否正确：</p><p>cloudflared tunnel –config .\cloudflared\config.yml ingress validate</p><p>测试规则是否命中：</p><p>cloufdlared tunnel –config .\cloudflared\config.yml ingress rule <a href="http://wangzan.net" target="_blank" rel="noopener">http://wangzan.net</a></p></li><li><p>测试运行</p><p>.\cloudflared.exe –loglevel debug –transport-loglevel warn –config C:\Users\wyzane.cloudflared\config.yml tunnel run &lt;隧道UUID&gt;</p></li></ol><p>以上就是通过cloudflare配置内网穿透的步骤。</p><p>参考：</p><p><a href="https://blog.cloudflare.com/zh-cn/elevate-load-balancing-with-private-ips-and-cloudflare-tunnels-a-secure-path-to-efficient-traffic-distribution-zh-cn/" target="_blank" rel="noopener">https://blog.cloudflare.com/zh-cn/elevate-load-balancing-with-private-ips-and-cloudflare-tunnels-a-secure-path-to-efficient-traffic-distribution-zh-cn/</a></p><p><a href="https://bra.live/setup-home-server-with-cloudflare-tunnel/" target="_blank" rel="noopener">https://bra.live/setup-home-server-with-cloudflare-tunnel/</a></p><p><a href="https://github.com/anderspitman/awesome-tunneling" target="_blank" rel="noopener">https://github.com/anderspitman/awesome-tunneling</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cloudflare是一家提供一系列面向网站、应用程序和API的互联网安全性和性能增强服务的公司，它提供的服务主要包括内容分发网络（CDN）、分布式域名系统（DNS）服务、防御分布式拒绝服务（DDoS）攻击的解决方案和安全防护措施等。&lt;/p&gt;
&lt;p&gt;我们在cloudflare上购买域名后，可以使用它的 tunnel 技术实现内网穿透，将我们的域名绑定到一个本地服务上。&lt;/p&gt;
&lt;p&gt;下面分享一下操作步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://wyzane.gitee.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://wyzane.gitee.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器之间免密登录的配置</title>
    <link href="http://wyzane.gitee.io/blog/2021/09/04/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://wyzane.gitee.io/blog/2021/09/04/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2021-09-04T08:34:49.000Z</published>
    <updated>2024-02-02T09:00:05.808Z</updated>
    
    <content type="html"><![CDATA[<p>下面的步骤中以 ubuntu1804 为例，介绍服务器之间配置免密登录的步骤。</p><a id="more"></a><p>三台服务器的 ip 为：192.168.0.101、192.168.0.103、192.168.0.104，配置使101可以在不需要密码（通过配置密钥）的情况下访问103和104。</p><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 三台服务器都安装 ssh 服务端和客户端</span><br><span class="line"></span><br><span class="line">2. 修改 103 和 104 服务器的 ssh 配置 &#x2F;etc&#x2F;ssh&#x2F;sshd_config，增加如下配置：</span><br><span class="line">PermitRootLogin yes  # 允许 root 用户通过 ssh 登录</span><br><span class="line">   修改完成保存后，重启 ssh 服务：service ssh restart</span><br><span class="line">   </span><br><span class="line">3. 在 101 上切换到 root 用户，然后执行：ssh-keygen -t rsa，执行后一路回车，生成公钥和私钥对</span><br><span class="line"></span><br><span class="line">4. 在 101 上执行：ssh-copy-id 192.168.0.103</span><br><span class="line">   输入 103 的 root 密码后（如果忘记 root 密码，可以使用 sudo passwd root 重新设置 root 密码），会出现如下信息：</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: Source of key(s) to be installed: &quot;&#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub&quot;</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@192.168.0.103&#39;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#39;192.168.0.103&#39;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br><span class="line">  </span><br><span class="line">   上面的信息表示，已经成功将 101 的公钥添加到了 103 服务器的 &#x2F;root&#x2F;.ssh&#x2F;authored_keys 文件中。</span><br><span class="line">   </span><br><span class="line">5. 执行: ssh 192.168.0.103 即可登录 103 服务器，也可以执行 scp file 192.168.0.103:&#x2F;home&#x2F;wyzane 将需要的文件拷贝到 103 服务器上</span><br><span class="line"></span><br><span class="line">6. 配置 104 服务器时， 重复执行步骤 4 即可。</span><br></pre></td></tr></table></figure><p>上面就是配置服务器之间免密登录的步骤，当我们在 101 服务器的 /etc/hosts 文件中添加如下配置后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.103  app-01</span><br><span class="line">192.168.0.104  app-02</span><br></pre></td></tr></table></figure><p>可以使用 ssh app-01 和 ssh app-02 之类的命令通过 DNS 解析来访问 103 和 104 服务器。</p><h2 id="ansible的使用"><a href="#ansible的使用" class="headerlink" title="ansible的使用"></a>ansible的使用</h2><p>如果有多台服务器需要配置密钥登录，可以使用Ansible进行批量配置。</p><p>Ansible 是一个开源的自动化平台，它用于配置管理、应用部署、任务自动执行等，下面介绍如何使用它进行批量密钥登录的配置。</p><p>假设我们有若干个员工，需要密钥登录多台服务器，那么就需要把多个员工的公钥上传到多台服务器上。</p><ol><li>首先创建一个hosts文件，文件中保存了服务器的信息：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[test]</span><br><span class="line">test_ip ansible_user&#x3D;test_user ansible_ssh_pass&#x3D;test_pass ansible_port&#x3D;22</span><br><span class="line"></span><br><span class="line">[preprod]</span><br><span class="line">preprod_ip ansible_user&#x3D;preprod_user ansible_ssh_pass&#x3D;preprod_pass ansible_port&#x3D;2000</span><br><span class="line"></span><br><span class="line">[prod]</span><br><span class="line">prod_ip ansible_user&#x3D;prod_user ansible_ssh_pass&#x3D;prod_pass ansible_port&#x3D;22</span><br><span class="line"></span><br><span class="line">[nginx]</span><br><span class="line">nginx_ip ansible_user&#x3D;nginx_user ansible_ssh_pass&#x3D;nginx_pass ansible_port&#x3D;22</span><br></pre></td></tr></table></figure><p>文件中，中括号的内容可以理解为服务器名称，这个名称在下面的文件中会用到，名称下面分别指定了对应的服务器ip、用户名、密码、端口信息。</p><ol start="2"><li>创建一个 Ansible playbook 配置文件 test.yml，用于保存需要执行的任务</li></ol><p>内容可以像下面这样：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">SSH</span> <span class="string">Keys</span>   <span class="comment"># 操作的名称</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">test:preprod</span>        <span class="comment"># 指定hosts文件中的哪些服务器执行这个操作</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span>                <span class="comment"># become表示是否使用特权提升，yes表示任务将以超级用户权限运行</span></span><br><span class="line">  <span class="attr">vars:</span>                      <span class="comment"># playbook运行时使用的变量</span></span><br><span class="line">    <span class="attr">ansible_become_pass:</span> <span class="string">"Dy18Zz@!@"</span>   <span class="comment"># 在提升权限时使用的密码</span></span><br><span class="line">  <span class="attr">tasks:</span>                               <span class="comment"># 这个操作中有哪些任务需要执行</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">authorized</span> <span class="string">key</span>         <span class="comment"># 任务名称，设置ssh授权密钥</span></span><br><span class="line">      <span class="attr">authorized_key:</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">lxtech</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('file', item) &#125;&#125;</span>"</span>    <span class="comment"># 使用了lookup从文件中读取密钥</span></span><br><span class="line">      <span class="attr">loop:</span>                                  <span class="comment"># 通过循环添加多个密钥文件，配置这些员工密钥登录test和preprod服务器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../pub/001.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../pub/002.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../pub/003.pub</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ensure</span> <span class="string">PubkeyAuthentication</span> <span class="string">is</span> <span class="string">enabled</span>   <span class="comment"># 任务名称，更新sshd_config文件，设置PubkeyAuthentication yes，允许密钥登录</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PubkeyAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PubkeyAuthentication yes'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Disable</span> <span class="string">Password</span> <span class="string">Authentication</span>   <span class="comment"># 禁止账号密码登录</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PasswordAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PasswordAuthentication no'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Disable</span> <span class="string">Root</span> <span class="string">SSH</span> <span class="string">Login</span>   <span class="comment"># 禁止使用root用户登录</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PermitRootLogin'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PermitRootLogin no'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">SSH</span> <span class="string">service</span>    <span class="comment"># 重启ssh服务</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">sshd</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">Nginx</span> <span class="string">SSH</span> <span class="string">Keys</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">nginx:prod</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">ansible_become_pass:</span> <span class="string">"!zE4s678g@"</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">authorized</span> <span class="string">key</span></span><br><span class="line">      <span class="attr">authorized_key:</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('file', item) &#125;&#125;</span>"</span></span><br><span class="line">      <span class="attr">loop:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/home/dytech/pkgs/ansible/pub/005.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/home/dytech/pkgs/ansible/pub/006.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/home/dytech/pkgs/ansible/pub/007.pub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ensure</span> <span class="string">PubkeyAuthentication</span> <span class="string">is</span> <span class="string">enabled</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PubkeyAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PubkeyAuthentication yes'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Disable</span> <span class="string">Password</span> <span class="string">Authentication</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PasswordAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PasswordAuthentication no'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">SSH</span> <span class="string">service</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">sshd</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p>配置完成后，执行命令 ansible-playbook -i hosts test.yml 批量执行任务就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面的步骤中以 ubuntu1804 为例，介绍服务器之间配置免密登录的步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://wyzane.gitee.io/blog/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://wyzane.gitee.io/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>jenkins的安装与简单使用</title>
    <link href="http://wyzane.gitee.io/blog/2021/08/24/jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2021/08/24/jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-24T14:09:49.000Z</published>
    <updated>2021-08-24T14:33:36.249Z</updated>
    
    <content type="html"><![CDATA[<p>jenkins是一个持续集成和自动化部署的工具，使用它可以快速方便的部署项目。下面介绍下 jenkins 的安装、git中央仓库的创建，及使用 jenkins 实现自动化部署。</p><a id="more"></a><p>以下例子中使用的服务器是 Ubuntu 18.04。</p><h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 去官网下载 jdk: jdk-8u251-linux-i586.tar.gz</span><br><span class="line">2. 解压并配置环境变量，在配置文件 &#x2F;etc&#x2F;profile 中加入以下内容（路径可根据自己情况更改）：</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib:$CLASSPATH</span><br><span class="line">export JAVA_PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JRE_HOME&#125;&#x2F;bin</span><br><span class="line">export PATH&#x3D;$PATH:$&#123;JAVA_PATH&#125;</span><br><span class="line">3. 执行 source &#x2F;etc&#x2F;profile，并执行 java 查看是否安装成功</span><br><span class="line">4. 安装成功后，配置软连接 ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java</span><br><span class="line">5. 安装 jenkins</span><br><span class="line">1) wget -q -O - https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian&#x2F;jenkins.io.key | sudo apt-key add -</span><br><span class="line">2) sudo sh -c &#39;echo deb http:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian-stable binary&#x2F; &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;jenkins.list&#39;</span><br><span class="line">3) sudo apt-get update</span><br><span class="line">4) sudo apt-get install jenkins</span><br><span class="line">6. 安装完成后，查看jenkins的状态，jenkins默认运行在8080端口（可以在 &#x2F;etc&#x2F;default&#x2F;jenkins文件中修改默认端口）</span><br><span class="line">service jenkins status</span><br><span class="line">service jenkins start</span><br><span class="line">service jenkins restart</span><br></pre></td></tr></table></figure><h2 id="git中央仓库的搭建"><a href="#git中央仓库的搭建" class="headerlink" title="git中央仓库的搭建"></a>git中央仓库的搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 安装 git</span><br><span class="line">sudo apt install git</span><br><span class="line">2. 添加 git 用户，添加时输入密码</span><br><span class="line">adduser git</span><br><span class="line">3. 服务器打开 RSA 验证： vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config，添加下面的配置</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile  .ssh&#x2F;authorized_keys</span><br><span class="line">4. 切换到git用户，</span><br><span class="line">1）创建目录：mkdir .ssh</span><br><span class="line">2）生成密钥对：ssh-keygen -t rsa -C &quot;12345678@qq.com&quot;</span><br><span class="line">5. 在 .ssh 目录下添加 authorized_keys 文件，并把客户端的公钥添加到文件中</span><br><span class="line">6. 创建一个裸仓库：git init --bare pro1.git</span><br><span class="line">7. 在客户端克隆仓库： git clone git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;pro1.git</span><br></pre></td></tr></table></figure><h2 id="使用jenkins实现自动化部署"><a href="#使用jenkins实现自动化部署" class="headerlink" title="使用jenkins实现自动化部署"></a>使用jenkins实现自动化部署</h2><p>实现功能：使用jenkins将代码从一台服务器拉取到另一台服务器上，并将代码移动到指定目录中。</p><p>上面步骤中创建的 git 中央仓库就是此次例子中的源代码仓库。</p><p>配置 jenkins 前，我们需要先修改 jenkins 的配置文件，以便使用 jenkins 用户执行 shell 脚本时不会出现权限问题。修改步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 修改配置文件 &#x2F;etc&#x2F;default&#x2F;jenkins，让 jenkins 以 root 用户执行脚本</span><br><span class="line">JENKINS_USER&#x3D;&quot;root&quot;</span><br><span class="line">JENKINS_GROUP&#x3D;&quot;root&quot;</span><br><span class="line"></span><br><span class="line">2. 修改 jenkins 相关目录的属性</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;lib&#x2F;jenkins</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;cache&#x2F;jenkins</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;log&#x2F;jenkins</span><br><span class="line"></span><br><span class="line">3. 重启 jenkins 服务: service jenkins restart</span><br><span class="line">重启后，可能会遇到以下几个问题：</span><br><span class="line">1）mesg: ttyname failed: Inappropriate ioctl for device</span><br><span class="line">处理：使用 root 用户修改文件 &#x2F;root&#x2F;.profile，将 mesg n || true 替换成 tty -s &amp;&amp; mesg n。</span><br><span class="line">2）daemon: fatal: refusing to execute unsafe program: &#x2F;usr&#x2F;bin&#x2F;java (&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin is group and world writable)</span><br><span class="line">处理：执行 chmod -R 755 &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin</span><br><span class="line"></span><br><span class="line">4. 执行以上步骤后，重启服务器和 jenkins 服务就行了，下面就能使用 jenkins 执行 shell 脚本了。</span><br></pre></td></tr></table></figure><p>启动 jenkins 服务后，访问 127.0.0.1:8080，输入密码后进入jenkins。配置步骤如下：</p><p>首先，在 Dashboard 上创建一个 Item，输入 Item 名称并选择 Freestyle project。</p><p><img src="new_item.png" alt="new_item"></p><p>选择好以后，点击 OK。进入 Item 后，主要配置以下两个部分。</p><p>然后，配置源代码的 git 地址，如下图：</p><p><img src="source_code_git.png" alt="source_code_git"></p><p>配置 git 地址前，需要先在 jenkins 用户下创建秘钥（命令：ssh-keygen -t rsa -C “<a href="mailto:12345678@qq.com">12345678@qq.com</a>“），然后将生成的公钥放入 192.168.0.104 git用户下的 authorized_keys 文件中，否则会报错提示没有权限。</p><p>然后，再配置构建时要执行的 shell 脚本，如下图：</p><p><img src="build_shell.png" alt="build_shell"></p><p>上面的 shell 脚本就一行，将远程服务器上 git 仓库的代码拉取后（test目录，默认情况下，jenkins 会把拉取的代码放到其 workspace 目录下），再将代码放到 /home/wyzane/GitProject 目录下。</p><p>上图的 shell 脚本很简单，若需要执行其他的一些部署、重启服务等命令，可以再根据需要添加。</p><p>最后，可以保存并 Build 一下 Item，上面例子中控制台的输出日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Started by user wyzane</span><br><span class="line">Running as SYSTEM</span><br><span class="line">Building in workspace &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;test</span><br><span class="line">[WS-CLEANUP] Deleting project workspace...</span><br><span class="line">[WS-CLEANUP] Deferred wipeout is used...</span><br><span class="line">The recommended git tool is: NONE</span><br><span class="line">No credentials specified</span><br><span class="line">Cloning the remote Git repository</span><br><span class="line">Cloning repository git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git</span><br><span class="line"> &gt; git init &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;test # timeout&#x3D;10</span><br><span class="line">Fetching upstream changes from git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git</span><br><span class="line"> &gt; git --version # timeout&#x3D;10</span><br><span class="line"> &gt; git --version # &#39;git version 2.17.1&#39;</span><br><span class="line"> &gt; git fetch --tags --progress -- git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;* # timeout&#x3D;10</span><br><span class="line"> &gt; git config remote.origin.url git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git # timeout&#x3D;10</span><br><span class="line"> &gt; git config --add remote.origin.fetch +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;* # timeout&#x3D;10</span><br><span class="line">Avoid second fetch</span><br><span class="line"> &gt; git rev-parse refs&#x2F;remotes&#x2F;origin&#x2F;master^&#123;commit&#125; # timeout&#x3D;10</span><br><span class="line">Checking out Revision 8d114db052b5c4914e56a1e5848a2c5df9bca69e (refs&#x2F;remotes&#x2F;origin&#x2F;master)</span><br><span class="line"> &gt; git config core.sparsecheckout # timeout&#x3D;10</span><br><span class="line"> &gt; git checkout -f 8d114db052b5c4914e56a1e5848a2c5df9bca69e # timeout&#x3D;10</span><br><span class="line">Commit message: &quot;add test03&quot;</span><br><span class="line"> &gt; git rev-list --no-walk 8d114db052b5c4914e56a1e5848a2c5df9bca69e # timeout&#x3D;10</span><br><span class="line">[test] $ &#x2F;bin&#x2F;sh -xe &#x2F;tmp&#x2F;jenkins7411340475787087463.sh</span><br><span class="line">+ cp -r &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;test &#x2F;home&#x2F;wyzane&#x2F;GitProject</span><br><span class="line">Finished: SUCCESS</span><br></pre></td></tr></table></figure><p>jenkins 中还有很多其他配置项和插件，在后面还会整理一部分它们的使用方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jenkins是一个持续集成和自动化部署的工具，使用它可以快速方便的部署项目。下面介绍下 jenkins 的安装、git中央仓库的创建，及使用 jenkins 实现自动化部署。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>提高文本查询效率的几个命令</title>
    <link href="http://wyzane.gitee.io/blog/2021/05/22/%E6%8F%90%E9%AB%98%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/"/>
    <id>http://wyzane.gitee.io/blog/2021/05/22/%E6%8F%90%E9%AB%98%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/</id>
    <published>2021-05-22T13:15:54.000Z</published>
    <updated>2021-05-25T13:51:56.199Z</updated>
    
    <content type="html"><![CDATA[<p> 查找日志定位问题时，往往被查询的日志可能是一个很大的文件或者是压缩文件，查找时为了提高效率，我们可以使用 more、zgrep 等命令来查找。</p><a id="more"></a><h1 id="more"><a href="#more" class="headerlink" title="more"></a>more</h1><p>more 命令与 cat 命令类似，但是查找文件时，more 是一页一页的显示，这样更方便我们查找。</p><p>我们执行 more –help ，可以看看 more 有哪些参数可以使用。</p><p>more 的基本用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 空格键：往下显示一页</span><br><span class="line">2. b键：往上显示一页</span><br><span class="line">3. more +n：从第n行开始显示</span><br><span class="line">4. more -n: 自定义每页显示行数</span><br><span class="line">5. &#x2F;待查找字符串：查找特定的字符串</span><br><span class="line">6. q：退出more命令</span><br><span class="line"></span><br><span class="line">还可以使用 more --help 查看更多参数。</span><br></pre></td></tr></table></figure><h1 id="zgrep"><a href="#zgrep" class="headerlink" title="zgrep"></a>zgrep</h1><p>zgrep 命令与 grep 命令功能一样，只不过 zgrep 可以用来查找压缩文件中的特定内容而不用将文件解压，这对于查询大压缩文件的查找很有帮助。</p><p>zgrep 的基本用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. zgrep 待查找内容 压缩文件（若查找的是二进制文件，需要加上参数 -a，下同）</span><br><span class="line">2. zgrep -A n 待查找内容 压缩文件 （获取待查找内容的后面 n 行内容）</span><br><span class="line">3. zgrep -B n 待查找内容 压缩文件 （获取待查找内容的前面 n 行内容）</span><br><span class="line">4. zgrep -C n 待查找内容 压缩文件 （获取待查找内容的前后 n 行内容）</span><br></pre></td></tr></table></figure><p>类似的命令还有 zmore、zcat 等，感兴趣的同学可以下去学习一下。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>less  命令与 more 命令类似，但是功能比 more 更强大，它的基本用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">less用法：</span><br><span class="line">1. less 文件名 查找指定的文件</span><br><span class="line">常用参数：</span><br><span class="line"> -i：搜索时忽略大小写</span><br><span class="line"> -m：增加百分比的显示</span><br><span class="line"> -s：合并连续空行为一行</span><br><span class="line"> -N：显示行号</span><br><span class="line">2. d 向下翻页</span><br><span class="line">3. u 向上翻页</span><br><span class="line">4. g 跳到第一行</span><br><span class="line">5. G 跳到最后一行</span><br><span class="line">6. &#x2F;字符串：向下搜索字符串</span><br><span class="line">7. ?字符串：向上搜索字符串</span><br></pre></td></tr></table></figure><p>less 的更多用法，可以执行 less –help 查看。</p><p>以上就是文本查找中可能常用到的几个查找命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 查找日志定位问题时，往往被查询的日志可能是一个很大的文件或者是压缩文件，查找时为了提高效率，我们可以使用 more、zgrep 等命令来查找。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://wyzane.gitee.io/blog/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://wyzane.gitee.io/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵模式的配置与使用</title>
    <link href="http://wyzane.gitee.io/blog/2021/05/19/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2021/05/19/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-19T14:23:08.000Z</published>
    <updated>2021-05-22T12:57:46.219Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍下 Redis 哨兵模式的配置与使用方法。</p><p>在 Redis 中，哨兵是一个独立的进程，它用来监控 Redis 集群中中主从服务器的运行状态，当发现 Redis 主服务器宕机后，哨兵会从集群剩下服务器中重新选择一个主服务器，从而保证集群的正常运行，即保证 Redis 集群的高可用性。</p><a id="more"></a><p>以下例子中使用的 Redis 版本均为 6.0。</p><h1 id="哨兵模式的配置"><a href="#哨兵模式的配置" class="headerlink" title="哨兵模式的配置"></a>哨兵模式的配置</h1><p>以搭建三个哨兵为例，Redis 哨兵模式的配置步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 首先，进入 Redis 所在目录，复制三份 sentinel.conf 文件，分别命名为 sentinel01.conf、sentinel02.conf、sentinel03.conf</span><br><span class="line"></span><br><span class="line">2. 配置 sentinel01.conf 文件的如下内容：</span><br><span class="line">sentinel monitor mymaster 192.168.172.130 6379 2</span><br><span class="line"># 监控名为 mymaster 的主服务器，主服务器ip和端口为192.168.172.130，6379，当至少有两个sentinel同意时，该主服务器才会被判定为失效</span><br><span class="line"></span><br><span class="line">sentinel auth-pass mymaster &quot;wyzane&quot;</span><br><span class="line"># 设置连接主服务器的密码</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds mymaster 10000</span><br><span class="line"># 如果服务器在给定的毫秒数之内，没有返回 Sentinel 发送的 PING 命令的回复，或者返回一个错误，那么 Sentinel 将这个服务器标记为主观下线（subjectively down，简称 SDOWN ）。</span><br><span class="line"></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"># 指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步，这个数字越小，完成故障转移所需的时间就越长。</span><br><span class="line"></span><br><span class="line">3. 对 sentinel02.conf 和 sentinel03.conf 进行同样的配置</span><br></pre></td></tr></table></figure><p>配置完成后，使用以下方式启动哨兵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方式一，分别执行以下命令：</span><br><span class="line">redis-sentinel sentinel01.conf</span><br><span class="line">redis-sentinel sentinel02.conf</span><br><span class="line">redis-sentinel sentinel03.conf</span><br><span class="line">方式二，分别执行以下命令：</span><br><span class="line">redis-server sentinel01.conf --sentinel</span><br><span class="line">redis-server sentinel02.conf --sentinel</span><br><span class="line">redis-server sentinel03.conf --sentinel</span><br></pre></td></tr></table></figure><p>以上就是 Redis 哨兵的配置和启动，下面介绍下 Redis 哨兵模式的工作原理。</p><h1 id="哨兵模式的原理"><a href="#哨兵模式的原理" class="headerlink" title="哨兵模式的原理"></a>哨兵模式的原理</h1><p>哨兵模式运行的大致流程如下：</p><p>当 Redis 集群和 Redis 哨兵启动后，哨兵通过向主服务器和从服务器发送命令，来获取主、从服务器的运行状态，参数 sentinel down-after-milliseconds 用来控制，主、从服务器收到命令后返回响应的时间。如果在给定时间内，哨兵没有收到服务器发回的响应信息，那么该哨兵就将对应的服务器标记为主观下线状态(subjectively down，简称 SDOWN ），当有多个（一般是半数以上）哨兵都把该服务器标记为主观下线状态时，那么该服务器就被标记为客观下线（objectively down， 简称 ODOWN），此时才会发生故障迁移操作。</p><p>Redis 的 Sentinel 中关于下线（down）有两个不同的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</span><br><span class="line">2. 客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</span><br></pre></td></tr></table></figure><p>下面，我们来搭建一个含有一主两从的 Redis 集群，并配置三个哨兵，看一下哨兵是怎么运行的。</p><p>Redis 主从的配置就不多做介绍了，下面直接看启动后的日志信息。</p><p>Redis 主从信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主：192.168.172.131 6380</span><br><span class="line">从：192.168.172.131 6381</span><br><span class="line">从：192.168.172.131 6382</span><br></pre></td></tr></table></figure><p>启动 192.168.172.131 6380 和 192.168.172.131 6381 后，主服务器的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">16243:M 22 May 2021 00:56:23.056 * Replica 192.168.172.131:6381 asks for synchronization</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Full resync requested by replica 192.168.172.131:6381</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Replication backlog created, my new replication IDs are &#39;b643fa0d90a895b29c82b71446167e6b60d52283&#39; and &#39;0000000000000000000000000000000000000000&#39;</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Background saving started by pid 16254</span><br><span class="line">16254:C 22 May 2021 00:56:23.058 * DB saved on disk</span><br><span class="line">16254:C 22 May 2021 00:56:23.059 * RDB: 0 MB of memory used by copy-on-write</span><br><span class="line">16243:M 22 May 2021 00:56:23.095 * Background saving terminated with success</span><br><span class="line">16243:M 22 May 2021 00:56:23.097 * Synchronization with replica 192.168.172.131:6381 succeeded</span><br></pre></td></tr></table></figure><p>192.168.172.131 6381 服务器的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">16249:S 22 May 2021 00:56:23.054 * Master replied to PING, replication can continue...</span><br><span class="line">16249:S 22 May 2021 00:56:23.055 * Partial resynchronization not possible (no cached master)</span><br><span class="line">16249:S 22 May 2021 00:56:23.057 * Full resync from master: b643fa0d90a895b29c82b71446167e6b60d52283:0</span><br><span class="line">16249:S 22 May 2021 00:56:23.096 * MASTER &lt;-&gt; REPLICA sync: receiving 680 bytes from master to disk</span><br><span class="line">16249:S 22 May 2021 00:56:23.096 * MASTER &lt;-&gt; REPLICA sync: Flushing old data</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * Loading RDB produced by version 6.0.6</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * RDB age 0 seconds</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * RDB memory usage when created 1.83 Mb</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * MASTER &lt;-&gt; REPLICA sync: Finished with success</span><br></pre></td></tr></table></figure><p>上面的过程表示，从服务器连接上主服务器后，进行了数据的全量同步。同样的，启动 192.168.172.131 6382 后，数据也会进行全量同步。</p><p>下面再启动 Redis 哨兵。</p><p>执行 redis-sentinel sentinel.conf 后，哨兵服务器的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16392:X 22 May 2021 01:13:36.020 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.</span><br><span class="line">16392:X 22 May 2021 01:13:36.020 # Sentinel ID is 8fd93d8d9547434177903ba11cb5ae0bf603f358</span><br><span class="line">16392:X 22 May 2021 01:13:36.020 # +monitor master mymaster 192.168.172.131 6380 quorum 2</span><br><span class="line">16392:X 22 May 2021 01:13:36.022 * +slave slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380</span><br><span class="line">16392:X 22 May 2021 01:13:36.024 * +slave slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380</span><br></pre></td></tr></table></figure><p>若将主服务器的进程关掉，则哨兵的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">16481:X 22 May 2021 01:24:02.032 # +sdown master mymaster 192.168.172.131 6380（当前哨兵认为主服务器宕机，主观下线）</span><br><span class="line">16481:X 22 May 2021 01:24:02.093 # +odown master mymaster 192.168.172.131 6380 （有三个哨兵认为主服务器宕机，超过了两个，客观下线）#quorum 3&#x2F;2</span><br><span class="line">16481:X 22 May 2021 01:24:02.093 # +new-epoch 9（递增的集群版本号）</span><br><span class="line">16481:X 22 May 2021 01:24:02.093 # +try-failover master mymaster 192.168.172.131 6380（开始尝试对集群进行故障迁移）</span><br><span class="line">16481:X 22 May 2021 01:24:02.097 # +vote-for-leader 12e1af953d931b8ac097876d7bdf803ba39c52f6 9（选出一个哨兵，作为故障迁移的leader，当前哨兵，投票给 Sentinel ID 为 12e1af953d931b8ac097876d7bdf803ba39c52f6 的哨兵）</span><br><span class="line">16481:X 22 May 2021 01:24:02.103 # 2c2c810af7936fba2facbeb159b0f7fa1e87d325 voted for 2c2c810af7936fba2facbeb159b0f7fa1e87d325 9（其它哨兵投票）</span><br><span class="line">16481:X 22 May 2021 01:24:02.106 # 8fd93d8d9547434177903ba11cb5ae0bf603f358 voted for 12e1af953d931b8ac097876d7bdf803ba39c52f6 9（其它哨兵投票）</span><br><span class="line">16481:X 22 May 2021 01:24:02.187 # +elected-leader master mymaster 192.168.172.131 6380（当前的主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.188 # +failover-state-select-slave master mymaster 192.168.172.131 6380（分析从节点的状态）</span><br><span class="line">16481:X 22 May 2021 01:24:02.265 # +selected-slave slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（选出一个从节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.265 * +failover-state-send-slaveof-noone slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（将上面选出的从节点与现在的主节点进行主从切换）</span><br><span class="line">16481:X 22 May 2021 01:24:02.355 * +failover-state-wait-promotion slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（等待从节点升级成主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.531 # +promoted-slave slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（从节点已经升级为主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.532 # +failover-state-reconf-slaves master mymaster 192.168.172.131 6380（修改原来主节点的配置文件）</span><br><span class="line">16481:X 22 May 2021 01:24:02.586 * +slave-reconf-sent slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380（重写从节点的配置文件，即为从节点配置新的主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:03.229 # -odown master mymaster 192.168.172.131 6380</span><br><span class="line">16481:X 22 May 2021 01:24:03.565 * +slave-reconf-inprog slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380（从节点正在重新指向为新的主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:03.565 * +slave-reconf-done slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380（从节点配置完毕）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 # +failover-end master mymaster 192.168.172.131 6380（故障迁移结束）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 # +switch-master mymaster 192.168.172.131 6380 192.168.172.131 6382（故障迁移成功，哨兵开始监控新的主服务器）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 * +slave slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6382（确认新主节点的从节点）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 * +slave slave 192.168.172.131:6380 192.168.172.131 6380 @ mymaster 192.168.172.131 6382（确认新主节点的从节点）</span><br><span class="line">16481:X 22 May 2021 01:24:08.662 # +sdown slave 192.168.172.131:6380 192.168.172.131 6380 @ mymaster 192.168.172.131 6382（原主节点变为slave节点并且主观下线）</span><br></pre></td></tr></table></figure><p>上面的日志是哨兵发现主服务器宕机后，故障恢复的的一个过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天介绍下 Redis 哨兵模式的配置与使用方法。&lt;/p&gt;
&lt;p&gt;在 Redis 中，哨兵是一个独立的进程，它用来监控 Redis 集群中中主从服务器的运行状态，当发现 Redis 主服务器宕机后，哨兵会从集群剩下服务器中重新选择一个主服务器，从而保证集群的正常运行，即保证 Redis 集群的高可用性。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://wyzane.gitee.io/blog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Python3中生成器和协程的使用</title>
    <link href="http://wyzane.gitee.io/blog/2020/09/13/Python3%E4%B8%AD%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2020/09/13/Python3%E4%B8%AD%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-09-13T13:24:11.000Z</published>
    <updated>2020-09-14T14:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理下 Python3 中生成器和协程的使用。</p><a id="more"></a><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><h2 id="生成器输出数据"><a href="#生成器输出数据" class="headerlink" title="生成器输出数据"></a>生成器输出数据</h2><p>python 中可以使用 yield 关键字实现生成器，简单点说就是：一个函数中，如果包含 yield 关键字，那么这个函数就是一个生成器。下面看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""生成器：yield的使用</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    print(<span class="string">"=======start======="</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"=====flag:"</span>, flag)</span><br><span class="line">        flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">"========end========="</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""调用生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    t = test()</span><br><span class="line">    print(t)</span><br><span class="line">    print(next(t))</span><br><span class="line">    print(next(t))</span><br><span class="line">    print(next(t))</span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上面代码的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object test at 0x000001726581C2B0&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flag: 0</span><br><span class="line">0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flag: 1</span><br><span class="line">1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flag: 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>从上面的输出结果中可以看出，每次调用next()，都会从上一次结束的地方执行。 相当于遇到 yield 时，会跳出当前代码的执行，再次调用next()时，会从上一次跳出的地方开始执行 (即print(“========end=========”)这行代码试下一次执行的开始)。调用生成器时可以使用 next() 函数，也可以使用生成器的 <code>__next__</code>() 方法来获取值。</p><h2 id="生成器接收外部数据"><a href="#生成器接收外部数据" class="headerlink" title="生成器接收外部数据"></a>生成器接收外部数据</h2><p>在生成器中，yield 还可以接收外部传进来的值，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""生成器：yield接收外部传入的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        x = <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">"=====x:"</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"OK"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t = test()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 第一次调用生成器的send()方法时，传入一个None值，用于启动生成器。</span></span><br><span class="line">        <span class="comment"># 调用 send()，相当于调用 next()，执行到 yield 时，会返回 yield 后面的值</span></span><br><span class="line">        ret = t.send(<span class="literal">None</span>)</span><br><span class="line">        print(<span class="string">"=====ret1:"</span>, ret)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二次调用 send() 时，执行到 x = yield i 部分，相当于 x 接收到了通过 send() 传入的值</span></span><br><span class="line">        ret = t.send(<span class="number">9</span>)</span><br><span class="line">        print(<span class="string">"=====ret2:"</span>, ret)</span><br><span class="line"></span><br><span class="line">        ret = t.send(<span class="number">8</span>)</span><br><span class="line">        print(<span class="string">"=====ret3:"</span>, ret)</span><br><span class="line"></span><br><span class="line">        ret = t.send(<span class="number">7</span>)</span><br><span class="line">        print(<span class="string">"=====ret4:"</span>, ret)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exp:</span><br><span class="line">        print(<span class="string">"=====value:"</span>, exp.value)</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上面代码的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ret1: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;x: 9</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ret2: 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;x: 8</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;value: OK</span><br></pre></td></tr></table></figure><p>当生成器中 yield 后没有值返回时，再调用 send() 或者 next() 会抛出 StopIteration 异常，所以我们需要捕获该异常。若生成器中有返回值，可以在捕获异常时获取它。</p><h2 id="使用for循环遍历生成器"><a href="#使用for循环遍历生成器" class="headerlink" title="使用for循环遍历生成器"></a>使用for循环遍历生成器</h2><p>生成器中的值也可以通过 for 循环获取，类似于调用 next() 方法，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""使用 for 循环调用生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    t = test()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">        print(i)</span><br><span class="line">          </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>协程，更像是一个过程，类似线程和进程，协程是由调用方来控制程序执行和切换的过程。python 中的协程是由生成器转化而来，即通过扩展生成器的功能来实现协程。</p><p>python中，生成器和协程一样，都是使用了 yield 关键字的函数，但是通常来说，生成器仅仅是向外部输出数据，并将代码的执行交给调用方，协程不仅可以向外部输出数据，还能通过 send() 方法接收外部传进来的数据，即 yield data 和 x = yield data。yield 类似于一种控制流程的方式。</p><h1 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h1><p>一个含有 yield from 的方法也是一个生成器，与 yield 不同的是，yield from 后面如果跟一个生成器，那么可以直接调用这个生成器，而不再需要 next() 函数。yield from 后面也可一跟一个可迭代对象，此时相比于 for 循环加 yield 输出数据要方便。例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test01</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""yield from 后面可以跟一个可迭代对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test02</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""yield from 后面跟一个生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"=====start====="</span>)</span><br><span class="line">    ret = <span class="keyword">yield</span> <span class="keyword">from</span> test01()</span><br><span class="line">    <span class="comment"># 还可以获取子生成器的值</span></span><br><span class="line">    print(<span class="string">"=====ret:"</span>, ret)</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t = test02()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">"=====t1:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t2:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t3:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t4:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t5:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t6:"</span>, next(t))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上面到妈的输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t1: 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t2: 2</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t3: 3</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t4: 4</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t5: 5</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ret: ok</span><br></pre></td></tr></table></figure><p>可以看出，生成器 test02() 里面嵌套了一个生成器 test01()。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天整理下 Python3 中生成器和协程的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="python" scheme="http://wyzane.gitee.io/blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>openrestry的安装</title>
    <link href="http://wyzane.gitee.io/blog/2020/08/30/openresty%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://wyzane.gitee.io/blog/2020/08/30/openresty%E7%9A%84%E5%AE%89%E8%A3%85/</id>
    <published>2020-08-30T01:18:00.000Z</published>
    <updated>2020-09-06T07:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>OpenResty 是一个基于 Nginx 的可伸缩的 Web 平台，提供了很多高质量的第三方模块；它也是一个强大的 Web 应用服务器，开发人员可以使用 Lua 脚本语言调用 Nginx 支持的各种 C 以及 Lua 模块。</p><p>今天介绍下 OpenResty 在 Ubuntu 1804 上的安装。</p><a id="more"></a><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>安装依赖时，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libpcre3-dev libssl-dev perl make build-essential curl</span><br></pre></td></tr></table></figure><p>需要注意的是，执行上面的命令时，可能会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E: py3compile:243: Requested versions are not installed</span><br></pre></td></tr></table></figure><p>这是因为我们安装的 python3 版本与 py3compile 不一致引起的，py3compile 是属于 python3-minimal 的，我们只需要安装对应的 python3-minimal 即可。python3-minimal 的下载地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mirrors.edge.kernel.org&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;p&#x2F;python3-defaults&#x2F;</span><br></pre></td></tr></table></figure><p>下载完成后，执行以下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i python3-minimal_3.6.7-1~18.04_amd64.deb</span><br></pre></td></tr></table></figure><p>安装 python3-minimal 可能还会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#x2F;python3-minimal.postinst: py3compile: not found</span><br></pre></td></tr></table></figure><p>这是因为安装过程中，python3-minimal 会寻找 python3.6（根据安装版本不同而不同），我的系统中 /usr/bin 下只有python3，这时候添加一个 python3.6 的软链接即可。</p><h1 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h1><p>依赖安装完成后，可以到以下地址下载相应版本的 OpenResty ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;openresty.org&#x2F;cn&#x2F;download.html</span><br></pre></td></tr></table></figure><p>下载完成后，解压缩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf openresty-1.17.8.2.tar.gz</span><br></pre></td></tr></table></figure><p>执行配置及安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty --with-luajit</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>命令执行完成后，在 /usr/local 下会生成一个 openrestry 目录，里面就行 openrestry 的一些源码文件、配置文件和可执行文件。</p><p>其它系统的安装步骤可以参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;openresty.org&#x2F;cn&#x2F;installation.html</span><br></pre></td></tr></table></figure><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="hello-world的例子"><a href="#hello-world的例子" class="headerlink" title="hello world的例子"></a>hello world的例子</h2><p>我们可以在 /usr/local/openresty 目录下新建一个文件 conf/openrestry.conf 配置文件，文件内容如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">error_log</span> logs/error.log;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">                ngx.say("&lt;p&gt;hello, world&lt;/p&gt;")</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动 openrestry 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;conf&#x2F;openrestry.conf</span><br></pre></td></tr></table></figure><p>执行命令，请求 openrestry 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:8080&#x2F;</span><br></pre></td></tr></table></figure><p>请求后，会返回下面的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;hello, world&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h2 id="接收请求参数"><a href="#接收请求参数" class="headerlink" title="接收请求参数"></a>接收请求参数</h2><p>openresty 中接收客户端请求参数的配置为：</p><p>conf/params.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">                local params = ngx.req.get_uri_args();</span></span><br><span class="line"><span class="string">                ngx.print(params.name);</span></span><br><span class="line"><span class="string">                ngx.print(params.age);</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端请求 <a href="http://localhost:8080/test/?name=aaa&amp;age=12" target="_blank" rel="noopener">http://localhost:8080/test/?name=aaa&amp;age=12</a> 时，返回的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaa12</span><br></pre></td></tr></table></figure><p>ngx.req.get_uri_args 的用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args, err &#x3D; ngx.req.get_uri_args()，用于获取客户端请求 uri 中的参数。</span><br><span class="line"></span><br><span class="line">它的说明文档为：https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;lua-nginx-module#ngxreqget_uri_args</span><br></pre></td></tr></table></figure><p>其中，ngx.print() 函数的功能是将参数作为响应体返回给调用的客户端，未返回响应头时，首先返回响应头，再返回响应体。</p><p>还有一个 ngx.say() 方法，它与 ngx.print() 方法的功能一样，但是 ngx.say() 最后会返回一个换行符。</p><p>上面的方法 ngx.req.get_uri_args() 是接收 get 请求的参数，接收 post 请求参数的配置为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">                ngx.req.read_body();</span><br><span class="line">                <span class="attribute">local</span> params = ngx.req.get_post_args();</span><br><span class="line">                ngx.say(params.name);</span><br><span class="line">                ngx.say(params.age);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:8080&#x2F;test -X POST -d &#39;name&#x3D;aaa&amp;age&#x3D;12&#39;</span><br></pre></td></tr></table></figure><p>得到的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>接收 post 请求使用的是 ngx.req.get_post_args()。，在使用该方法之前，需要调用方法：ngx.req.read_body()。ngx.req.read_body() 的作用是：在不阻塞 nginx event loop 的请求下，异步读取客户端的请求体数据。</p><h2 id="内部调用"><a href="#内部调用" class="headerlink" title="内部调用"></a>内部调用</h2><p>在 openresty 中，可以进行内部 location 之间的调用，配置例子如下：</p><p>conf/inner.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">                local res = ngx.location.capture(</span></span><br><span class="line"><span class="string">                    "/getname", &#123;args=&#123;name=ngx.var["arg_name"], age=18&#125;&#125;</span></span><br><span class="line"><span class="string">                )</span></span><br><span class="line"><span class="string">                ngx.say(ngx.var["arg_name"]);</span></span><br><span class="line"><span class="string">                ngx.say("status:", res.status, " resp:", res.body)</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /getname &#123;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">                local params = ngx.req.get_uri_args();</span></span><br><span class="line"><span class="string">                ngx.print(params.name);</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，当访问 <a href="http://localhost:8080/test/?name=xxx" target="_blank" rel="noopener">http://localhost:8080/test/?name=xxx</a> 时，会打印出以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br><span class="line">status:200 resp:aaa</span><br></pre></td></tr></table></figure><p>配置文件中，ngx.location.capture 的作用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">功能：在 nginx 内部调用其它 location 块</span><br><span class="line">语法：res &#x3D; ngx.location.capture(uri, options)</span><br><span class="line">上面的配置文件中，它的作用域是 content_by_lua 开头的模块</span><br><span class="line"></span><br><span class="line">ngx.location.capture 会返回一个 lua table 对象，有以下4个属性：res.status, res.header, res.body, and res.truncated</span><br><span class="line"></span><br><span class="line">ngx.location.capture 的说明文档为：https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;lua-nginx-module#ngxlocationcapture</span><br></pre></td></tr></table></figure><h2 id="指定lua脚本文件"><a href="#指定lua脚本文件" class="headerlink" title="指定lua脚本文件"></a>指定lua脚本文件</h2><p>在 openresty 的 location 中，可以指定 lua 脚本来执行，配置例子为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> = /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">content_by_lua_file</span> /usr/local/openresty/lua_code/test.lua;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，使用 content_by_lua_file 来指定请求进来时需要运行的 lua 脚本文件。</p><p>test.lua 的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(&quot;lua test file&quot;);</span><br></pre></td></tr></table></figure><p>在终端执行  curl <a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a> 后，会返回 lua test file。</p><h2 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis"></a>连接redis</h2><p>openresty 中通过 lua 连接 redis 的例子如下：redis.lua：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-- redis use</span><br><span class="line"></span><br><span class="line">local resty_redis &#x3D; require(&#39;resty.redis&#39;)</span><br><span class="line">local redis &#x3D; resty_redis:new()</span><br><span class="line"></span><br><span class="line">redis:settimeout(1000)</span><br><span class="line"></span><br><span class="line">local ok, err &#x3D; redis:connect(&#39;127.0.0.1&#39;, 6379)</span><br><span class="line">if not ok then</span><br><span class="line">        ngx.say(err)</span><br><span class="line">        ngx.eof()</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 连接 redis 后进行密码验证</span><br><span class="line">local res, err &#x3D; redis:auth(&#39;wyzane&#39;)</span><br><span class="line">if not res then</span><br><span class="line">        ngx.say(&quot;failed to auth:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local res, err &#x3D; redis:get(&quot;name&quot;)</span><br><span class="line">if not res then</span><br><span class="line">        ngx.say(&quot;failed to get name:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ngx.say(res)</span><br><span class="line"></span><br><span class="line">local ok, err &#x3D; redis:set_keepalive(10000, 100)</span><br><span class="line">if not ok then</span><br><span class="line">        ngx.say(&quot;failed to set keeplive:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>redis.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line"></span><br><span class="line">        location &#x3D; &#x2F;test &#123;</span><br><span class="line">            default_type text&#x2F;html;</span><br><span class="line"></span><br><span class="line">            content_by_lua_file &#x2F;home&#x2F;wyzane&#x2F;lua_code&#x2F;redis.lua;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h2><p>openresty 中使用 lua 连接 mysql 的例子如下：mysql.lua：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql use</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> resty_mysql = <span class="built_in">require</span>(<span class="string">"resty.mysql"</span>)</span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">"cjson"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> db, err = resty_mysql:new()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> db <span class="keyword">then</span></span><br><span class="line">        ngx.say(<span class="string">'init mysql failed'</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">db:set_timeout(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ok, err, errcode, sqlstate = db:connect(&#123;</span><br><span class="line">    host = <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    post = <span class="number">3306</span>,</span><br><span class="line">    database = <span class="string">"test_koa"</span>,</span><br><span class="line">    user = <span class="string">"root"</span>,</span><br><span class="line">    password = <span class="string">"wyzane"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.say(<span class="string">"failed to connect mysql:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res, err, errcode, sqlstate = db:query(<span class="string">"select * from tb_user"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">        nga.say(<span class="string">"query failed:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">db:set_keepalive(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">ngx.say(cjson.encode(res))</span><br></pre></td></tr></table></figure><p>mysql.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> = /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">content_by_lua_file</span> /home/wyzane/lua_code/mysql.lua;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Openresty 官网：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;openresty.org&#x2F;cn&#x2F;</span><br></pre></td></tr></table></figure><p>Openresty的 github 地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;openresty</span><br></pre></td></tr></table></figure><p>Openresty最佳实践：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.kancloud.cn&#x2F;allanyu&#x2F;openresty-best-practices&#x2F;82658</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenResty 是一个基于 Nginx 的可伸缩的 Web 平台，提供了很多高质量的第三方模块；它也是一个强大的 Web 应用服务器，开发人员可以使用 Lua 脚本语言调用 Nginx 支持的各种 C 以及 Lua 模块。&lt;/p&gt;
&lt;p&gt;今天介绍下 OpenResty 在 Ubuntu 1804 上的安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://wyzane.gitee.io/blog/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx中处理http请求的流程</title>
    <link href="http://wyzane.gitee.io/blog/2020/08/02/nginx%E4%B8%AD%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://wyzane.gitee.io/blog/2020/08/02/nginx%E4%B8%AD%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B/</id>
    <published>2020-08-02T13:27:23.000Z</published>
    <updated>2023-02-26T08:50:52.339Z</updated>
    
    <content type="html"><![CDATA[<p>今天总结下 nginx 处理http请求的流程，重点介绍下处理 http 请求的11个阶段。</p><p>nginx 处理 http 请求时，首先会对请求行和请求体进行解析，解析完成后进入11 个阶段，这 11 个阶段会根据 nginx.conf 中的配置信息进行相应的重定向、权限控制、日志记录等操作。</p><a id="more"></a><h1 id="http请求的11个阶段"><a href="#http请求的11个阶段" class="headerlink" title="http请求的11个阶段"></a>http请求的11个阶段</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST_READ：读取到请求头之后会进入该阶段，realip模块在该阶段使用</span><br><span class="line">SERVER_REWRITE：执行server块内，location块外的指令，rewrite 模块在该阶段生效</span><br><span class="line">FIND_CONFIG：根据配置，寻找对应的 location 块并执行</span><br><span class="line">REWRITE：执行 location 块中的重写指令</span><br><span class="line">POST_REWRITE：根据上阶段的重写指令跳转到合适的阶段</span><br><span class="line">PREACCESS：访问权限控制之前的阶段，执行访问频率、连接数等控制</span><br><span class="line">ACCESS：访问权限的控制阶段，例如基于ip黑名单的权限控制</span><br><span class="line">POST_ACCESS：访问权限控制的后一阶段，该阶段根据权限控制阶段的执行结果进行相应处理</span><br><span class="line">PRECONTENT：try_files指令的处理阶段，如果没有配置try_files指令，则该阶段被跳过</span><br><span class="line">CONTENT：内容生成阶段，该阶段产生响应，并发送到客户端</span><br><span class="line">LOG：记录访问日志</span><br></pre></td></tr></table></figure><p>各个请求阶段的顺序如下：</p><p><img src="nginx%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B52.png" alt="nginx处理http请求的11个阶段2"></p><p>上面简单介绍了 nginx 处理 http 请求的各个阶段，以及各个阶段使用到的模块（导数第二行是 content 阶段，最后一行是 log 阶段）。下面具体介绍各个阶段的功能。</p><h2 id="POST-READ"><a href="#POST-READ" class="headerlink" title="POST_READ"></a>POST_READ</h2><p>解析完请求体后，首先会进入 post_read 阶段，该阶段主要获取客户端真实 ip。</p><h3 id="realip模块"><a href="#realip模块" class="headerlink" title="realip模块"></a>realip模块</h3><p>realip 模块在 POST_READ 节点生效，可以用来获取客户端的真实 ip 地址。</p><p>在 http 请求中，可以通过请求头中的 X-Forwarded-For 和 X-Real-IP 获取 ip 地址，X-Forwarded-For 中可能保存了多个</p><p>ip，X-Real-IP 中保存了客户端的真实 ip。realip 模块会把从 X-Forwarded-For 和 X-Real-IP 获取的值赋值到 nginx 变量 binary_remote_addr 和 remote_addr 中，从而通过这两个变量就能获取客户端真实 ip 地址，后续会进一步做限流、限速等工作（在 limit_conn 模块中）。</p><p>realip 模块默认没有编译进 nginx ，可以通过 –with-http_realip_module 参数将其编译进 nginx。</p><p>realip 中的指令（具体说明可以查阅官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html）" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_realip_module.html）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. set_real_ip_from addr|CIDR|unix;</span><br><span class="line">作用：设置信任地址，从该地址过来的请求会被获取真实地址，并替换 remote_addr 中的值</span><br><span class="line">例子：set_real_ip_from  192.168.1.0&#x2F;24|192.168.2.1;</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. real_ip_header field | X-Real-IP | X-Forwarded-For | proxy_protocol;</span><br><span class="line">作用：从请求头的哪个参数中获取真实ip</span><br><span class="line">例子：real_ip_header X-Real-IP（默认）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. real_ip_recursive on | off;</span><br><span class="line">作用：设置为 off 时，匹配信任地址（由 set_real_ip_from 设置）的真实客户端地址会被一个值替换，这个值是 real_ip_header 指定的请求头参数中最后一个值；为 on 时，真实客户端地址会被一个非信任值替代，这个值也是 real_ip_header 指定的请求头参数中的值</span><br></pre></td></tr></table></figure><p>realip 中指令的配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> realip.wzblogs.cn;</span><br><span class="line">    <span class="attribute">set_real_ip_from</span> <span class="number">223.73.212.4</span>;</span><br><span class="line">    <span class="attribute">real_ip_recursive</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="comment"># real_ip_recursive on;</span></span><br><span class="line">    <span class="attribute">real_ip_header</span> X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">"client real ip is：<span class="variable">$remote_addr</span>\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SERVER-REWRITE"><a href="#SERVER-REWRITE" class="headerlink" title="SERVER_REWRITE"></a>SERVER_REWRITE</h2><p>该阶段中，在 server 块内，location 块外的指令会被执行。</p><h3 id="rewrite模块"><a href="#rewrite模块" class="headerlink" title="rewrite模块"></a>rewrite模块</h3><p>rewrite 模块在 server_write 阶段生效，该模块主要功能是改变请求 URI，主要有以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">1. return code URL | return URL | return code [text]</span><br><span class="line">作用：停止请求的访问，并返回给客户端状态码和重定向url</span><br><span class="line">例子：return 302 &#x2F;redirect_url;</span><br><span class="line">上下文：server, location, if</span><br><span class="line"></span><br><span class="line">return 中的一些状态码：</span><br><span class="line">HTTP 1.0：</span><br><span class="line">301 永久重定向（访问站点a时，被重定向到站点b，则下次遇到访问站点a的请求就会直接访问站点b）</span><br><span class="line">302 临时重定向，禁止被缓存（访问站点a时，被重定向到站点b，则下次还会先访问站点a，再被重定向到b）</span><br><span class="line"></span><br><span class="line">HTTP 1.1:</span><br><span class="line">303 临时重定向，允许改变请求方法，禁止被缓存</span><br><span class="line">307 临时重定向，不允许改变请求方法，禁止被缓存</span><br><span class="line">308 永久重定向，不允许改变请求方法</span><br><span class="line"></span><br><span class="line">error_page 指令与 return 指令的不同</span><br><span class="line">error_page code uri;</span><br><span class="line">作用：nginx接收到指定状态码时，返回特定的页面或者uri</span><br><span class="line">例子： error_page 404 &#x2F;404.html;|error_page 500 501 502 503 &#x2F;50x.html;</span><br><span class="line">error_page 404 &#x3D;200 &#x2F;empty.gif (接收到404时，返回一张图片，响应状态码是200)</span><br><span class="line">上下文：http, server, location, if in location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. rewrite regex replacement [flag]</span><br><span class="line">作用：用于修改接收到的uri，如果如果正则表达式匹配uri，则匹配的uri会被replacement替换。其中 flag 有以下几个值：last,break,redirect,permanent</span><br><span class="line">last： 使用 replacement 继续进行 location匹配</span><br><span class="line">break: 停止当前脚本指令的执行，等价于独立的 break 指令</span><br><span class="line">redirect: 返回302重定向</span><br><span class="line">permanent: 返回301重定向</span><br><span class="line">上下文：server, location, if</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. rewrite_log on | off;</span><br><span class="line">作用：是否记录 rewrite 模块产生的日志，默认为 off，为 on 时，会将日志记录在 error_log 指定的文件中</span><br><span class="line">上下文：http, server, location, if</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. if (condition) &#123; ... &#125;</span><br><span class="line">作用：判断变量的值，如果满足条件，则执行 if 块中的内容</span><br><span class="line">上下文：server, location</span><br><span class="line">condition中可以有下面的功能：</span><br><span class="line">1. 检查变量为空或者为0</span><br><span class="line">2. 将变量与字符串做匹配，使用&#x3D;或者!&#x3D;</span><br><span class="line">3. 将变量与正则表达式匹配</span><br><span class="line">4. 检查文件是否存在，使用 -f 或者 !-f</span><br><span class="line">5. 检查目录是否存在，使用 -d 或者 !-d</span><br><span class="line">6. 检查文件、目录、软链接是否存在，使用 -e 或者 !-e</span><br><span class="line">7. 检查是否为可执行文件，使用 -x 或者 !-x</span><br><span class="line"></span><br><span class="line">if 中也可以使用正则表达式匹配，正则表达式规则如下：</span><br><span class="line">&#x3D;&#x3D;:等值比较;</span><br><span class="line">~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br><span class="line">!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br></pre></td></tr></table></figure><h3 id="error-page与return的优先级"><a href="#error-page与return的优先级" class="headerlink" title="error_page与return的优先级"></a>error_page与return的优先级</h3><p>return.conf 的配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8095</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line">    <span class="attribute">error_page</span>  <span class="number">404</span> /<span class="number">403</span>.html;</span><br><span class="line">    <span class="comment"># return 405;</span></span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">        <span class="comment"># return 404 "find nothing\n";</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 nginx 后，执行请求 curl localhost:8095/xxx，会直接返回 html/403.html 中的内容；当打开 location 块中的 return 后，会返回 “find nothing”；同样的，将 server 块中的 return 打开，同样的请求，会返回 405 的错误；这说明 return 指令会覆盖 它前面的 error_page 指令。</p><h3 id="rewrite与return的使用"><a href="#rewrite与return的使用" class="headerlink" title="rewrite与return的使用"></a>rewrite与return的使用</h3><p>下面看一个 rewrite 指令的使用例子，rewrite.conf 配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /first &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /first(.*) /second<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'first\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /second &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /second(.*) /third<span class="variable">$1</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'second\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /third &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'third\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /redirect &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /redirect(.*) <span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，html 目录的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 403.html</span><br><span class="line">├── 50x.html</span><br><span class="line">├── first</span><br><span class="line">│   └── 1.txt</span><br><span class="line">├── index.html</span><br><span class="line">├── second</span><br><span class="line">│   └── 2.txt</span><br><span class="line">└── third</span><br><span class="line">    └── 3.txt</span><br></pre></td></tr></table></figure><p>启动 nginx 服务后，执行 curl localhost:8096/first/3.txt，返回的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">second</span><br></pre></td></tr></table></figure><p>可以看到，先匹配到了 location /first，然后再去匹配 location /second，最后执行了 return 指令，返回了结果。</p><p>在 location /second 中的 rewrite 指令后加上 break 后，返回的内容就是 third/3.txt 文件中的内容，此时说明 break 指令生效了，此时访问  curl localhost:8096/second/3.txt 也会得到相同结果。</p><h3 id="if-指令使用例子"><a href="#if-指令使用例子" class="headerlink" title="if 指令使用例子"></a>if 指令使用例子</h3><p>if 指令使用例子如下，server_if.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8097;</span><br><span class="line"></span><br><span class="line">    if ($request_uri ~* &#x2F;aaa&#x2F;test.html)&#123;</span><br><span class="line">        return 200 &quot;test.html returned\n&quot;;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        return 200 &quot;location returned\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 curl localhost:8097/aaa/test.html 时，会进入 if 块中，返回 test.html returned。</p><h2 id="FIND-CONFIG"><a href="#FIND-CONFIG" class="headerlink" title="FIND_CONFIG"></a>FIND_CONFIG</h2><p>find_config 阶段主要功能是选择哪个 location 块，并执行 location 块中的配置。location 块中常用指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location </span><br><span class="line">上下文：server，location</span><br><span class="line">location 后面可以跟以下数据：</span><br><span class="line">1. 前缀字符串</span><br><span class="line">&#x3D;：精确匹配</span><br><span class="line">^~：匹配成功后，则不再进行正则表达式匹配</span><br><span class="line">常规字符串</span><br><span class="line">2. 正则表达式</span><br><span class="line">~：大小写敏感</span><br><span class="line">~*：忽略大小写</span><br><span class="line">3. 内部跳转的命名location（使用@符号 + 名称）</span><br></pre></td></tr></table></figure><p>当 nginx 中配置了多个 location 块时，它的匹配规则是怎么样的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 首先会遍历所有前缀字符串，找到匹配的 location （与 location 顺序无关）</span><br><span class="line">1）&#x3D; 精确匹配优先级最高</span><br><span class="line">2）没有精确匹配时使用 ^~ 匹配上的location</span><br><span class="line">3）当有多个匹配上时，选择 location 中 url 最长的匹配 </span><br><span class="line">2. 按照正则表达式匹配（此时会根据 location 的顺序进行匹配）</span><br><span class="line">1）按照正则表达式，匹配上则使用该 location</span><br></pre></td></tr></table></figure><p>下面看一下 location 指令使用的具体例子，location.conf的配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8099</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    <span class="attribute">location</span> /aaa &#123;</span><br><span class="line">        <span class="comment"># 前缀匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'prefix string match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /aaa/$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配，大小写敏感</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex strict match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* /aaa/$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配，忽略大小写</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex none strice match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4</span></span><br><span class="line">    <span class="attribute">location</span> /aaa/bbb &#123;</span><br><span class="line">        <span class="comment"># 前缀最长匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'long prefix string match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* /aaa/(\w+)$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'long regex match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /aaa$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7</span></span><br><span class="line">    <span class="attribute">location</span> = /aaa &#123;</span><br><span class="line">        <span class="comment"># 精确匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'exatc match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 8</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /aaa &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'^~ match \n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当有前缀匹配、正则匹配、^~匹配、精确匹配时，优先精确匹配、其次^~匹配、然后正则匹配、最后前缀匹配，对应上面配置的顺序为7861</span><br><span class="line">curl localhost:8099&#x2F;aaa                                 </span><br><span class="line">响应：exatc match</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 正则匹配，优先匹配区分大小写的配置</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;                                </span><br><span class="line">响应：regex strict match</span><br><span class="line"></span><br><span class="line"># 正则匹配，不区分大小写</span><br><span class="line">curl localhost:8099&#x2F;Aaa&#x2F;</span><br><span class="line">响应：regex none strice match</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 正则匹配，优先匹配5中的配置而不是4</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;bbb</span><br><span class="line">响应：long regex match</span><br><span class="line"></span><br><span class="line"># 正则表达式未匹配到，使用字符串最长匹配规则，匹配4而不是5</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;bbb&#x2F;</span><br><span class="line">long prefix string match</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ^~，匹配后，则不再使用正选择匹配</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;ccc                             </span><br><span class="line">响应：^~ match </span><br><span class="line"></span><br><span class="line">如果加上配置：</span><br><span class="line">location &#x2F;aaa&#x2F;ccc &#123;</span><br><span class="line">    # 前缀最长匹配</span><br><span class="line">    return 200 &#39;long prefix string match ccc\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">则 curl localhost:8099&#x2F;aaa&#x2F;ccc 会返回 long prefix string match ccc</span><br></pre></td></tr></table></figure><h2 id="PREACCESS"><a href="#PREACCESS" class="headerlink" title="PREACCESS"></a>PREACCESS</h2><p>preaccess 阶段主要功能是对客户端的请求数或者连接数进行限制。</p><p>限制连接数时，需要用到 nginx 的 ngx_http_limit_conn_module 模块，限制请求数时，要使用 ngx_http_limit_req_module 模块。</p><h3 id="limit-conn"><a href="#limit-conn" class="headerlink" title="limit_conn"></a>limit_conn</h3><p>ngx_http_limit_conn_module 模块的生效范围是全部worker（基于共享内存），并且限制的有效性取决于 key 的设计（依赖于 postread 阶段中realip模块取到的真实ip）。 </p><p>常用指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone key zone&#x3D;name:size;</span><br><span class="line">功能：为一块共享内存指定一个 key，会记录每个 key 的状态（状态中包含了 key 对应的当前连接数）</span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_conn zone number;</span><br><span class="line">功能：限制 key 的并发连接数</span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_conn_log_level info | notice | warn | error;（默认 error）</span><br><span class="line">功能：发生限制并发连接时，打印日志的格式</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_conn_status code;（默认 503）</span><br><span class="line">功能：发生并发连接数限制时，向客户端返回的状态码</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><p>限制客户端连接数的配置例子为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=addr:<span class="number">10m</span>;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8099</span>;</span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line">    <span class="attribute">error_log</span>  logs/err_limit.log <span class="literal">info</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_conn_status</span> <span class="number">503</span>;</span><br><span class="line">        <span class="attribute">limit_conn_log_level</span>  <span class="literal">warn</span>;</span><br><span class="line">        <span class="comment"># 限制向客户端返回数据的速率（每秒50字节）</span></span><br><span class="line">        <span class="attribute">limit_rate</span> <span class="number">50</span>;</span><br><span class="line">        <span class="attribute">limit_conn</span> addr <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="limit-req"><a href="#limit-req" class="headerlink" title="limit_req"></a>limit_req</h3><p>ngx_http_limit_req_module 模块的生效范围也是全部 worker  进程，使用的算法是 leaky bucket 算法。</p><p>常用指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone key zone&#x3D;name:size rate&#x3D;rate;</span><br><span class="line">功能：与 limit_conn_zone 功能类似，定义共享内存大小，以及根据 key 关键字限制速率，rate 是每秒或每分钟处理的请求数（r&#x2F;s、r&#x2F;m）</span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req limit_req zone&#x3D;name [burst&#x3D;number] [nodelay | delay&#x3D;number];</span><br><span class="line">功能：限制并发连接数，burst表示最大请求数，nodelay表示对burst中的请求立刻处理</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req_log_level info | notice | warn | error;</span><br><span class="line">功能：限制发生时的日志级别</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req_status code;</span><br><span class="line">功能：限制发生时，返回给客户端的状态码</span><br><span class="line">上下文: http, server, location</span><br></pre></td></tr></table></figure><p>限制客户端请求数的配置例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 每分钟处理两次请求</span><br><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;req:10m rate&#x3D;2r&#x2F;m;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8099;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log  logs&#x2F;err_limit.log info;</span><br><span class="line">   </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        limit_req zone&#x3D;req burst&#x3D;3 nodelay;</span><br><span class="line">        # limit_req zone&#x3D;req;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当同时配置了 limit_conn 和 limit_req 时，由于 limt_req 模块在 limit_conn 模块之前，所以 limit_req 模块会先返回，limit_conn 模块则不会返回。</p><h2 id="ACCESS"><a href="#ACCESS" class="headerlink" title="ACCESS"></a>ACCESS</h2><p>access 阶段主要负责对 ip 访问的权限控制，常用模块 ngx_http_access_module（用户对 ip 做限制）、 ngx_http_auth_basic_module（校验用户名和密码）、ngx_http_auth_request_module（使用第三方的权限验证）</p><p>与 access 阶段相关的一个指令 satisfy ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">satisfy all | any;</span><br><span class="line">功能：配置为all时，所有模块（ngx_http_access_module, ngx_http_auth_basic_module, ngx_http_auth_request_module, ngx_http_auth_jwt_module）通过时，请求才能继续；为 any 时，至少有一个模块通过请求才能继续。默认为 all</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><p>access （ngx_http_access_module）模块常用指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allow address | CIDR | unix: | all;</span><br><span class="line">功能：允许哪些地址访问</span><br><span class="line">上下文：http, server, location, limit_except</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deny address | CIDR | unix: | all;</span><br><span class="line">功能：不允许哪些地址访问</span><br><span class="line">上下文：http, server, location, limit_except</span><br></pre></td></tr></table></figure><p>配置例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    deny 192.168.1.1;</span><br><span class="line">    allow 192.168.1.0&#x2F;24;</span><br><span class="line">    allow 10.1.1.0&#x2F;16;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auth_basic（ngx_http_auth_basic_module） 模块常用指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auth_basic string | off;</span><br><span class="line">功能：开启或者禁用 auth_basic，默认off，string表示浏览器上标签页显示的对话框名称</span><br><span class="line">上下文：http, server, location, limit_except</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth_basic_user_file file;</span><br><span class="line">功能：指定用户名、密码配置文件</span><br><span class="line">上下文：http, server, location, limit_except</span><br></pre></td></tr></table></figure><p>配置例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8099;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        satisfy any;</span><br><span class="line">        auth_basic &#39;auth_test&#39;;</span><br><span class="line">        # 指定密码文件为 passwd&#x2F;user.pass</span><br><span class="line">        auth_basic_user_file passwd&#x2F;user.pass;</span><br><span class="line">        deny all;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auth_request（ngx_http_auth_request_module） 模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原理：收到请求后，生成一个子请求，通过反向代理把子请求传到上游第三方服务器，根据上游服务器返回的响应来处理收到的原请求。若上游服务器范围的状态码为 2xx，则允许请求继续，若范围的是 401 或者 403，则将请求返回给客户端。</span><br></pre></td></tr></table></figure><p>常用指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auth_request uri | off;</span><br><span class="line">功能：配置子请求访问的url，默认为off</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth_request_set $variable value;</span><br><span class="line">功能：权限校验完成后，设置新的变量和值，值中可以包含上游请求的一些信息</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h2 id="PRECONTENT阶段"><a href="#PRECONTENT阶段" class="headerlink" title="PRECONTENT阶段"></a>PRECONTENT阶段</h2><h3 id="try-files模块"><a href="#try-files模块" class="headerlink" title="try_files模块"></a>try_files模块</h3><p>try_files 模块中有一个 try_files 指令，其功能如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能：依次访问文件，当文件存在时，返回文件中的内容，后面的文件将不再访问，若文件都不存在，返回最后的 url 或者 code</span><br><span class="line">语法：try_files file1 file2 file3 ... uri|&#x3D;code;</span><br><span class="line">上下文：server, location</span><br></pre></td></tr></table></figure><p>使用例子如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8090</span>;</span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /first &#123;</span><br><span class="line">        <span class="attribute">try_files</span> /tmp/index.html <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html <span class="variable">$uri</span>.html <span class="variable">@lasturl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@lasturl</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'lasturl \n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /second &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mirror模块"><a href="#mirror模块" class="headerlink" title="mirror模块"></a>mirror模块</h3><p>mirror 模块具有实时流量拷贝的功能，可以把生产环境的请求拷贝一份到测试环境中。该模块中提供了以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. mirror</span><br><span class="line">功能：处理请求时，生成子请求访问其他服务，对于子请求的返回值则不做处理</span><br><span class="line">语法：mirror uri | off(默认);</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. mirror_request_body</span><br><span class="line">功能：是否把请求体也转发到其他服务</span><br><span class="line">语法：mirror_request_body on(默认) | off;</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h2 id="CONTENT阶段"><a href="#CONTENT阶段" class="headerlink" title="CONTENT阶段"></a>CONTENT阶段</h2><h3 id="static模块"><a href="#static模块" class="headerlink" title="static模块"></a>static模块</h3><p>content阶段中有一个 static 模块，它提供了两个我们常用的指令：root 和 alias，这两个指令的功能都是将 url 映射为文件路径，以返回静态文件中的内容。其中 root 将完整的 url 映射为文件路径，alias 将 location 后的 url 映射为文件路径。两个指令的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. root</span><br><span class="line">语法：root path; （默认：root html）</span><br><span class="line">上下文：http, server, location, if in location</span><br><span class="line"></span><br><span class="line">2. alias</span><br><span class="line">语法：alias path;（无默认值）</span><br><span class="line">上下文：location</span><br></pre></td></tr></table></figure><p>static 模块中还提供了三个静态文件相关的变量：request_filename（待访问文件的完整路径）、document_root（由 URI 和 root/alias 指定的规则生成的文件对应的目录）、realpath_root（若document_root中有软链接，则会将软链接替换成真实路径）。</p><p>static模块中还提供了以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. types</span><br><span class="line">功能：映射文件扩展名和响应中的 content-type</span><br><span class="line">语法：types &#123;text&#x2F;html  html; image&#x2F;gif  gif; image&#x2F;jpeg jpg;&#125;</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. default_type</span><br><span class="line">功能：设置响应中默认的 content-type</span><br><span class="line">语法：default_type mime-type;</span><br><span class="line">默认：default_type text&#x2F;plain;</span><br><span class="line">上下文: http, server, location</span><br></pre></td></tr></table></figure><h3 id="index模块"><a href="#index模块" class="headerlink" title="index模块"></a>index模块</h3><p>index 模块的功能是：当访问的 url 以 / 结尾时，index 模块就会寻找该目录下是否有 index.html 文件，如果有，就会将 index.html 的内容返回。可以通过 index 指令指定要寻找的文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：index file;</span><br><span class="line">默认：index index.html;</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h3 id="autoindex模块"><a href="#autoindex模块" class="headerlink" title="autoindex模块"></a>autoindex模块</h3><p>audoindex 模块的功能是：当请求 url 以 / 结尾时，会尝试以 html/xml/jspn/jsonp 等形式返回 root/alias 所指向目录的目录结构。指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. autoindex</span><br><span class="line">功能：展示或者不展示目录结构</span><br><span class="line">用法：autoindex on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. autoindex_format</span><br><span class="line">功能：显示的格式</span><br><span class="line">用法：autoindex_format html | xml | json | jsonp;（默认 html）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. autoindex_localtime</span><br><span class="line">功能：是否显示本地时间（仅 html 格式生效）</span><br><span class="line">用法：autoindex_localtime on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. autoindex_exact_size</span><br><span class="line">功能：是否显示文件大小（仅 html 格式生效）</span><br><span class="line">用法：autoindex_exact_size on | off;（默认 off，显示字节数）</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h3 id="concat-模块"><a href="#concat-模块" class="headerlink" title="concat 模块"></a>concat 模块</h3><p>concat 模块的功能是：可以把多个小文件的内容合并到一个 http 响应中返回。该模块的 github 地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nginx-http-concat</span><br></pre></td></tr></table></figure><p>当请求多个文件内容时，请求url后需要跟两个?，再配合该模块，就可以接收多个文件的内容，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;example.com&#x2F;??style1.css,style2.css,foo&#x2F;style3.css</span><br><span class="line">http:&#x2F;&#x2F;example.com&#x2F;xxx&#x2F;??style1.css,style2.css,foo&#x2F;style3.css</span><br></pre></td></tr></table></figure><p>下载后，可以通过 –add-modules 来安装该模块。它提供的指令有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. concat</span><br><span class="line">功能：是否启用合并功能</span><br><span class="line">用法：concat on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. concat_types</span><br><span class="line">功能：指定对哪些文件类型做合并</span><br><span class="line">用法：concat_types MIME types</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. concat_delimiter</span><br><span class="line">功能：返回多个文件时，指定文件内容的分隔符</span><br><span class="line">用法：concat_delimiter: string;</span><br><span class="line">上下文：http, server, locatione</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. concat_unique</span><br><span class="line">功能：是否仅对一种文件类型合并</span><br><span class="line">用法：concat_unique on | off;（默认 on, 仅对一种文件类型合并）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. concat_ignore_file_error</span><br><span class="line">功能：是否忽略文件不存在等错误</span><br><span class="line">用法：concat_ignore_file_error: on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. concat_max_files</span><br><span class="line">功能：指定最多合并的文件数量</span><br><span class="line">用法：concat_max_files number（默认 10）</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h2 id="LOG阶段"><a href="#LOG阶段" class="headerlink" title="LOG阶段"></a>LOG阶段</h2><p>log阶段中有 log 模块，它的功能是把 http 请求相关的信息记录到日志文件中。常用指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. log_format</span><br><span class="line">功能：定义日志的格式</span><br><span class="line">用法：log_format name [escape&#x3D;default|json|none] string ...;</span><br><span class="line">默认：log_format combined &#39;...&#39;;（日志有一个默认格式）</span><br><span class="line">上下文: http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. access_log</span><br><span class="line">功能：指定日志文件路径和格式</span><br><span class="line">用法：access_log path [format [buffer&#x3D;size] [gzip[&#x3D;level]] [flush&#x3D;time] [if&#x3D;condition]];</span><br><span class="line">默认：access_log path combined;</span><br><span class="line">上下文：http, server, location, if in location, limit_except</span><br><span class="line"></span><br><span class="line">access_log 后的 path 中可以包含变量，它后面也可以跟 buffer、gzip、flush等参数，这些参数有如下功能：</span><br><span class="line">1. 日志缓存：批量将内存中的日志写入缓存中，写入磁盘的条件有1）所欲待写入磁盘的日志大小超出缓存大小 2）达到 flush 指定的过期时间 3）worker进程执行 reopen 命令</span><br><span class="line">2. 日志压缩：批量压缩内存中的日志，再写入磁盘，buffer参数值的默认大小为64k，压缩级别默认为1（1最快压缩压缩率最低 9最慢压缩压缩率最高）</span><br></pre></td></tr></table></figure><p>….. 未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天总结下 nginx 处理http请求的流程，重点介绍下处理 http 请求的11个阶段。&lt;/p&gt;
&lt;p&gt;nginx 处理 http 请求时，首先会对请求行和请求体进行解析，解析完成后进入11 个阶段，这 11 个阶段会根据 nginx.conf 中的配置信息进行相应的重定向、权限控制、日志记录等操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://wyzane.gitee.io/blog/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>django开发之在docker中部署项目</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/26/django%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9C%A8docker%E4%B8%AD%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/26/django%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9C%A8docker%E4%B8%AD%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-07-26T07:51:27.000Z</published>
    <updated>2020-07-26T08:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理了一下如何在docker中部署django项目。</p><a id="more"></a><h1 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.6 django2.0.5 nginx mysql5.7 gunicorn</span><br></pre></td></tr></table></figure><h1 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h1><p>项目主目录为 blog 目录，需要编写的文件包括（省去了其他django文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog&#x2F;Dockerfile, blog&#x2F;gunicorn.conf, blog&#x2F;start.sh, nginx&#x2F;Doickerfile, nginx&#x2F;nginx.conf, docker-conpose.yml</span><br></pre></td></tr></table></figure><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><h2 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h2><p>blog/Dockerfile 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6    # 选择基础镜像,这里的基础镜像也可以选择ubuntu,centos等，但是下面的配置就会发生变化</span><br><span class="line"></span><br><span class="line"># 创建工作目录</span><br><span class="line">RUN mkdir &#x2F;blog  </span><br><span class="line"></span><br><span class="line">#设置工作目录</span><br><span class="line">WORKDIR &#x2F;blog</span><br><span class="line"></span><br><span class="line">#将当前目录加入到工作目录中</span><br><span class="line">ADD . &#x2F;blog</span><br><span class="line">RUN pip3 install -r requirements.txt</span><br><span class="line">#对外暴露端口</span><br><span class="line">EXPOSE 80 8080 8000 5000</span><br><span class="line">#设置环境变量</span><br><span class="line">ENV SPIDER&#x3D;&#x2F;blog</span><br></pre></td></tr></table></figure><p>上面基础镜像使用的是python:3.6,而不是ubuntu、centos。如果是ubuntu、cenos，Dockerfile文件中需要配置python环境</p><p>nginx/Doickerfile 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx    # nginx镜像，最好是先拉取到本地</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对外暴露端口</span><br><span class="line">EXPOSE 80 8000</span><br><span class="line"></span><br><span class="line">RUN rm &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf  # 删除原有配置文件</span><br><span class="line">ADD nginx.conf  &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;   # 添加配置文件</span><br><span class="line">RUN mkdir -p &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static  # 创建静态资源文件夹</span><br></pre></td></tr></table></figure><p>docker-compose.yml 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">    image: mysql:5.7  # mysql镜像，最好先拉取到本地</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_HOST&#x3D;localhost</span><br><span class="line">      - MYSQL_DATABASE&#x3D;docker</span><br><span class="line">      - MYSQL_USER&#x3D;root</span><br><span class="line">      - MYSQL_PASSWORD&#x3D;wyzane</span><br><span class="line">      - MYSQL_ROOT_PASSWORD&#x3D;wyzane</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;home&#x2F;wyzane&#x2F;pyprojects&#x2F;db:&#x2F;var&#x2F;lib&#x2F;mysql  # 将宿主机与容器中的文件映射</span><br><span class="line">    restart: always  # 若容器运行出现问题，会自动重启容器</span><br><span class="line"></span><br><span class="line">  web:</span><br><span class="line">    build: .&#x2F;blog</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;8000:8000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;blog:&#x2F;blog</span><br><span class="line">    - &#x2F;tmp&#x2F;logs:&#x2F;tmp</span><br><span class="line">    command: bash start.sh  # 执行命令，有多种格式</span><br><span class="line">    links:</span><br><span class="line">    - db</span><br><span class="line">    depends_on:</span><br><span class="line">    - db</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">nginx:</span><br><span class="line">    build: .&#x2F;nginx</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;blog&#x2F;static:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static:ro</span><br><span class="line">    links:</span><br><span class="line">    - web</span><br><span class="line">    depends_on:</span><br><span class="line">    - web</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure><h2 id="gunicorn配置"><a href="#gunicorn配置" class="headerlink" title="gunicorn配置"></a>gunicorn配置</h2><p>blog/gunicorn.conf 的配置内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workers&#x3D;2</span><br><span class="line">bind&#x3D;&#39;0.0.0.0:8000&#39;</span><br><span class="line">proc_name&#x3D;&#39;blog&#39;</span><br></pre></td></tr></table></figure><h2 id="start文件配置"><a href="#start文件配置" class="headerlink" title="start文件配置"></a>start文件配置</h2><p>blog/start.sh 文件内容如下，用于启动项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">python manage.py collectstatic --noinput&amp;&amp;</span><br><span class="line">python manage.py makemigrations&amp;&amp;</span><br><span class="line">python manage.py migrate &amp;&amp;</span><br><span class="line">gunicornblog.wsgi:application -c gunicorn.conf</span><br></pre></td></tr></table></figure><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>nginx/nginx.conf 文件配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location &#x2F;static &#123;</span><br><span class="line">        alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;web:8000;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h1><p>配置完成后，依次执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>执行完成后，通过 docker images 命令可以查看新增了2个镜像，docker ps 命令可以查看启动了3个容器。</p><p>多执行几次docker ps，当容器的STATUS是以Restarting开头时，表示这个容器运行时发生了错误。执行docker logs CONTAINERID可以查看容器出错的具体原因。</p><p>若上述容器都成功运行，则在浏览器中输入<a href="http://127.0.0.1:80/api/v1/articles/info/时（这是django中的一个视图，在这里没有写出来，不同的小伙伴可以替换成不同的接口），视图会返回相应的结果。" target="_blank" rel="noopener">http://127.0.0.1:80/api/v1/articles/info/时（这是django中的一个视图，在这里没有写出来，不同的小伙伴可以替换成不同的接口），视图会返回相应的结果。</a><br>以交互方式进入容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it CONTAINERID &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>后，进入mysql数据库，会看到在数据库中生成了相应的表。</p><h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>在运行3个容器后，web容器一直报错，通过 docker logs CONTAINERID查看主要错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django.db.utils.OperationalError: (2003, &#39;Can\&#39;t connect to MySQL server on \&#39;mariadb55\&#39; (111 &quot;Connection refused&quot;)&#39;)</span><br></pre></td></tr></table></figure><p>解决方案在这里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;47979270&#x2F;django-cannot-connect-mysql-in-docker-compose</span><br></pre></td></tr></table></figure><p>主要是在settings.py中，将database配置中的HOST值改成db,而不是127.0.0.1，指向docker-compose.yml中的db服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天整理了一下如何在docker中部署django项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="django, docker" scheme="http://wyzane.gitee.io/blog/tags/django-docker/"/>
    
  </entry>
  
  <entry>
    <title>为已安装的nginx动态添加模块</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/25/%E4%B8%BA%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84nginx%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/25/%E4%B8%BA%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84nginx%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97/</id>
    <published>2020-07-25T09:47:09.000Z</published>
    <updated>2020-07-25T09:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍下如何为已安装的 nginx 动态添加模块。</p><a id="more"></a><p>首先，我们下载需要编译进 nginx 模块，或者使用 nginx 自带的模块如：realip 模块。</p><p>然后，执行 nginx -V，查看nginx信息和之前的安装记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  conf nginx -V                                  </span><br><span class="line">nginx version: nginx&#x2F;1.16.1</span><br><span class="line">built by gcc 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) </span><br><span class="line">built with OpenSSL 1.1.1  11 Sep 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic</span><br></pre></td></tr></table></figure><p>可以看到，我们之前编译 nginx 时使用的参数是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic</span><br></pre></td></tr></table></figure><p>那么，我们这次编译时，如果想把 nginx 自带的模块编译进去，如 realip，则执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic --with-http_realip_module</span><br></pre></td></tr></table></figure><p>如果想把第三方模块编译进去，则可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic -–add-module&#x3D;第三方模块所在目录</span><br></pre></td></tr></table></figure><p>上述命令执行完成后，再执行 make 命令（不需要指定 make install命令）就行了。</p><p>最后，将现有的 nginx 二进制文件备份（例如：备份文件 /usr/local/nginx/sbin/nginx），备份完成后，再使用刚刚生成的 nginx 二进制文件替换现有的 nginx 二进制文件既可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天介绍下如何为已安装的 nginx 动态添加模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://wyzane.gitee.io/blog/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>使用nginx搭建反向代理服务器</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/20/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/20/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-07-20T13:56:31.000Z</published>
    <updated>2020-07-26T02:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享下，如何使用 nginx 搭建具有反向代理功能的服务器。</p><p>首先把 nginx 官方文档地址贴出来，有问题可以随时查阅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>首先介绍下正向代理与反向代理的区别。</p><p>正向代理是发送请求时，隐藏了真正的客户端，即服务端不知道请求的客户端信息，客户端的请求都被代理服务器代替来请求。正向代理的常用场景就是在爬虫系统中。<br>反向代理是客户端不知道将要请求的服务器的信息，而是请求一个代理服务器，代理服务器再去请求上游服务器，并把上游服务器的响应返回给客户端。</p><p>其实，正向代理和反向代理的请求流程都是一样的，只是被代理对象不同。正向代理代理的对象是客户端，反向代理代理的对象是服务端，也就是说，谁被代理就隐藏了谁。</p><h2 id="反向代理服务器搭建"><a href="#反向代理服务器搭建" class="headerlink" title="反向代理服务器搭建"></a>反向代理服务器搭建</h2><p>下面看一个 nginx 配置反向代理的例子。</p><p>使用 nginx 搭建一个反向代理，上游服务器是一个静态资源 web 服务，配置如下：</p><p>nginx.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                  <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">127.0.0.1:8081</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span>  docs/;   <span class="comment"># 指定静态资源目录</span></span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;  <span class="comment"># 这个设置会显示docs目录结构</span></span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;  <span class="comment"># 限制速率</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反向代理服务器配置如下：</p><p>nginx2.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">include</span>       ../confs/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                  <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定上游服务,这里可以配置负载均衡算法</span></span><br><span class="line">    <span class="attribute">upstream</span> local &#123;</span><br><span class="line">        <span class="attribute">server</span>  <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8082</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">192.168.0.105</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将请求转发到指定的上游服务器</span></span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://local;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别启动两个服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">sudo nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx2.conf</span><br></pre></td></tr></table></figure><p>启动后，再浏览器地址栏输入 <a href="http://192.168.0.105:8082/" target="_blank" rel="noopener">http://192.168.0.105:8082/</a> 便可以访问静态资源了。</p><h2 id="反向代理服务加入缓存功能"><a href="#反向代理服务加入缓存功能" class="headerlink" title="反向代理服务加入缓存功能"></a>反向代理服务加入缓存功能</h2><p>如果想提高响应速率，可以在 nginx 反向代理服务器上增加缓存功能。</p><p>反向代理增加缓存后，客户端的请求会首先从nginx缓存中获取数据，并返回给客户端，当没有缓存数据或者缓存数据过期时，才会请求上游服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">include</span>       ../confs/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                  <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy_cache_path 参数用于设置缓存路径，并且可以指定其他参数</span></span><br><span class="line">    <span class="comment"># levels=1:2 参数指定缓存等级，值从1到3（暂时没弄明白这里的意思）</span></span><br><span class="line">    <span class="comment"># keys_zone  参数指定共享内存大小和名称</span></span><br><span class="line">    <span class="comment"># inactive 参数指定数据缓存的时长，默认10分钟</span></span><br><span class="line">    <span class="comment"># max_size 参数指定缓存数据的最大值</span></span><br><span class="line">    <span class="comment"># use_temp_path 指定是否使用临时文件存放缓存数据</span></span><br><span class="line">    指定保存缓存数据的路径, keys_zone表示开了一个10m的共享内存用于存放key，my_cache是共享内存名称 </span><br><span class="line">    <span class="attribute">proxy_cache_path</span>  /tmp/nginx_cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span> </span><br><span class="line">                      inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定上游服务,这里可以配置负载均衡算法</span></span><br><span class="line">    <span class="attribute">upstream</span> local &#123;</span><br><span class="line">        <span class="attribute">server</span>  <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8082</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">192.168.0.105</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 指定刚刚开辟的共享内存</span></span><br><span class="line">            <span class="attribute">proxy_cache</span>  my_cache;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定义缓存数据对应的 key 由什么组成</span></span><br><span class="line">            <span class="attribute">proxy_cache_key</span>  <span class="variable">$host</span><span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 给指定的想用窗台吗设置缓存过期时间，最后一个值时过期时间，可以是小时、分钟等单位</span></span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">302</span> <span class="number">1d</span>;            </span><br><span class="line">           </span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://local;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置中也介绍了一些常用的缓存参数，详细参数信息可以参考 nginx 的官方文档，文档地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_proxy_module.html#proxy_cache_path</span><br></pre></td></tr></table></figure><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>既然提到了反向代理，那么负载均衡是一定要说一下的。负载均衡的大意就是反向代理服务器把客户端的请求均匀的，或者按照一定的规则分发给上游服务器，从而保证服务可用性。</p><p>实现负载均衡有以下几种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 水平扩展：基于 Round-Robin或者least-connect算法进行请求分发</span><br><span class="line">2. 按功能扩展：根据请求URL，按照功能分发请求到上游服务器</span><br><span class="line">3. 基于用户信息扩展：根据请求客户端ip或者其他信息分发客户端请求（基于hash的某些算法）</span><br></pre></td></tr></table></figure><p>上面的方式可以组合起来使用，并不是只能单独使用。</p><p>nginx支持多种协议的反向代理，即客户端使用http协议请求服务时，nginx可以将其转换成fastcgi、uwsgi、rpc、websocket等协议，再向上游服务器发起请求。</p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>nginx 中负责与上游服务器交互的模块是 upstream 模块，该模块中提供了一个基本的负载均衡算法 Round-Robin。</p><p>upstream 模块中，指定上游服务器的指令是 upstream，上面的例子中已经见过，该指令的作用域是 http 上下文。在 upstream 中，使用 server 指令指定上游服务器地址信息。</p><p>Round-Robin负载均衡算法介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该算法功能：以轮询的方式访问 server 指令指定的上游服务器，该算法集成在 Nginx 的 upstream 模块中。</span><br></pre></td></tr></table></figure><p>该算法提供以下指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wieght: 上游服务器权重，默认1</span><br><span class="line">max_conns：上游服务器的最大并发连接数，仅用于单 worker 进程，默认0，表示没有限制</span><br><span class="line">max_fails: 与fail_timeout配合使用。在fail_timeout时间段内，最大的失败次数。当达到最大失败次数时，在fail_timeout时间内，该上游服务器不再被选择</span><br><span class="line">fail_timeout:单位秒，默认为10，与max_fails配合使用，有两个功能：，指定一段时间内最大的失败次数max_fails；当到达max_fails后，该上游服务器不能再被访问</span><br></pre></td></tr></table></figure><h2 id="反向代理服务中加入负载均衡"><a href="#反向代理服务中加入负载均衡" class="headerlink" title="反向代理服务中加入负载均衡"></a>反向代理服务中加入负载均衡</h2><h3 id="基于-Round-Robin-算法的负载均衡"><a href="#基于-Round-Robin-算法的负载均衡" class="headerlink" title="基于  Round-Robin 算法的负载均衡"></a>基于  Round-Robin 算法的负载均衡</h3><h4 id="反向代理服务配置"><a href="#反向代理服务配置" class="headerlink" title="反向代理服务配置"></a>反向代理服务配置</h4><p>nginx.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">        <span class="comment"># server_name  192.168.0.103;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line">        <span class="attribute">error_log</span>   logs/error.log;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span>  docs/;</span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;  <span class="comment"># 显示docs目录结构</span></span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;</span><br><span class="line">            <span class="comment"># index  index.html index.htm;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 指定反向代理的配置文件，配置文件中加入了负载均衡</span></span><br><span class="line">    <span class="attribute">include</span> reverse_proxy.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reverse_proxy.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> proxy &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8011</span> weight=<span class="number">2</span> max_conns=<span class="number">2</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8012</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8091</span>;</span><br><span class="line">    <span class="attribute">error_log</span>  logs/reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  http://proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上游服务配置"><a href="#上游服务配置" class="headerlink" title="上游服务配置"></a>上游服务配置</h4><p>nginx2.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">127.0.0.1:8082</span>;</span><br><span class="line">        <span class="comment"># server_name  192.168.0.103;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line">        <span class="attribute">error_log</span>   logs/error.log;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span>  docs/;</span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;  <span class="comment"># 显示docs目录结构</span></span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;</span><br><span class="line">            <span class="comment"># index  index.html index.htm;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 指定上游服务配置文件</span></span><br><span class="line">    <span class="attribute">include</span> upstream.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upstream.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 监听 8011 端口</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8011</span>;</span><br><span class="line"><span class="attribute">default_type</span> text/plain;</span><br><span class="line"><span class="attribute">return</span> <span class="number">200</span> <span class="string">'8011 server response'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 监听 8012 端口</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8012</span>;</span><br><span class="line"><span class="attribute">default_type</span> text/plain;</span><br><span class="line"><span class="attribute">return</span> <span class="number">200</span> <span class="string">'8012 server response'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的服务配置好以后，可以分别启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动反向代理服务：sudo nginx -c nginx.conf</span><br><span class="line">启动上游服务：sudo nginx -c nginx2.conf</span><br></pre></td></tr></table></figure><p>服务启动后，在终端多次执行 curl localhost:8091，可以发现，响应结果中，’8011 server response’ 和 ‘8012 server response’ 的比例大致为 2:1，这说明我们配置的负载均衡已经生效了。</p><h3 id="基于-ip-hash-的负载均衡"><a href="#基于-ip-hash-的负载均衡" class="headerlink" title="基于 ip hash 的负载均衡"></a>基于 ip hash 的负载均衡</h3><p>基于 ip 地址的 hash 算法可以根据客户端 ip 的不同，将请求转发到不同的上游服务器，它的配置如下（仅仅修改了 reverse_proxy.conf文件）：</p><p>reverse_proxy.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    set_real_ip_from  192.168.0.105;</span><br><span class="line">    real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，上面使用了 realip 模块的一些指令，现在的 nginx 版本中，realip模块默认没有编译进 nginx，如果要使用 该模块，需要将 realip 模块编译进 nginx 中。如何把某个模块编译进已安装的 nginx 中，可以查看我的另一篇博客。</p><p>上面指定的大致意思如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip_hash：根据用户的 ip 地址分发客户端的请求到上游服务器</span><br><span class="line">set_real_ip_from：设置可信任的地址</span><br><span class="line">real_ip_recursive on：表示原始客户端 ip 地址会被请求头中的某个非信任 ip 地址（由real_ip_header决定）替换</span><br><span class="line">real_ip_header X-Forwarded-For：表示以 X-Forwarded-For 中的最后一个 ip 作为 ip_hash 对应的 ip 地址</span><br></pre></td></tr></table></figure><p>具体解释可以查看官方文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_realip_module.html#set_real_ip_from</span><br></pre></td></tr></table></figure><p>配置完成重启后，我们可以在终端执行以下命令来测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;X-Forwarded-For: 10.112.23.45&quot; localhost:8091</span><br></pre></td></tr></table></figure><p>可以更换 ip ，查看返回的结果。</p><h3 id="基于关键字-hash-的负载均衡"><a href="#基于关键字-hash-的负载均衡" class="headerlink" title="基于关键字  hash 的负载均衡"></a>基于关键字  hash 的负载均衡</h3><p>使用关键字 hash 时，reverse_proxy.conf的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    # 使用特定的字符串作为hash值</span><br><span class="line">    hash user_$arg_username;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    set_real_ip_from  192.168.0.105;</span><br><span class="line">    real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求服务时时，传入不同的 username 参数，会请求不同的上游服务器。</p><h3 id="hash算法优化"><a href="#hash算法优化" class="headerlink" title="hash算法优化"></a>hash算法优化</h3><p>当有上游服务器宕机或者需要扩容时，hash 算法会导致负载均衡的路由发生变化，这样会导致一系列问题（例如缓存失效）。一致性 hash 算法可以解决这个问题。</p><p>nginx 中配置一致性 hash 比较简单，配置如下：</p><p>reverse_proxy.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    # 使用特定的字符串作为hash值</span><br><span class="line">    hash user_$arg_username consistent;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # set_real_ip_from  192.168.0.105;</span><br><span class="line">    # real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原来的 hash key 后面加上 consistent 即可实现一致性 hash，具体介绍可以查看官方文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_upstream_module.html#hash</span><br></pre></td></tr></table></figure><h3 id="基于最少连接数算法的负载均衡"><a href="#基于最少连接数算法的负载均衡" class="headerlink" title="基于最少连接数算法的负载均衡"></a>基于最少连接数算法的负载均衡</h3><p>最少连接数算法中，nginx 反向代理服务器会将客户端请求转发到连接数最少的上游服务器中。当有多个上游服务器最少连接数相同时，会按照 Roubd-Robin 算法将请求发送到这几个服务器中的一个。最少连接数算法的配置如下：</p><p>reverse_proxy.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # set_real_ip_from  192.168.0.105;</span><br><span class="line">    # real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 upstream 上下文中，加入 least_conn 指令即可配置最少连接数算法。</p><p>官方文档如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_upstream_module.html#least_conn</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天分享下，如何使用 nginx 搭建具有反向代理功能的服务器。&lt;/p&gt;
&lt;p&gt;首先把 nginx 官方文档地址贴出来，有问题可以随时查阅：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;nginx.org&amp;#x2F;en&amp;#x2F;docs&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://wyzane.gitee.io/blog/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>ice配合tornado搭建http服务</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/19/ice%E9%85%8D%E5%90%88tornado%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/19/ice%E9%85%8D%E5%90%88tornado%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-07-19T13:23:40.000Z</published>
    <updated>2020-07-19T13:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>tornado 是 python 中的一个 http 框架，以异步高性能著称，zeroc-ice 是一个分布式的 rpc 框架，将两者结合使用，可以搭建高性能的 web 应用服务。</p><p>下面写了一个小 demo，演示了如何在 tornado 中使用 ice。</p><a id="more"></a><h2 id="demo结构"><a href="#demo结构" class="headerlink" title="demo结构"></a>demo结构</h2><p>demo 的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.py</span><br><span class="line">├── handlers.py</span><br><span class="line">├── Test</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── Test.ice</span><br><span class="line">├── Test_ice.py</span><br><span class="line">└── user</span><br><span class="line">    ├── client.ini</span><br><span class="line">    ├── client.py</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── server.ini</span><br><span class="line">    └── server.py</span><br></pre></td></tr></table></figure><p>其中，Test.ice 是 slice 文件，其内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module Test</span><br><span class="line">&#123;</span><br><span class="line">    dictionary&lt;string, string&gt; Params;</span><br><span class="line"></span><br><span class="line">    interface User</span><br><span class="line">    &#123;</span><br><span class="line">        void printStr(string s);</span><br><span class="line"></span><br><span class="line">        int addMun(int num1, int num2);</span><br><span class="line"></span><br><span class="line">        string invoke(string fid, string params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行 slice2py 后，生成了 Test 目录和 Test_ics.py 文件。</p><p>handlers.py 和 app.py 是 tornado 文件，内容分别如下：</p><p>handlers.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 13:48 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">from user.client import IceCommunicator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserHandler(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    def post(self, url):</span><br><span class="line">        print(&quot;url:&quot;, url)</span><br><span class="line">        # print(&quot;params:&quot;, self.request.body.decode(&quot;utf-8&quot;))</span><br><span class="line">        print(&quot;params:&quot;, self.request.arguments)</span><br><span class="line"></span><br><span class="line">        path &#x3D; &quot;user&#x2F;&quot; + url</span><br><span class="line">        params &#x3D; self.request.arguments</span><br><span class="line">        params &#x3D; &#123;k: params.get(k)[0].decode(&quot;utf-8&quot;) for k in params.keys()&#125;</span><br><span class="line"></span><br><span class="line">        resp &#x3D; self.invoke(path, params)</span><br><span class="line">        self.write(resp)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line">    def invoke(self, path, params):</span><br><span class="line">        communicator &#x3D; IceCommunicator()</span><br><span class="line">        user &#x3D; communicator.init()</span><br><span class="line">        params &#x3D; json.dumps(params)</span><br><span class="line">        resp &#x3D; user.invoke(path, params)</span><br><span class="line">        return resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GoodsHandler(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    def post(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>app.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 13:46 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import tornado.web</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.options</span><br><span class="line">import tornado.httpserver</span><br><span class="line">from tornado.options import define, options</span><br><span class="line"></span><br><span class="line">from handlers import UserHandler, GoodsHandler</span><br><span class="line"></span><br><span class="line">define(&quot;port&quot;, default&#x3D;8000, help&#x3D;&quot;run on the given port&quot;, type&#x3D;int)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    handlers &#x3D; [</span><br><span class="line">        (r&quot;&#x2F;user&#x2F;(.*)&quot;, UserHandler),</span><br><span class="line">        (r&quot;&#x2F;goods&#x2F;(.*)&quot;, GoodsHandler)</span><br><span class="line">    ]</span><br><span class="line">    app &#x3D; tornado.web.Application(handlers&#x3D;handlers)</span><br><span class="line">    http_server &#x3D; tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>user目录下是 ice 相关的文件和配置，内容分别如下：</p><p>server.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 10:00 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import Ice</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">Ice.loadSlice(&quot;..&#x2F;Test.ice&quot;)</span><br><span class="line">import Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_resp(status&#x3D;None, msg&#x3D;None, data&#x3D;None):</span><br><span class="line">    &quot;&quot;&quot;获取响应信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    resp &#x3D; dict()</span><br><span class="line">    resp[&quot;status&quot;] &#x3D; status if status else &#39;10000&#39;</span><br><span class="line">    resp[&quot;msg&quot;] &#x3D; msg if msg else &#39;ok&#39;</span><br><span class="line">    resp[&quot;data&quot;] &#x3D; data if data else &#123;&#125;</span><br><span class="line">    return resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserI(Test.User):</span><br><span class="line"></span><br><span class="line">    def printStr(self, s, current&#x3D;None):</span><br><span class="line">        print(&quot;hello ice&quot;)</span><br><span class="line"></span><br><span class="line">    def addMun(self, n1, n2, current&#x3D;None):</span><br><span class="line">        ret &#x3D; n1 + n2</span><br><span class="line">        print(&quot;addMun result is:&quot;, ret)</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    def invoke(self, path, params, current&#x3D;None):</span><br><span class="line">        &quot;&quot;&quot;调用具体业务逻辑</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        user &#x3D; ViewUser()</span><br><span class="line"></span><br><span class="line">        params &#x3D; json.loads(params)</span><br><span class="line"></span><br><span class="line">        map &#x3D; &#123;</span><br><span class="line">            &quot;user&#x2F;list&quot;: user.list,</span><br><span class="line">            &quot;user&#x2F;detail&quot;: user.detail,</span><br><span class="line">            &quot;user&#x2F;add&quot;: user.add</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resp &#x3D; map.get(path, user.others)(params)</span><br><span class="line">        return resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ViewUser():</span><br><span class="line"></span><br><span class="line">    def list(self, params):</span><br><span class="line">        resp &#x3D; get_resp(data&#x3D;&#123;&quot;url&quot;: &quot;user&#x2F;list&quot;&#125;)</span><br><span class="line">        print(&quot;user list:&quot;, params)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line">    def detail(self, params):</span><br><span class="line">        resp &#x3D; get_resp(data&#x3D;&#123;&quot;url&quot;: &quot;user&#x2F;detail&quot;&#125;)</span><br><span class="line">        print(&quot;user detail:&quot;, params)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line">    def add(self, params):</span><br><span class="line">        resp &#x3D; get_resp(data&#x3D;&#123;&quot;url&quot;: &quot;user&#x2F;add&quot;&#125;)</span><br><span class="line">        print(&quot;user add:&quot;, params)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line">    def others(self, params):</span><br><span class="line">        resp &#x3D; get_resp(&#39;10001&#39;, &#39;not found&#39;)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with Ice.initialize(sys.argv, &quot;server.ini&quot;) as communicator:</span><br><span class="line">    adapter &#x3D; communicator.createObjectAdapter(&quot;User&quot;)</span><br><span class="line">    adapter.add(UserI(), Ice.stringToIdentity(&quot;user&quot;))</span><br><span class="line">    adapter.activate()</span><br><span class="line">    communicator.waitForShutdown()</span><br></pre></td></tr></table></figure><p>client.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 10:00 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import Ice</span><br><span class="line"></span><br><span class="line">Ice.loadSlice(&quot;Test.ice&quot;)</span><br><span class="line">import Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IceCommunicator:</span><br><span class="line"></span><br><span class="line">    def init(self):</span><br><span class="line">        communicator &#x3D; Ice.initialize(sys.argv, &#39;user&#x2F;client.ini&#39;)</span><br><span class="line">        user &#x3D; Test.UserPrx.checkedCast(communicator.propertyToProxy(&#39;User.Proxy&#39;)</span><br><span class="line">                                        .ice_twoway()</span><br><span class="line">                                        .ice_secure(False))</span><br><span class="line">        if not user:</span><br><span class="line">            print(&quot;invalid proxy&quot;)</span><br><span class="line">            sys.exit(1)</span><br><span class="line"></span><br><span class="line">        return user</span><br></pre></td></tr></table></figure><p>server.ini：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User.Endpoints&#x3D;tcp -p 10000</span><br><span class="line">Ice.Default.Host&#x3D;localhost</span><br><span class="line">Ice.Warn.Connections&#x3D;1</span><br></pre></td></tr></table></figure><p>client.ini：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User.Proxy&#x3D;user:tcp -p 10000</span><br><span class="line">Ice.Default.Host&#x3D;localhost</span><br><span class="line">Ice.Warn.Connections&#x3D;1</span><br></pre></td></tr></table></figure><h2 id="demo执行流程"><a href="#demo执行流程" class="headerlink" title="demo执行流程"></a>demo执行流程</h2><p>执行流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. app.py 中接受 http 请求，并将请求转发到对应的 handler</span><br><span class="line">2. 在 hendler 中调用 ice 客户端向 ice 服务端发送请求，请求 ice 服务端时会传入请求 path 和参数</span><br><span class="line">3. ice 服务端根据不同的请求 path 执行不同的操作，并返回响应结果</span><br></pre></td></tr></table></figure><p>上面仅仅是一个小的 demo，后面还会更近一步研究两者的结合使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tornado 是 python 中的一个 http 框架，以异步高性能著称，zeroc-ice 是一个分布式的 rpc 框架，将两者结合使用，可以搭建高性能的 web 应用服务。&lt;/p&gt;
&lt;p&gt;下面写了一个小 demo，演示了如何在 tornado 中使用 ice。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="tornado" scheme="http://wyzane.gitee.io/blog/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>Python中多个装饰器的执行顺序</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/13/Python%E4%B8%AD%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/13/Python%E4%B8%AD%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2020-07-13T14:04:07.000Z</published>
    <updated>2020-07-13T14:17:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天总结下 Python 中多个装饰器的执行顺序。</p><a id="more"></a><p>装饰器代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper_out1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'--out11--'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner1</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"--in11--"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"--in12--"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    print(<span class="string">"--out12--"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper_out2</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'--out21--'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner2</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"--in21--"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"--in22--"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    print(<span class="string">"--out22"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper_out2</span></span><br><span class="line"><span class="meta">@wrapper_out1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"--test--"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>执行后，打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">--out11--</span><br><span class="line">--out12--</span><br><span class="line">--out21--</span><br><span class="line">--out22--</span><br><span class="line">--in21--</span><br><span class="line">--in11--</span><br><span class="line">--test--</span><br><span class="line">--in12--</span><br><span class="line">--in22--</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>执行顺序以图片形式展示如下：</p><p><img src="python01.png" alt="python01"></p><p>先进入离test函数最近的装饰器，由于装饰器中返回的是函数的函数名引用，并非真正调用函数，所以先打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--out11--</span><br><span class="line">--out12--</span><br><span class="line">--out21--</span><br><span class="line">--out22--</span><br></pre></td></tr></table></figure><p>到inner2后，func会真正执行函数，会调用 inner1() ,所以再打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--in21--</span><br><span class="line">--in11--</span><br></pre></td></tr></table></figure><p>到 inner1 中，func 会调用test函数，所以会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--test--</span><br></pre></td></tr></table></figure><p>再从各个函数出来后，会依次打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--in12--</span><br><span class="line">--in22--</span><br></pre></td></tr></table></figure><p>合起来就是上面的执行结果。</p><p>以上就是多个装饰器的执行顺序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天总结下 Python 中多个装饰器的执行顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="python" scheme="http://wyzane.gitee.io/blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>zeroc ice在python中的使用</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/11/zeroc-ice%E5%9C%A8python%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/11/zeroc-ice%E5%9C%A8python%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-11T01:54:26.000Z</published>
    <updated>2020-07-19T13:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>zeroc ice 指的是 zeroc 公司开发的一款网络通讯引擎 ice。ice 是一个面向对象的 RPC 框架，可以搭建分布式应用。最主要的一点，它是跨语言的，不管你使用 Python、Java 还是 C++、Ruby、C# 等开发语言，它都支持。还有一点，ice 提供了其他功能，包括：IceStorm（一种订阅服务，类似于消息队列）、IceGrid 等。</p><a id="more"></a><p>下面从安装、使用等几个方面介绍下 ice 在 python 中的使用。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装环境是 python3.6.9，ubuntu18.04。</p><h2 id="安装方式一"><a href="#安装方式一" class="headerlink" title="安装方式一"></a>安装方式一</h2><p>安装步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. sudo apt-get install openssl libssl-dev libbz2-dev</span><br><span class="line">    第一步安装不成功时，可以使用 aptitude 来安装需要的包：</span><br><span class="line">sudo apt-get install aptitude </span><br><span class="line">sudo aptitude install xxxxx</span><br><span class="line">2. 安装 ice for python: pip install zeroc-ice</span><br><span class="line">3. 安装 ice for linux</span><br><span class="line">1）将源码克隆到本地: git clone https:&#x2F;&#x2F;github.com&#x2F;zeroc-ice&#x2F;ice.git</span><br><span class="line">若网速太慢，可以先在码云上创建项目并将ice.git克隆过去，再从码云上克隆</span><br><span class="line">2）克隆完成后，切换分支到3.7: git checkout 3.7（安装3.7版本）</span><br><span class="line">3）编译：make supported-languages&#x3D;&#39;cpp python&#39; （只编译c++和python，还可以编译其他语言）</span><br><span class="line">4）安装：make install supported-languages&#x3D;&#39;cpp python&#39; prefix&#x3D;&#x2F;opt&#x2F;zeroc-ice </span><br><span class="line">5）配置环境变量：在 .zshrc 中添加配置: PATH&#x3D;$PATH:&#x2F;opt&#x2F;zeroc-ice&#x2F;bin</span><br><span class="line">6）执行命令: icegridnode -v，会输出响应版本</span><br><span class="line">4. 安装完成后，可以从 github 上克隆 ice-demos 来学习。</span><br></pre></td></tr></table></figure><h2 id="安装方式二"><a href="#安装方式二" class="headerlink" title="安装方式二"></a>安装方式二</h2><p>或者，可以按照 zeroc 官方文档进行安装，官方文档如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;zeroc.com&#x2F;downloads&#x2F;ice&#x2F;3.7&#x2F;python</span><br></pre></td></tr></table></figure><h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><p>首先简单介绍下 ice 中相关概念和一些基础知识。</p><h2 id="slice语言"><a href="#slice语言" class="headerlink" title="slice语言"></a>slice语言</h2><p>Slice (Specification Language for Ice) 是实现 Ice 协议的开发语言，它可以把 Ice 接口的实现翻译成不同的开发语言版本。对于不同的应用开发语言，有不同的映射规则。</p><p>Slice 提供一个基本的抽象机制用于分离接口和他们的实现。Slice 用于描述接口，建立客户端和服务端之间的关系。Slice的接口描述与具体实现语言无关，即它可以让你定义 client 和 server 之间的交互而不用关心具体的开发语言，例如 C++，Java、Python等。通过编译，可以把 Slice对接口的描述转换成不同的开发语言。</p><h2 id="client-与-server"><a href="#client-与-server" class="headerlink" title="client 与 server"></a>client 与 server</h2><p>在 ice 中，client 和 server 不是指一个应用系统的特定部分，它们是在一个持续请求中扮演不同角色，具有不同的功能。</p><p>client 会主动向 server 发送服务请求，而 server 端只能被动的接收请求，并针对请求，为 client 端提供不同的服务。通常，client 会主动向 server 端发起请求，也可以接收 server 端的回调通知，这样看来，client 既有 client 端属性也有 server 端属性。</p><p>client 和 server 的结构如下：</p><p><img src="Ice_Client_and_Server_Structure.gif" alt="Ice_Client_and_Server_Structure"></p><p>上面的结构中，有以下几部分。</p><h3 id="Ice-Core"><a href="#Ice-Core" class="headerlink" title="Ice Core"></a>Ice Core</h3><p>ice core 包含了 client 和 server 的运行时，用于支持远程通信。这部分包含了网络通信、线程、字节序及其他网络相关的代码实现，并与应用层代码分离开来。ice core 提供了一系列库供 client 和 server 端调用。</p><h3 id="Ice-API"><a href="#Ice-API" class="headerlink" title="Ice API"></a>Ice API</h3><p>ice 中通过 ice api 来访问 ice core，使用 ice api 来做一些基础工作，例如初始化和资源回收。ice api 对于 client 和 server 端来说没有什么区别。</p><h3 id="Proxy-Code"><a href="#Proxy-Code" class="headerlink" title="Proxy Code"></a>Proxy Code</h3><p>proxy code 部分是根据 slice 文件中定义的内容生成的，它规定了对象和数据的类型。proxy code 主要有两个功能：</p><ol><li>为 client 端提供向下调用的接口，在 proxy API 调用函数最终会向 server 端发送一个 RPC 消息，然后在服务端执行响应的目标函数</li><li>提供组包和解包代码，组包是序列化复杂数据结构的过程，例如为了在网络上传送，序列化一个序列或者字典。组包会将数据转换成一种标准的数据传输格式，并且不受字节序的影响。解包就是相反的过程。</li></ol><h3 id="Skeleton-Code"><a href="#Skeleton-Code" class="headerlink" title="Skeleton Code"></a>Skeleton Code</h3><p>skeleton code 与 proxy code 功能相似，只是它在 server 端发挥作用，proxy code 是在 client 端的。它提供了向上调用的接口，并且允许 ice 运行时将控制线程转换为应用代码。skeleton 中也包含组包和解包的功能，以便 server 端能接收 client 端传入的参数，并且向 client 端返回结果或者异常。</p><h3 id="Object-Adapter"><a href="#Object-Adapter" class="headerlink" title="Object Adapter"></a>Object Adapter</h3><p>object adapter 是 ice api 的一部分，它只在 server 端使用，它由如下几个功能：</p><ol><li>将客户端请求与编程语言中的特定方法映射，即 object adapter 会找到内存中具有特定标识的对象</li><li>object adapter 与传输协议有关，如果一个 object adapter 对应多个传输协议，server 就能提供多种服务</li><li>object adapter 可以生成 proxy（proxy 会被发送到 client 端）。object adapter 中记录了每个对象的类型、名称、传输信息。当 server 端想要创建 proxy 时，object adapter 能创建 proxy 而不需要知道具体细节。</li></ol><h2 id="Ice-Objects"><a href="#Ice-Objects" class="headerlink" title="Ice Objects"></a>Ice Objects</h2><p>简单来说，ice object 对象中定义了一些接口，通过调用这些接口，client 能向服务器发送请求。我的理解是（以 Python 为例），ice object 中定义了一些方法，这些方法实现了请求创建、数据传递、数据接收等功能；我们在 slice 文件中定义的接口，经过转换后是 ice object 的子类；server 端需要继承 ice object 的子类来实现具体的功能。</p><h2 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h2><p>通过 proxy，client 能与 ice object 关联起来，proxy 就类似于 ice object 的一个使者。当 client 想调用 ice object 中的某个功能时（其实就是某个方法），需要通过 proxy ，这时会执行以下流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 定位 ice object</span><br><span class="line">2. 激活 ice object</span><br><span class="line">3. 激活 server 端的 ice object</span><br><span class="line">4. 传递入参到 ice object 中</span><br><span class="line">5. 等待操作完成</span><br><span class="line">6. 把出参和结果返回给 client 端</span><br></pre></td></tr></table></figure><p>proxy 信息可以用一个字符串表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimplePrinter:default -p 10000</span><br></pre></td></tr></table></figure><p>这种字符串形式的 proxy 更加易于理解和存储。</p><p>proxy 还分为 Direct Proxy 和 Indirect Proxy。Direct Proxy 通常包括 proxy 对象名称和服务器地址，包括以下两类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. a protocol identifier (such TCP&#x2F;IP or UDP)</span><br><span class="line">2. a protocol-specific address (such as a host name and port number)</span><br></pre></td></tr></table></figure><p>Indirect Proxy 有两种形式，一种是仅仅提供对象名称（如：SimplePrinter），另一种是提供对象名称和对象适配器名称（如：SimplePrinter@PrinterAdapter）。</p><h2 id="Ice-Protocol"><a href="#Ice-Protocol" class="headerlink" title="Ice Protocol"></a>Ice Protocol</h2><p>ice能提供 RPC 协议，这些 RPC 协议可以使用多种底层协议，最常用的是TCP和UDP，但是ice也支持 Websocket, Bluetooth 和 Apple’s iAP。Ice还可以使用 SSL 协议对传输数据加密。</p><p>Ice 协议中定义了以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 定义了一些消息类型，例如请求\应答的消息类型</span><br><span class="line">2. 定义了状态机，确定客户端和服务端如何交换数据</span><br><span class="line">3. 定义编码规则，确定怎样表示数据类型</span><br><span class="line">4. 定义了消息类型的头部，包括消息类型、消息大小、使用的协议等。</span><br></pre></td></tr></table></figure><p>Ice也支持数据压缩，当客户端与服务端传输的数据量非常大时，这很有用。<br>Ice 协议非常适合创建高效的事件分发机制，因为它允许我们分发消息而不用关心消息内部的实现。<br>Ice 协议也支持双向的操作，即：如果服务端传输数据到客户端提供的回调对象上，回调过程可以通过客户端最初创建的连接来完成。</p><h2 id="Ice-Service"><a href="#Ice-Service" class="headerlink" title="Ice Service"></a>Ice Service</h2><p>对于开发分布式应用程序，Ice Core提供了一个复杂的 client-server 平台，然而，实际开发中不仅仅需要远程处理能力，也需要按需提供服务、向客户端分发代理、分发异步任务、向应用程序分发补丁等等。Ice 提供了以下服务来实现上面的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. IceGrid</span><br><span class="line">2. IceStorm</span><br><span class="line">3. IcePatch2</span><br><span class="line">4. Glacier2</span><br><span class="line">5. IceBridge</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的介绍中，我们可以发现，开发 ice 的 client 和 server 时，我们需要以下几个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. slice 文件</span><br><span class="line">2. ice object</span><br><span class="line">3. proxy code</span><br><span class="line">4. object adapter</span><br></pre></td></tr></table></figure><p>上面这些都会在下面的代码中体现出来，可以回想一下它们的功能分别是什么。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>安装完成后，首先看第一个使用的例子。</p><h2 id="编写-Slice-File"><a href="#编写-Slice-File" class="headerlink" title="编写 Slice File"></a>编写 Slice File</h2><p>开发时，首先要编写 slice 文件，slice 文件是与开发语言无关的。编写完成后，需要使用编译器将其转换成不同的开发语言，例如转换成 Python 时，就需要使用 slice2py。slice 文件里面的内容其实就是一些接口，server 端开发时需要编写 Python 类来实现这些接口。</p><p>Printer.ice：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module Demo</span><br><span class="line">&#123;</span><br><span class="line">    interface Printer</span><br><span class="line">    &#123;</span><br><span class="line">        void printString(string s);</span><br><span class="line"></span><br><span class="line">        int addMun(int num1, int num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中， Demo 是模块名称，Printer 是接口名称，接口里面是方法的定义。</p><p>编写完成后，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice2py Printer.ice</span><br></pre></td></tr></table></figure><p>执行完成后，会生成 Printer_ice.py 文件和 Demo 文件夹。Demo文件夹下的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── __init__.py</span><br><span class="line">└── __pycache__</span><br><span class="line">    └── __init__.cpython-36.pyc</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Demo&#x2F;__init__.py 内容如下：</span><br><span class="line"># Generated by slice2py - DO NOT EDIT!</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">import Ice</span><br><span class="line">Ice.updateModule(&quot;Demo&quot;)</span><br><span class="line"></span><br><span class="line"># Modules:</span><br><span class="line">import Printer_ice</span><br><span class="line"></span><br><span class="line"># Submodules:</span><br></pre></td></tr></table></figure><p>Printer_ice.py 文件中的内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright (c) ZeroC, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Ice version 3.7.4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;auto-generated&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Generated from file `Printer.ice'</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Warning: do not edit this file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;/auto-generated&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> version_info <span class="keyword">as</span> _version_info_</span><br><span class="line"><span class="keyword">import</span> Ice, IcePy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start of module Demo</span></span><br><span class="line">_M_Demo = Ice.openModule(<span class="string">'Demo'</span>)</span><br><span class="line">__name__ = <span class="string">'Demo'</span></span><br><span class="line"></span><br><span class="line">_M_Demo._t_Printer = IcePy.defineValue(<span class="string">'::Demo::Printer'</span>, Ice.Value, <span class="number">-1</span>, (), <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">None</span>, ())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'PrinterPrx'</span> <span class="keyword">not</span> <span class="keyword">in</span> _M_Demo.__dict__:</span><br><span class="line">    _M_Demo.PrinterPrx = Ice.createTempClass()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PrinterPrx</span><span class="params">(Ice.ObjectPrx)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printString</span><span class="params">(self, s, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.invoke(self, ((s, ), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printStringAsync</span><span class="params">(self, s, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.invokeAsync(self, ((s, ), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">begin_printString</span><span class="params">(self, s, _response=None, _ex=None, _sent=None, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.begin(self, ((s, ), _response, _ex, _sent, context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">end_printString</span><span class="params">(self, _r)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.end(self, _r)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addMun</span><span class="params">(self, num1, num2, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.invoke(self, ((num1, num2), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addMunAsync</span><span class="params">(self, num1, num2, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.invokeAsync(self, ((num1, num2), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">begin_addMun</span><span class="params">(self, num1, num2, _response=None, _ex=None, _sent=None, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.begin(self, ((num1, num2), _response, _ex, _sent, context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">end_addMun</span><span class="params">(self, _r)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.end(self, _r)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">checkedCast</span><span class="params">(proxy, facetOrContext=None, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.PrinterPrx.ice_checkedCast(proxy, <span class="string">'::Demo::Printer'</span>, facetOrContext, context)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">uncheckedCast</span><span class="params">(proxy, facet=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.PrinterPrx.ice_uncheckedCast(proxy, facet)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_staticId</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'::Demo::Printer'</span></span><br><span class="line">    _M_Demo._t_PrinterPrx = IcePy.defineProxy(<span class="string">'::Demo::Printer'</span>, PrinterPrx)</span><br><span class="line"></span><br><span class="line">    _M_Demo.PrinterPrx = PrinterPrx</span><br><span class="line">    <span class="keyword">del</span> PrinterPrx</span><br><span class="line"></span><br><span class="line">    _M_Demo.Printer = Ice.createTempClass()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Printer</span><span class="params">(Ice.Object)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_ids</span><span class="params">(self, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">'::Demo::Printer'</span>, <span class="string">'::Ice::Object'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_id</span><span class="params">(self, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'::Demo::Printer'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_staticId</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'::Demo::Printer'</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printString</span><span class="params">(self, s, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">"servant method 'printString' not implemented"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addMun</span><span class="params">(self, num1, num2, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">"servant method 'addMun' not implemented"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> IcePy.stringify(self, _M_Demo._t_PrinterDisp)</span><br><span class="line"></span><br><span class="line">        __repr__ = __str__</span><br><span class="line"></span><br><span class="line">    _M_Demo._t_PrinterDisp = IcePy.defineClass(<span class="string">'::Demo::Printer'</span>, Printer, (), <span class="literal">None</span>, ())</span><br><span class="line">    Printer._ice_type = _M_Demo._t_PrinterDisp</span><br><span class="line"></span><br><span class="line">    Printer._op_printString = IcePy.Operation(<span class="string">'printString'</span>, Ice.OperationMode.Normal, Ice.OperationMode.Normal, <span class="literal">False</span>, <span class="literal">None</span>, (), (((), IcePy._t_string, <span class="literal">False</span>, <span class="number">0</span>),), (), <span class="literal">None</span>, ())</span><br><span class="line">    Printer._op_addMun = IcePy.Operation(<span class="string">'addMun'</span>, Ice.OperationMode.Normal, Ice.OperationMode.Normal, <span class="literal">False</span>, <span class="literal">None</span>, (), (((), IcePy._t_int, <span class="literal">False</span>, <span class="number">0</span>), ((), IcePy._t_int, <span class="literal">False</span>, <span class="number">0</span>)), (), ((), IcePy._t_int, <span class="literal">False</span>, <span class="number">0</span>), ())</span><br><span class="line"></span><br><span class="line">    _M_Demo.Printer = Printer</span><br><span class="line">    <span class="keyword">del</span> Printer</span><br><span class="line"></span><br><span class="line"><span class="comment"># End of module Demo</span></span><br></pre></td></tr></table></figure><p>从上面的内容中可以看出，Printer_ice.py 中主要有两个 Python 类 PrinterPrx 和 Printer。</p><h2 id="编写-Server-端"><a href="#编写-Server-端" class="headerlink" title="编写 Server 端"></a>编写 Server 端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, Ice</span><br><span class="line"><span class="keyword">import</span> Demo</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterI</span><span class="params">(Demo.Printer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printString</span><span class="params">(self, s, current=None)</span>:</span></span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addMun</span><span class="params">(self, n1, n2, current=None)</span>:</span></span><br><span class="line">        ret = n1 + n2</span><br><span class="line">        print(ret)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> Ice.initialize(sys.argv) <span class="keyword">as</span> communicator:</span><br><span class="line">    adapter = communicator.createObjectAdapterWithEndpoints(<span class="string">"SimplePrinterAdapter"</span>, <span class="string">"default -p 10000"</span>)</span><br><span class="line">    object = PrinterI()</span><br><span class="line">    adapter.add(object, communicator.stringToIdentity(<span class="string">"SimplePrinter"</span>))</span><br><span class="line">    adapter.activate()</span><br><span class="line">    communicator.waitForShutdown()</span><br></pre></td></tr></table></figure><p>server 端的代码中主要有两部分：一个 Python 类 PrinterI，继承了 Demo.Printer 并实现了其中的方法；with 代码块。</p><p>with 代码块中的含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Ice.initialize()初始化 Ice 运行环境，返回一个Ice.Communicator对象，它是 Ice 运行时的主要对象</span><br><span class="line">2. communicator.createObjectAdapterWithEndpoints()创建一个 Object Adapter 对象，</span><br><span class="line">   &quot;SimplePrinterAdapter&quot;表示 Adapter 对象名称，&quot;default -p 10000&quot; 表示使用 TCP&#x2F;IP协议并监听10000端口</span><br><span class="line">3. object &#x3D; PrinterI() 表示实例化 Printer 接口的子类</span><br><span class="line">4. 调用 Adapter 对象的 add 方法，将实例化的对象绑定到 Adapter 中。add() 方法的第一个参数就是 PrinterI 类的对    象，第二个参数是给 PrinterI 对象指定一个名称，如果有多个实例化的对象时，每个对象的名称都不能相同</span><br><span class="line">5. adapter.activate() 表示启用 Adapter </span><br><span class="line">6. 最后，调用 communicator.waitForShutdown() 会阻塞直到服务关闭</span><br></pre></td></tr></table></figure><h2 id="编写-Client-端"><a href="#编写-Client-端" class="headerlink" title="编写 Client 端"></a>编写 Client 端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, Ice</span><br><span class="line"><span class="keyword">import</span> Demo</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> Ice.initialize(sys.argv) <span class="keyword">as</span> communicator:</span><br><span class="line">    base = communicator.stringToProxy(<span class="string">"SimplePrinter:default -p 10000"</span>)</span><br><span class="line">    printer = Demo.PrinterPrx.checkedCast(base)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> printer:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"Invalid proxy"</span>)</span><br><span class="line"> </span><br><span class="line">    printer.printString(<span class="string">"Hello World!"</span>)</span><br><span class="line">    ret = printer.addMun(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"client:"</span>, ret)</span><br></pre></td></tr></table></figure><p>client 中只有一个 with 代码块，其含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Ice.initialize()：初始化 Ice 运行环境</span><br><span class="line">2. communicator.stringToProxy()：获得远端 printer 的一个代理对象，参数 &quot;SimplePrinter:default -p 10000&quot;    表示在服务端指定的 printer 对象名称和监听端口</span><br><span class="line">3. stringToProxy()方法返回的是一个Ice.ObjectPrx类型，它是其他所有接口的父类。但是，实际上我们是需要一个          Demo.Printer 类型，所以需要类型向下的转换。使用 Demo.PrinterPrx.checkedCast(base) 可以向服务器发送消息，    确认代理是否是 Demo.Printer类型，如果是，就返回一个 Demo.PrinterPrx 类型的代理，否则返回None</span><br><span class="line">4. printer.printString(&quot;Hello World!&quot;) 调用方法。</span><br></pre></td></tr></table></figure><p>编写完成后，执行 Python 文件就行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python server.py</span><br><span class="line">python client.py</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zeroc ice 指的是 zeroc 公司开发的一款网络通讯引擎 ice。ice 是一个面向对象的 RPC 框架，可以搭建分布式应用。最主要的一点，它是跨语言的，不管你使用 Python、Java 还是 C++、Ruby、C# 等开发语言，它都支持。还有一点，ice 提供了其他功能，包括：IceStorm（一种订阅服务，类似于消息队列）、IceGrid 等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="python" scheme="http://wyzane.gitee.io/blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制的搭建</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/04/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/04/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2020-07-04T02:01:34.000Z</published>
    <updated>2024-02-02T06:20:07.420Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的主从复制是一个很有用的功能，在大型系统中，为了分担 Redis 的读写压力，可以使用主从复制功能。下面介绍下 Redis 主从复制的搭建。</p><a id="more"></a><h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><h2 id="Redis-持久化方式"><a href="#Redis-持久化方式" class="headerlink" title="Redis 持久化方式"></a>Redis 持久化方式</h2><p>先介绍下 Redis 的持久化方式。Redis 的持久化方式有两种 rdb和 aof，默认是 rdb 的方式。</p><h3 id="rdb-备份方式"><a href="#rdb-备份方式" class="headerlink" title="rdb 备份方式"></a>rdb 备份方式</h3><p>rdb 是半持久化的存储方式，它会定期将内存中数据保存到磁盘上，从而保证数据的持久化，永久保存Redis数据。它是通过快照（snapshotting）的方式完成的，当满足在 Redis.conf 配置文件中设置的条件时 Redis 会自动将内存中的所有数据进行快照并存储在硬盘上，完成数据备份。</p><p>Redis进行 rdb 快照的条件由用户在配置文件中自定义，由两个参数构成：时间和改动键的个数。当在指定时间内被更改键的个数大于指定的数值时就会进行快照。配置文件中默认预值了3个条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1       #900秒内有至少1个键被更改则进行快照；</span><br><span class="line">save 300 10      #300秒内有至少10个键被更改则进行快照；</span><br><span class="line">save 60  10000   #60秒内有至少10000个键被更改则进行快照</span><br></pre></td></tr></table></figure><p>默认可以存在多个条件，条件之间是“或”的关系，只要满足其中任意一个，就会进行快照备份数据。若想要禁用自动快照，只需删除所有save参数即可。</p><p>Redis 默认会将快照文件存储在 Redis 数据目录中，默认文件名是：dump.rdb，可通过配置dir和dbfilename两个参数来指定快照文件的存储路径和文件名。</p><p>Redis快照过程：Redis使用fork函数复制一份当前进程（父进程）的副本（子进程），父进程负责接收和处理客户端发来的命令，而子进程负责将内存中的数据写入硬盘中的临时文件，当子进程写完所有数据后会用该临时文件替换旧的 rdb 文件，至此一次快照操作完成。<br>rdb 文件是经过压缩的二进制格式，所以占用的空间会小于内存中的数据大小。除了自动快照，还可以手动发送SAVE和BGSAVE 命令让Redis执行快照。两个命令区别是：SAVE是由主进程进行快照操作，会阻塞其他请求，BGSAVE会通过fork 子进程进行快照操作。</p><p>手动执行备份：redis-cli bgsave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save  &#x2F;&#x2F; 手动备份</span><br><span class="line">bgsave  &#x2F;&#x2F; 手动备份</span><br><span class="line">config get dir  &#x2F;&#x2F; 获取redis的dir</span><br></pre></td></tr></table></figure><h3 id="aof-备份方式"><a href="#aof-备份方式" class="headerlink" title="aof 备份方式"></a>aof 备份方式</h3><p>aof 是全持久化的备份方式，使用这种方式，Redis 会实时将内存中数据刷到磁盘上，从而保证数据的持久化，永久保存Redi s数据。如果数据非常重要无法承受任何损失，可以使用 aof 方式进行持久化，默认 Redis 没有开启 aof（append only file）方式的全持久化模式。</p><p>在启动时 Redis 会逐个执行 apf 文件中的命令来将硬盘中的数据载入到内存中，载入的速度相对于 rdb 方式慢些，开启 aof 持久化后每执行一条都会更改Redis中的数据的命令，Redis就会将命令写入硬盘中的 aof 文件。</p><p>Redis允许同时开启 aof 和 rdb ，既保证了数据安全又使得进行备份等操作十分容易。</p><p>Redis aof持久化参数配置详解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly  yes                   #开启AOF持久化功能；</span><br><span class="line">appendfilenameappendonly.aof      #AOF持久化保存文件名；</span><br><span class="line">appendfsyncalways                 #每次执行写入都会执行同步，最安全也最慢；</span><br><span class="line">#appendfsynceverysec              #每秒执行一次同步操作；</span><br><span class="line">#appendfsyncno                    #不主动进行同步操作，而是完全交由操作系统来做，每30秒一次，最快也最不安全；</span><br><span class="line">auto-aof-rewrite-percentage  100  #当AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据；</span><br><span class="line">auto-aof-rewrite-min-size    64mb #允许重写的最小AOF文件大小配置写入AOF文件后，要求系统刷新硬盘缓存的机制。</span><br></pre></td></tr></table></figure><p>在配置文件中进行以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>aof 刷新日志到disk的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always   #always 表示每次有写操作都进行同步，非常慢，非常安全。</span><br><span class="line">appendfsync everysec #everysec表示对写操作进行累积，每秒同步一次</span><br></pre></td></tr></table></figure><p>官方的建议的everysec，安全，就是速度不够快，如果是机器出现问题可能会丢失1秒的数据。</p><p>手动执行备份：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli bgrewriteaof</span><br></pre></td></tr></table></figure><h2 id="主从数据同步"><a href="#主从数据同步" class="headerlink" title="主从数据同步"></a>主从数据同步</h2><p>当 slave 初始化的时候，会将 master 上的数据复制一份到自己服务器上。此后，每当 master 新增数据后，都会将写命令发送一份到 slave 上，slave 接收到写命令后将数据写入。我们可以通过 monitor 命令来看 slave 的写入过程。</p><p>例如：当 master 执行 set name wyzane 后，使用 monitor 查看到 slave 的执行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1593857563.031330 [0 192.168.0.105:6379] &quot;PING&quot;</span><br><span class="line">1593857553.918113 [0 192.168.0.105:6379] &quot;set&quot; &quot;name&quot; &quot;wyzane&quot;</span><br><span class="line">1593857563.031330 [0 192.168.0.105:6379] &quot;PING&quot;</span><br></pre></td></tr></table></figure><h1 id="主从复制搭建"><a href="#主从复制搭建" class="headerlink" title="主从复制搭建"></a>主从复制搭建</h1><p>下面在一个服务器上开启三个 Redis 进程为例，来介绍下主从复制的搭建过程。</p><h2 id="不需要权限校验的主从复制"><a href="#不需要权限校验的主从复制" class="headerlink" title="不需要权限校验的主从复制"></a>不需要权限校验的主从复制</h2><p>配置的时候，需要修改 Redis .conf 配置文件，master 和 slave 的配置分别如下。其中，protected-mode no 表示 slave 连接 master 时不需要密码校验。</p><p>master配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.0.105</span><br><span class="line">protected-mode no</span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure><p>slqve1 的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.0.105</span><br><span class="line">slaveof 192.168.0.105 6379</span><br><span class="line">protected-mode no</span><br><span class="line">port 6380</span><br></pre></td></tr></table></figure><p>slave2 的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.0.105</span><br><span class="line">slaveof 192.168.0.105 6379</span><br><span class="line">protected-mode no</span><br><span class="line">port 6381</span><br></pre></td></tr></table></figure><p>配置完成后，执行以下命令启动这三个服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf （master）</span><br><span class="line">redis-server redis2.conf （slave1）</span><br><span class="line">redis-server redis3.conf （slave2）</span><br></pre></td></tr></table></figure><p>服务启动后，需要连接这三个服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.0.105 -p 6379</span><br><span class="line">redis-cli -h 192.168.0.105 -p 6380</span><br><span class="line">redis-cli -h 192.168.0.105 -p 6381</span><br></pre></td></tr></table></figure><p>连接上客户端，在 master 上 set 数据后，可以分别在 slave1、slave2 上看到这些数据。</p><h2 id="权限校验的主从配置"><a href="#权限校验的主从配置" class="headerlink" title="权限校验的主从配置"></a>权限校验的主从配置</h2><p>在生产环境上，为了保证安全性，权限校验是非常重要的。所以，我们配置主从复制时，一定要把权限校验的功能加上去。权限校验首先需要把 master redis.conf 中的 protected-mode 值设置为 yes（默认），然后再设置密码。设置密码的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected-mode yes</span><br><span class="line">requirepass wyzane  # wyzane 就是密码</span><br></pre></td></tr></table></figure><p>设置完成后，使用 redis-cli 时，需要执行 auth wyzane， 即输入密码。</p><p>slave1 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth wyzane</span><br></pre></td></tr></table></figure><p>slave2 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth wyzane</span><br></pre></td></tr></table></figure><p>设置完成后，重启 Redis 服务就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 的主从复制是一个很有用的功能，在大型系统中，为了分担 Redis 的读写压力，可以使用主从复制功能。下面介绍下 Redis 主从复制的搭建。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="Redis" scheme="http://wyzane.gitee.io/blog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>svn的简单使用</title>
    <link href="http://wyzane.gitee.io/blog/2020/06/27/svn%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2020/06/27/svn%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-27T07:29:17.000Z</published>
    <updated>2020-06-27T13:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>与 git 一样，svn （Subversion）也是一个开源的版本控制系统，相比于 git 的分布式管理，svn是一个集中式的版本管理工具。今天介绍下它的简单使用。</p><a id="more"></a><p>svn 是集中式的版本管理工具，它依赖于 svn 服务器，所有的版本信息都保存在服务器上。</p><h1 id="svn使用总结"><a href="#svn使用总结" class="headerlink" title="svn使用总结"></a>svn使用总结</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>svn的使用步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">ubuntu安装svn</span><br><span class="line">1. apt-get update</span><br><span class="line">2. apt-get install subversion</span><br><span class="line">安装完成后，可以执行 svnserve --version 查看版本信息</span><br><span class="line"></span><br><span class="line">创建版本库：</span><br><span class="line">1. 在 &#x2F;home&#x2F;wyzane 下创建 svn 目录（作为中央仓库）</span><br><span class="line">2. 创建仓库：svnadmin create &#x2F;home&#x2F;wyzane&#x2F;svn</span><br><span class="line">3. 创建完成后，在 svn 下会生成 conf、db 等目录</span><br><span class="line">目录结构如下：</span><br><span class="line">        .</span><br><span class="line">        ├── conf</span><br><span class="line">        │   ├── authz</span><br><span class="line">        │   ├── hooks-env.tmpl</span><br><span class="line">        │   ├── passwd</span><br><span class="line">        │   └── svnserve.conf</span><br><span class="line">        ├── db</span><br><span class="line">        │   ├── current</span><br><span class="line">        │   ├── format</span><br><span class="line">        │   ├── fsfs.conf</span><br><span class="line">        │   ├── fs-type</span><br><span class="line">        │   ├── min-unpacked-rev</span><br><span class="line">        │   ├── rep-cache.db</span><br><span class="line">        │   ├── rep-cache.db-journal</span><br><span class="line">        │   ├── revprops</span><br><span class="line">        │   ├── revs</span><br><span class="line">        │   ├── transactions</span><br><span class="line">        │   ├── txn-current</span><br><span class="line">        │   ├── txn-current-lock</span><br><span class="line">        │   ├── txn-protorevs</span><br><span class="line">        │   ├── uuid</span><br><span class="line">        │   └── write-lock</span><br><span class="line">        ├── format</span><br><span class="line">        ├── hooks</span><br><span class="line">        │   ├── post-commit.tmpl</span><br><span class="line">        │   ├── post-lock.tmpl</span><br><span class="line">        │   ├── post-revprop-change.tmpl</span><br><span class="line">        │   ├── post-unlock.tmpl</span><br><span class="line">        │   ├── pre-commit.tmpl</span><br><span class="line">        │   ├── pre-lock.tmpl</span><br><span class="line">        │   ├── pre-revprop-change.tmpl</span><br><span class="line">        │   ├── pre-unlock.tmpl</span><br><span class="line">        │   └── start-commit.tmpl</span><br><span class="line">        ├── locks</span><br><span class="line">        │   ├── db.lock</span><br><span class="line">        │   └── db-logs.lock</span><br><span class="line">        └── README.txt</span><br><span class="line">其中，conf目录下存放了配置文件，passwd 是用户配置文件，可以配置用户名和密码。authz 是权限配置文件，可以配置用户对应的读写权限，也可以对用户进行分组配置。svnserve.conf 是基本的配置文件。</span><br><span class="line"></span><br><span class="line">启动服务：</span><br><span class="line">svnserve -d -r &#x2F;home&#x2F;wyzane&#x2F;svn  (默认端口 3690)</span><br><span class="line">其中：</span><br><span class="line">-d：表示在后台运行</span><br><span class="line">-r：指定服务器的根目录</span><br><span class="line">查看进程：ps aux | grep svnserve</span><br><span class="line"></span><br><span class="line">客户端 checkout 代码需要执行以下命令：</span><br><span class="line">svn checkout svn:&#x2F;&#x2F;192.168.0.105&#x2F; --username wyzane</span><br></pre></td></tr></table></figure><p>在 windows 下使用时，我们可以下载 svn 的 windows 版本进行安装，下载地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;subversion.apache.org&#x2F;packages.html</span><br></pre></td></tr></table></figure><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 首先创建 branches 目录并提交</span><br><span class="line">2. 创建分支：svn copy trunk&#x2F; branches&#x2F;sub，并使用 svn commit 提交（基于 trunk 的分支）</span><br><span class="line">3. 修改 sub 分支上的内容并提交</span><br><span class="line">4. 合并分支：切换到 trunk 目录，执行svn merge ..&#x2F;branches&#x2F;sub&#x2F;</span><br><span class="line">5. 提交合并后的内容：svn commit -m &quot;update&quot;</span><br></pre></td></tr></table></figure><h2 id="tag操作"><a href="#tag操作" class="headerlink" title="tag操作"></a>tag操作</h2><p>通过 tag 标签，可以给某一具体的版本加上一个有意义的名称，便于更好的管理，tag 的使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 创建 tags 目录并提交：mkdir tags &amp; svn add tags &amp; svn commit -m &quot;commit tags dir&quot;</span><br><span class="line">2. 在当前的 trunk 版本上打一个 tag：svn copy trunk&#x2F; tags&#x2F;v1.0</span><br><span class="line">3. 提交到版本库：svn commit -m &quot;v1.0&quot;</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">svn add test.txt   # 添加文件到版本库中</span><br><span class="line">A         test.txt</span><br><span class="line">svn status         # 查看状态</span><br><span class="line">A       test.txt  </span><br><span class="line">svn commit -m &quot;update&quot;   # 将改动的文件提交到版本库，此时再使用 svn status 时，就不会有输出信息了</span><br><span class="line"></span><br><span class="line">svn update  # 更新版本哭的改动到本地</span><br><span class="line"></span><br><span class="line">svn log   # 查看版本库的提交历史</span><br></pre></td></tr></table></figure><h1 id="使用时可能的错误"><a href="#使用时可能的错误" class="headerlink" title="使用时可能的错误"></a>使用时可能的错误</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. commit failed， 没有找到事务5-9</span><br><span class="line">解决：这是因为 svnserve 的服务没有开启，启动 svnserve 即可。</span><br><span class="line"></span><br><span class="line">2. the error was 条目不可读</span><br><span class="line">解决：配置文件中修改 anon-access 的值为 none，然后重启即可</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与 git 一样，svn （Subversion）也是一个开源的版本控制系统，相比于 git 的分布式管理，svn是一个集中式的版本管理工具。今天介绍下它的简单使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="SVN" scheme="http://wyzane.gitee.io/blog/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>git操作与分支管理</title>
    <link href="http://wyzane.gitee.io/blog/2020/06/21/git%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>http://wyzane.gitee.io/blog/2020/06/21/git%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-21T13:38:08.000Z</published>
    <updated>2020-06-27T02:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>git 是一个版本控制系统，现在大部分项目都会使用它来管理开发的项目，下面整理了 git 的常用命令及使用方式。</p><a id="more"></a><h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="git最小配置"><a href="#git最小配置" class="headerlink" title="git最小配置"></a>git最小配置</h2><p>配置 username 和 email</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &#39;your name&#39;</span><br><span class="line">git config --global user.email &#39;your email&#39;</span><br></pre></td></tr></table></figure><p>配置 email 的目的，当版本库中的代码变更时，会记录对应开发人员的 email 等信息，当进行 code review 时，若相应变更的代码有问题，会发送邮件通知到对应的开发者。</p><p>config的 三个作用域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local  缺省配置，表示只对某个仓库有效</span><br><span class="line">git config --global 对当前用户所有仓库有效</span><br><span class="line">git config --system 对系统所有的登录用户有效</span><br></pre></td></tr></table></figure><p>当我们需要显示 config 的配置信息时，使用 –list 就行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list --local</span><br><span class="line">git config --list --global</span><br><span class="line">git config --list --system</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ git config --list --global</span><br><span class="line">user.email&#x3D;wyzane1207@163.com</span><br><span class="line">user.name&#x3D;wyzane</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">λ git config --list</span><br><span class="line">core.symlinks&#x3D;false</span><br><span class="line">core.autocrlf&#x3D;true</span><br><span class="line">core.fscache&#x3D;true</span><br><span class="line">color.diff&#x3D;auto</span><br><span class="line">color.status&#x3D;auto</span><br><span class="line">color.branch&#x3D;auto</span><br><span class="line">color.interactive&#x3D;true</span><br><span class="line">help.format&#x3D;html</span><br><span class="line">rebase.autosquash&#x3D;true</span><br><span class="line">http.sslbackend&#x3D;openssl</span><br><span class="line">http.sslcainfo&#x3D;D:&#x2F;software&#x2F;Git&#x2F;mingw64&#x2F;ssl&#x2F;certs&#x2F;ca-bundle.crt</span><br><span class="line">credential.helper&#x3D;manager</span><br><span class="line">user.email&#x3D;wyzane1207@163.com</span><br><span class="line">user.name&#x3D;wyzane</span><br></pre></td></tr></table></figure><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><h3 id="把已有项目代码纳入版本管理"><a href="#把已有项目代码纳入版本管理" class="headerlink" title="把已有项目代码纳入版本管理"></a>把已有项目代码纳入版本管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 项目代码所在文件夹</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="新建一个git仓库"><a href="#新建一个git仓库" class="headerlink" title="新建一个git仓库"></a>新建一个git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 某个文件夹</span><br><span class="line">git init 目录名</span><br><span class="line">cd 目录名</span><br></pre></td></tr></table></figure><p>新建一个git仓库的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ git init demo1</span><br><span class="line">Initialized empty Git repository in F:&#x2F;GitTest&#x2F;demo1&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure><p>此时执行 git config –global –list 的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ git config --global --list</span><br><span class="line">user.email&#x3D;wyzane1207@163.com</span><br><span class="line">user.name&#x3D;wyzane</span><br></pre></td></tr></table></figure><p>在 demo1 仓库中，执行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ git config --local user.name &#39;wz&#39;</span><br><span class="line">λ git config --local user.email &#39;wyzane1207@gmail.com&#39;</span><br></pre></td></tr></table></figure><h2 id="添加一个文件"><a href="#添加一个文件" class="headerlink" title="添加一个文件"></a>添加一个文件</h2><p>在 dem01 目录下，新建文件 readme.md，此时执行 git status，显示如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        readme.md</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>此时显示，readme.md 文件是未被跟踪的文件，执行 git add readme.md，此时再执行 git status，显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   readme.md</span><br></pre></td></tr></table></figure><p>然后执行 git commit -m ‘readme.md’，表示将文件提交到本地仓库中，执行完，显示结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">λ git commit -m &#39;reaeme.md&#39;</span><br><span class="line">[master (root-commit) 28f3903] &#39;reaeme.md&#39;</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 readme.md</span><br></pre></td></tr></table></figure><p>此时，可以用 git log 命令查看提交记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">λ git log</span><br><span class="line">commit 28f3903644aea0102c9e7b7a6789b5990a45db50 (HEAD -&gt; master)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Mon Jun 22 22:41:14 2020 +0800</span><br><span class="line"></span><br><span class="line">    &#39;reaeme.md&#39;</span><br></pre></td></tr></table></figure><p>从上面的结果中可以看出 local 配置会覆盖 global 配置。</p><h2 id="往仓库里添加文件"><a href="#往仓库里添加文件" class="headerlink" title="往仓库里添加文件"></a>往仓库里添加文件</h2><p>上面使用的 git add、git commit 等命令的功能如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git status: 查看工作目录和暂存区的状态</span><br><span class="line">git add: 将工作目录的改动添加到暂存区</span><br><span class="line">git add -u：将工作区中，已经被git管理的文件添加到暂存区（没有被管理的则不会添加到暂存区）</span><br><span class="line">git commit: 将暂存区的高的那个添加到本地仓库</span><br><span class="line">git log: 查看当前分支的本地 commit 的历史记录 （查看所有分支的提交记录使用 git log --all）</span><br></pre></td></tr></table></figure><p>git log 显示结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ git log</span><br><span class="line">commit 683cbacc9aae84b55bf03a37217f09b23ec71b5a (HEAD -&gt; master)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:50:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line"></span><br><span class="line">commit 9548167eda1557775206f988e129625c8ebc664e</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line"></span><br><span class="line">    add index</span><br><span class="line"></span><br><span class="line">commit 28f3903644aea0102c9e7b7a6789b5990a45db50</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Mon Jun 22 22:41:14 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme</span><br></pre></td></tr></table></figure><h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">文件的重命名可以在工作目录中完成，然后添加到暂存区，再提交到本地仓库。这样的方式有如下问题：</span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ mv index2.html index02.html</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add&#x2F;rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    index2.html</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        index02.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">从上面的显示可以看出，在工作目录中重命名是先删除文件，再创建新文件。然后还需要执行以下命令：</span><br><span class="line">git add index02.html</span><br><span class="line">git rm index2.html  删除暂存区中的文件</span><br><span class="line">执行 git status 打印如下：</span><br><span class="line">λ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        renamed:    index2.html -&gt; index02.html</span><br></pre></td></tr></table></figure><p>把暂存区中所有的修改还原：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure><p>上面的更改文件名的操作，可以使用下面的命令直接修改暂存区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git mv index.html index02.html</span><br><span class="line"></span><br><span class="line">此时再执行 git status，结果如下：</span><br><span class="line">λ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        renamed:    index2.html -&gt; index02.html</span><br><span class="line">        </span><br><span class="line">这个结果，跟上面的结果一致。</span><br></pre></td></tr></table></figure><h2 id="查看版本历史"><a href="#查看版本历史" class="headerlink" title="查看版本历史"></a>查看版本历史</h2><p>我们可以使用 git log 命令查看版本历史，git log 命令还有以下几种用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. git log --oneline  查看简洁的 log 信息</span><br><span class="line">febad01 (HEAD -&gt; master) 修改文件名</span><br><span class="line">683cbac update</span><br><span class="line">9548167 add index</span><br><span class="line">28f3903 add readme</span><br><span class="line"></span><br><span class="line">2. git log -n2  使用 -n 加数字的方式查看最近的几次提交 或者 git log -n2 --oneline</span><br><span class="line">commit febad01c1b094e73047b204fd31b827cb2a86ff2 (HEAD -&gt; master)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 23:02:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    修改文件名</span><br><span class="line"></span><br><span class="line">commit 683cbacc9aae84b55bf03a37217f09b23ec71b5a</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:50:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line">    </span><br><span class="line">3. git log --all --graph  使用图形化的形式展示分支的提交父子关系</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面的所有参数都可以组合使用，还可以使用 git help --web log 查看更多 git log 参数。</span><br></pre></td></tr></table></figure><p>使用 gitk 命令可以打开图形界面，查看项目的版本历史。</p><h2 id="git目录介绍"><a href="#git目录介绍" class="headerlink" title=".git目录介绍"></a>.git目录介绍</h2><p>执行 git init 后，会生成一个 ,git 文件夹，文件夹内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 dell 197121  16 6月  23 23:02 COMMIT_EDITMSG</span><br><span class="line">-rw-r--r-- 1 dell 197121 180 6月  22 22:29 config</span><br><span class="line">-rw-r--r-- 1 dell 197121  73 6月  22 22:24 description</span><br><span class="line">-rw-r--r-- 1 dell 197121 216 6月  25 14:55 gitk.cache</span><br><span class="line">-rw-r--r-- 1 dell 197121  21 6月  24 23:07 HEAD</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  22 22:24 hooks&#x2F;</span><br><span class="line">-rw-r--r-- 1 dell 197121 217 6月  24 23:08 index</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  22 22:24 info&#x2F;</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  22 22:41 logs&#x2F;</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  23 23:02 objects&#x2F;</span><br><span class="line">-rw-r--r-- 1 dell 197121  41 6月  23 22:59 ORIG_HEAD</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  22 22:24 refs&#x2F;</span><br></pre></td></tr></table></figure><p>每个文件的含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HEAD: 文件，保存了当前正在工作的分支，切换分支时内容会改变，内容为：ref: refs&#x2F;heads&#x2F;master</span><br><span class="line">config: 文件，保存了与本地仓库相关的配置信息，内容如下：</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion &#x3D; 0</span><br><span class="line">        filemode &#x3D; false</span><br><span class="line">        bare &#x3D; false</span><br><span class="line">        logallrefupdates &#x3D; true</span><br><span class="line">        symlinks &#x3D; false</span><br><span class="line">        ignorecase &#x3D; true</span><br><span class="line">[user]</span><br><span class="line">        name &#x3D; &#39;wz&#39;</span><br><span class="line">        email &#x3D; &#39;wyzane1207@163.com&#39;</span><br><span class="line">refs: 目录，包含 heads(保存分支) 和 tags(保存标签)</span><br><span class="line">refs&#x2F;heads&#x2F;master 中保存的是一个 commit 的 id，指向一个 commit</span><br><span class="line">objects: 目录，保存了 tree、glob 等对象的信息</span><br></pre></td></tr></table></figure><h2 id="git对象之间的关系"><a href="#git对象之间的关系" class="headerlink" title="git对象之间的关系"></a>git对象之间的关系</h2><p>commit、tree、blob三者之间的关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个commit对应一个tree，这个tree表示当时commit后，项目的整个目录结构，这个tree下面有可以包含多个子tree(目录)和blob(文件)。</span><br><span class="line">子tree会对应项目中的一个目录，子tree中也包含很多blob和子tree。</span><br><span class="line">一个blob对应一个文件，只要文件内容相同，就是同一个blob对象。</span><br></pre></td></tr></table></figure><p>执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">λ git cat-file -p f9c5d761a  查看f9c5d761a的内容</span><br><span class="line">tree b4f5e1498a011eb1267852ff76ccbad35c08aac4</span><br><span class="line">parent febad01c1b094e73047b204fd31b827cb2a86ff2</span><br><span class="line">author wyzane &lt;wyzane1207@163.com&gt; 1593072058 +0800</span><br><span class="line">committer wyzane &lt;wyzane1207@163.com&gt; 1593072058 +0800</span><br><span class="line"></span><br><span class="line">添加用户页面</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git cat-file -t f9c5d761a  查看f9c5d761a的类型</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git cat-file -p b4f5e1498a011   查看f9c5d761a下tree对象b4f5e1498a011的内容</span><br><span class="line">100644 blob fd98613334e79fb5a12f537462627af2b7efdacd    index.html</span><br><span class="line">100644 blob 9b562d265a03e923b86bfc3b9b8418463f4f1c70    index02.html</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    readme.md</span><br><span class="line">040000 tree fa6ab77bfb3a6f0cbecd74ef7e98e8624ee4c099    test</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git cat-file -t b4f5e1498a011  查看b4f5e1498a011的类型</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git cat-file -p fa6ab77bfb3</span><br><span class="line">100644 blob 41d4171c5880f9cdab07eadc8564d04e7ee1e055    user.html</span><br><span class="line"></span><br><span class="line">从上面的打印信息中可以看出，一个commit对应一个tree，这个tree下面可以有blob对象和子tree对象，子tree下面还有blob对象。</span><br><span class="line"></span><br><span class="line">执行 git cat-file -p fd98613334e79fb，显示出 blob 对象的内容如下：</span><br><span class="line">&lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br><span class="line">&lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br><span class="line">&lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br></pre></td></tr></table></figure><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分离头指针是指，做的变更不是基于一个分支。</span><br><span class="line">HEAD 可以指向一个分支（最终还是指向一个commit），也可以指向一个commit，当使用 git checkout commitID 时，HEAD会切换到一个特定的commit。此时我们做的任何变更不是基于分支的，而是基于这个commit，当切换回其他分支时，在commit上做的变更就会被git丢弃掉。</span><br><span class="line">当我们需要做一些实验性的变更时，可以这样做。</span><br></pre></td></tr></table></figure><p>正常情况下，HEAD会指向一个分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">λ git log</span><br><span class="line">commit f9c5d761a8922dd69345da752ab135881418bc51 (HEAD -&gt; master)</span><br><span class="line">Author: wyzane &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Thu Jun 25 16:00:58 2020 +0800</span><br><span class="line"></span><br><span class="line">    添加用户页面</span><br><span class="line"></span><br><span class="line">commit febad01c1b094e73047b204fd31b827cb2a86ff2</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 23:02:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    修改文件名</span><br><span class="line"></span><br><span class="line">commit 683cbacc9aae84b55bf03a37217f09b23ec71b5a</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:50:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line"></span><br><span class="line">commit 9548167eda1557775206f988e129625c8ebc664e (temp)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line"></span><br><span class="line">    add index</span><br></pre></td></tr></table></figure><p>我们执行 git checkout 9548 febad01c1b 后，HEAD会指向一个 commit：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">λ git checkout febad01c1b</span><br><span class="line">Note: checking out &#39;febad01c1b&#39;.</span><br><span class="line"></span><br><span class="line">You are in &#39;detached HEAD&#39; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at febad01 修改文件名</span><br><span class="line"></span><br><span class="line">λ git log</span><br><span class="line">commit febad01c1b094e73047b204fd31b827cb2a86ff2 (HEAD)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 23:02:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    修改文件名</span><br><span class="line"></span><br><span class="line">commit 683cbacc9aae84b55bf03a37217f09b23ec71b5a</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:50:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line"></span><br><span class="line">commit 9548167eda1557775206f988e129625c8ebc664e (temp)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line"></span><br><span class="line">    add index</span><br></pre></td></tr></table></figure><h2 id="修改commit的msg"><a href="#修改commit的msg" class="headerlink" title="修改commit的msg"></a>修改commit的msg</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改最近一次 commit 的 msg 使用如下命令：</span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">如何修改其他 commit 的 msg</span><br></pre></td></tr></table></figure><h2 id="修改其他-commit-的-msg"><a href="#修改其他-commit-的-msg" class="headerlink" title="修改其他 commit 的 msg"></a>修改其他 commit 的 msg</h2><p>对其他 commit 的 msg 修改时，需要用到 git rebase 命令。<br>首先我们要确定待修改commit的上一个commitID，以这个commit为基础。然后执行 git rebase -i 上一个commitID，会进入一个编辑页面，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pick f5b4cb5 修改文件名</span><br><span class="line">pick a0b86da 添加用户页面2</span><br><span class="line"></span><br><span class="line"># Rebase 683cbac..a0b86da onto 683cbac (2 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; &#x3D; use commit</span><br><span class="line"># r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message</span><br><span class="line"># x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell</span><br><span class="line"># b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;)</span><br><span class="line"># d, drop &lt;commit&gt; &#x3D; remove commit</span><br><span class="line"># l, label &lt;label&gt; &#x3D; label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; &#x3D; reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#39;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure><p>上面的文件中，挑选出了两个 commit，然后下面有选择执行的命令。修改 commit 时，我们可以选择 commit message 命令，即把第一行的 pick 改成 reword，然后保存。保存后又会进入一个编辑页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">修改文件名</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Author:    wz &lt;wyzane1207@163.com&gt;</span><br><span class="line"># Date:      Tue Jun 23 23:02:37 2020 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto 683cbac</span><br><span class="line"># Last command done (1 command done):</span><br><span class="line">#    reword f5b4cb5 修改文件名2</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick a0b86da 添加用户页面2</span><br><span class="line"># You are currently editing a commit while rebasing branch &#39;master&#39; on &#39;683cbac&#39;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       renamed:    index2.html -&gt; index02.html</span><br></pre></td></tr></table></figure><p>这时我们修改完 msg 后保存即可。</p><h2 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h2><p>对其他 commit 的 msg 修改时，需要用到 git rebase 命令。<br>首先我们要确定待修改commit的上一个commitID，以这个commit为基础。然后执行 git rebase -i 上一个commitID，会进入一个编辑页面，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pick 9548167 add index</span><br><span class="line">pick 683cbac update</span><br><span class="line">pick 4a558f9 修改文件名2</span><br><span class="line">pick 8d1455b 添加用户页面2</span><br><span class="line"></span><br><span class="line"># Rebase 28f3903..8d1455b onto 28f3903 (4 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; &#x3D; use commit</span><br><span class="line"># r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message</span><br><span class="line"># x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell</span><br><span class="line"># b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;)</span><br><span class="line"># d, drop &lt;commit&gt; &#x3D; remove commit</span><br><span class="line"># l, label &lt;label&gt; &#x3D; label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; &#x3D; reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#39;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure><p>我们可以把 683cbac、4a558f9 这两个 commit 合并到第一个 commit 中。根据文件中的说明，我们可以使用 squash（或者简写成s） 命令。修改文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pick 9548167 add index</span><br><span class="line">squash 683cbac update</span><br><span class="line">squash 4a558f9 修改文件名2</span><br><span class="line">pick 8d1455b 添加用户页面2</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后保存，会出现如下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"># This is the 1st commit message:</span><br><span class="line"></span><br><span class="line">add index</span><br><span class="line"></span><br><span class="line"># This is the commit message #2:</span><br><span class="line"></span><br><span class="line">update</span><br><span class="line"></span><br><span class="line"># This is the commit message #3:</span><br><span class="line"></span><br><span class="line">修改文件名2</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Author:    wz &lt;wyzane1207@163.com&gt;</span><br><span class="line"># Date:      Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto 28f3903</span><br><span class="line"># Last commands done (3 commands done):</span><br><span class="line">#    squash 683cbac update</span><br><span class="line">#    squash 4a558f9 修改文件名2</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick 8d1455b 添加用户页面2</span><br><span class="line"># You are currently rebasing branch &#39;master&#39; on &#39;28f3903&#39;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.html</span><br><span class="line">#       new file:   index02.html</span><br></pre></td></tr></table></figure><p>我们可以在第一行下面写合并 commit 的注释，写完保存即可。执行 git log –graph，可以看到下面的 commit 记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">λ git log --graph</span><br><span class="line">* commit 04c862efc7b757b2038144ab24b2dc913151213c (HEAD -&gt; master)</span><br><span class="line">| Author: wyzane &lt;wyzane1207@163.com&gt;</span><br><span class="line">| Date:   Thu Jun 25 16:00:58 2020 +0800</span><br><span class="line">|</span><br><span class="line">|     添加用户页面2</span><br><span class="line">|</span><br><span class="line">* commit 2343bc35bef0f096b3768403fbceeb587e8ddfcf</span><br><span class="line">| Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">| Date:   Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line">|</span><br><span class="line">|     合并commit测试</span><br><span class="line">|</span><br><span class="line">|     add index</span><br><span class="line">|</span><br><span class="line">|     update</span><br><span class="line">|</span><br><span class="line">|     修改文件名2</span><br><span class="line">|</span><br><span class="line">* commit 28f3903644aea0102c9e7b7a6789b5990a45db50</span><br><span class="line">  Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">  Date:   Mon Jun 22 22:41:14 2020 +0800</span><br><span class="line"></span><br><span class="line">      reaeme.md</span><br></pre></td></tr></table></figure><p>可以看到， 2343bc35bef0f096b3768403fbceeb587e8ddfcf 这个就是新生成的commit。</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="git-check"><a href="#git-check" class="headerlink" title="git check"></a>git check</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名: 切换到分支</span><br><span class="line">git checkout -b 分支名: 创建新分支并切换到新分支</span><br><span class="line">git checkout -b 新分支名 基于分支名或者commitID: 基于某个分支或者commit创建一个分支并切换到该分支</span><br></pre></td></tr></table></figure><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch: 查看分支列表</span><br><span class="line">git branch -d 分支名: 删除某个分支 </span><br><span class="line">git branch -D 分支名: 强制删除某个分支</span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff 用户比较两个 commit 的区别</span><br><span class="line">git diff commitID1 commitID2: 比较两个commit</span><br><span class="line">git diff HEAD HEAD~1: 比较当前commit与上一次commit的区别</span><br><span class="line">git diff HEAD HEAD^^ 与 git diff HEAD HEAD~2 一样</span><br></pre></td></tr></table></figure><h2 id="git-cat-file"><a href="#git-cat-file" class="headerlink" title="git cat-file"></a>git cat-file</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 9b562d265a03e923b86bfc3b9b8418463f4f1c70: 查看hash值的类型（这个是blob类型，即文件对象）</span><br><span class="line">git cat-file -p 9b562d265a03e923b86bfc3b9b8418463f4f1c70: 查看hash值的内容</span><br><span class="line">这个 blog 类型的内容如下：</span><br><span class="line">&lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br><span class="line">        &lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br><span class="line">git cat-file -t 239ec593c6a2192e76c005435f748b2ad28be832：查看hash值的类型（这个是tree类型，即目录）</span><br><span class="line">git cat-file -p 239ec593c6a2192e76c005435f748b2ad28be832: 查看输出内容，输出如下（内容是一个blob对象）：</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    readme.md</span><br></pre></td></tr></table></figure><p>整理中 …..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 是一个版本控制系统，现在大部分项目都会使用它来管理开发的项目，下面整理了 git 的常用命令及使用方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="Git" scheme="http://wyzane.gitee.io/blog/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>项目开发中接口如何保证幂等性</title>
    <link href="http://wyzane.gitee.io/blog/2020/06/21/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>http://wyzane.gitee.io/blog/2020/06/21/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2020-06-21T13:11:18.000Z</published>
    <updated>2020-06-21T13:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>当用户在客户端向服务器发起请求时，如果网络出现问题，用户可能会对同一个接口发起多次请求，幂等性就是要保证多次请求的结果一致。</p><a id="more"></a><p>幂等性在支付场景中使用的较多，它能保证用户在下单扣款时，不会由于网络原因而出现重复扣款的现象。</p><p>那么如何实现幂等性呢？最常用的有两种方式：方式一：代码中通过逻辑判断实现，方式二：给需要幂等的接口加一个唯一id。</p><p>下面以支付接口为例。</p><h1 id="逻辑判断实现幂等性"><a href="#逻辑判断实现幂等性" class="headerlink" title="逻辑判断实现幂等性"></a>逻辑判断实现幂等性</h1><p>当用户支付完成准备扣款时，可以使用订单id加订单状态来实现幂等性。用户第一次扣款后，由于网络原因，又发起一次支付，这时可以根据客户端传入的订单id加订单表中的订单状态来判断订单是否已支付。若已支付，则返回结果就行，不用再执行一次扣款炒操作。</p><h1 id="接口添加唯一id"><a href="#接口添加唯一id" class="headerlink" title="接口添加唯一id"></a>接口添加唯一id</h1><p>用户请求购买接口时，返回一个唯一id，同时将id保存在redis中。用户支付时，需要传入此id，若不传则提示支付失败。用户支付时，支付接口需要校验此id与redis中保存id的一致性，若一致，则支付成功，同时删除redis中的id，否则支付失败。</p><p>上面就是两种实现幂等性的方式，若还有其他的方式，欢迎交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当用户在客户端向服务器发起请求时，如果网络出现问题，用户可能会对同一个接口发起多次请求，幂等性就是要保证多次请求的结果一致。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>编码那些事儿</title>
    <link href="http://wyzane.gitee.io/blog/2020/06/20/%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://wyzane.gitee.io/blog/2020/06/20/%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</id>
    <published>2020-06-20T00:16:02.000Z</published>
    <updated>2020-06-21T13:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发中，编码是一件很重要的工作，它涉及到了数据的传输与读取等方面。今天介绍下编码相关的知识。</p><a id="more"></a><h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p>ascii码是用0-127这些状态位（即00000000-01111111）表示数字、字母、特殊符号等字符的编码规则，即用8个比特位（1个字节）表示最常用、基础的字符（例如：大写字母 W 用 01010111 表示，转换为十进制就是87，转换为十六进制就是 0x57）。ascii编码刚被创造时，使用计算机的人还不是很多，所以它能满足人们的需求。但是随着技术的进步与发展，科学家们发现ascii码已经不能满足需求了，很多其他国家的文字、符号并不能在计算机上被表示出来，于是将表示范围从127扩大到了256，即新增了128~256这些状态位来表示其他的文字或者符号，这些被称为扩展字符集。</p><h1 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h1><p>等到计算机技术传入中国时，我们发现还没有用于表示汉字的状态位，这是不能容忍的。于是勤劳的中国人民创造了GB2312编码，GB2312编码中规定0~127的状态位与原来意义相同，称为”半角”字符，从127以后使用两个字节表示一个汉字。由于中华文化博大精深，随着计算机的普及，GB2312编码也不能满足人们的要求了，随后有相继扩展出了GBK和GB18030编码。GBK是采用单双字节变长编码，英文使用单字节编码，兼容ASCII字符编码，中文则采用双字节编码。</p><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>首先得知道一点：Unicode 包含两个方面：1. 字符集 2. 编码方式</p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>随着计算机在全世界的发展，如果世界各地都使用自己的编码规则，则会阻碍计算机的发展，导致世界不能互相交换信息，这时候Unicode通用字符集就出现了。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码（说白了就是一个数字编号），以满足跨语言、跨平台进行文本转换、处理的要求。Unicode使用两个字节表示一个字符。每个字符都有一个唯一的 Unicode 编号，这个编号一般用十六进制表示。</p><p>python3 中，可以使用 encode() 方法对字符串进行编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 &#x3D; &#39;马&#39;</span><br><span class="line">s1.encode(&#39;unicode_escape&#39;)[2:]</span><br><span class="line">b&#39;9a6c&#39;</span><br></pre></td></tr></table></figure><p>可以看到 ‘马’ 对应的 Unicode 编码是 9a6c，转换成二进制就是 1001 1010 0110 1100。</p><h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><p>Unicode 规定了每个字符对应的编号是多少，但是它没有说明这些编号如何存储。</p><p>UTF-8是Unicode字符集的一种实现方式，它规定了如何对 Unicode 字符的编号进行存储（即以何种方式保存 Unicode 字符的编号，保存这些编码是为了能够在网络中传输），它使用一个到四个不等的字节对一个字符进行编码，编码以后再存储。UTF-8可以表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII兼容。通过变长，UTF-8可以节省数据的空间。Unicode 的编号范围与 UTF-8 对应的二进制格式：</p><table><thead><tr><th align="center">编号范围</th><th align="center">二进制格式</th></tr></thead><tbody><tr><td align="center">0x00 - 0x7F（0 - 127）</td><td align="center">0XXXXXXX</td></tr><tr><td align="center">0x80 - 0x7FF （128 - 2047）</td><td align="center">110XXXXX - 10XXXXXX</td></tr><tr><td align="center">0x800 - 0xFFFF （2048 - 65535）</td><td align="center">1110XXXX 10XXXXXX 10XXXXXX</td></tr><tr><td align="center">0x10000 - 0x10FFFF （65536及以上）</td><td align="center">11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</td></tr></tbody></table><p>我们保存在内存中的数据都是 Unicode 编码，只有存储到硬盘上或者在网络传输中，才把 Unicode 编码转换成 UTF-8、GBK或者其他编码。</p><h1 id="Python3中的编码"><a href="#Python3中的编码" class="headerlink" title="Python3中的编码"></a>Python3中的编码</h1><p>在 python3 中，有文本字符串类型（str对象）和字节字符串类型（byte对象）两种字符串，str类型的对象都是 Unicode，因此对于 str 类型的对象只有encode（）方法，没有decode（）方法（若运行，会报错）。byte对象是由str类型的对象使用 encode() 方法产生的，byte 对象可以进行解码，从而得到真正的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.encode(encoding&#x3D;&quot;utf-8&quot;, errors&#x3D;&quot;strict&quot;)：将 unicode 字符串转换为 byte 字节流</span><br><span class="line">bytes.decode(encoding&#x3D;&quot;utf-8&quot;, errors&#x3D;&quot;strict&quot;)：将 byte 字节流转换为 unicode 字符串</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件开发中，编码是一件很重要的工作，它涉及到了数据的传输与读取等方面。今天介绍下编码相关的知识。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>国外优质开发者社区汇总</title>
    <link href="http://wyzane.gitee.io/blog/2020/06/15/%E5%9B%BD%E5%A4%96%E4%BC%98%E8%B4%A8%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA%E6%B1%87%E6%80%BB/"/>
    <id>http://wyzane.gitee.io/blog/2020/06/15/%E5%9B%BD%E5%A4%96%E4%BC%98%E8%B4%A8%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA%E6%B1%87%E6%80%BB/</id>
    <published>2020-06-15T14:28:22.000Z</published>
    <updated>2020-06-15T14:39:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享一些优质的国外开发者社区，从这些社区中我们能了解软件行业的发展前景、各种新奇有趣的开发技术，帮助我们拓宽视野，增长知识，顺便学习一下英语。</p><p>开发者社区有下面这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;dzone.com&#x2F;</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.infoq.com&#x2F;</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;bytes.com</span><br></pre></td></tr></table></figure><p>后续还会更新 …</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天分享一些优质的国外开发者社区，从这些社区中我们能了解软件行业的发展前景、各种新奇有趣的开发技术，帮助我们拓宽视野，增长知识，顺便学习一下英语。&lt;/p&gt;
&lt;p&gt;开发者社区有下面这些：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
