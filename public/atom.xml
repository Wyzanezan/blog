<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wyzane&#39;s Blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://wyzane.gitee.io/blog/"/>
  <updated>2024-03-01T04:30:38.049Z</updated>
  <id>http://wyzane.gitee.io/blog/</id>
  
  <author>
    <name>Wyzane</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LlamaIndex的介绍</title>
    <link href="http://wyzane.gitee.io/blog/2024/03/01/LlamaIndex%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://wyzane.gitee.io/blog/2024/03/01/LlamaIndex%E7%9A%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-03-01T04:04:54.000Z</published>
    <updated>2024-03-01T04:30:38.049Z</updated>
    
    <content type="html"><![CDATA[<p>LlamaIndex 是一个基于 LLM 应用程序的数据框架，受益于上下文增强。它提供了必要的抽象，可以更轻松地摄取、构建和访问私有或特定领域的数据，以便将这些数据安全可靠地注入 LLM 中，以实现更准确的文本生成。</p><a id="more"></a><p>LlamaIndex 可以在 Python 和 Typescript 中使用。</p><p>为什么要进行上下文增强呢？<br>LLM 在人类和数据之间提供自然语言接口。广泛可用的模型是根据大量公开数据（如维基百科、邮件列表、教科书、源代码等）进行预训练的。<br>然而，虽然 LLM 接受了大量数据的培训，但他们并没有接受你的数据的培训，这些数据可能是私有的或特定于您试图解决的问题。它位于 API 后面、SQL 数据库中，或者隐藏在 PDF 和幻灯片中。<br>您可以选择用您的数据微调 LLM，但是： </p><ol><li>训练 LLM 的费用很高，</li><li>由于培训成本的原因，很难用最新信息更新 LLM，</li><li>缺乏可观察性。当你向 LLM 提出问题时，LLM 是如何得出答案的并不明显。</li></ol><p>我们可以使用一种称为检索增强生成 (RAG) 的上下文增强模式来代替微调，以获得与您的特定数据相关的更准确的文本生成。 RAG 涉及以下高级步骤：</p><ol><li>首先从数据源检索信息</li><li>将其作为上下文添加到您的问题中，并且</li><li>请 LLM 根据丰富的提示进行回答</li></ol><p>通过这样做，RAG 克服了微调方法的三个弱点：</p><ol><li>不需要训练 LLM，所以很便宜</li><li>仅当您请求数据时才会获取数据，因此数据始终是最新的</li><li>LlamaIndex可以向您显示检索到的文档，因此更值得信赖</li></ol><p>为什么使用 LlamaIndex 进行上下文增强？<br>首先，LlamaIndex 对您如何使用 LLM 没有任何限制。您仍然可以将 LLM 用作自动完成、聊天机器人、半自主代理等。它只会让 LLM 与您更相关。<br>LlamaIndex 提供以下工具来帮助您快速建立可用于生产的 RAG 系统：</p><ol><li>Data Connector 从其本机源和格式获取现有数据。这些可以是 API、PDF、SQL 等等。</li><li>Data Index 以中间表示形式构建数据，这些中间表示形式对于 LLM 来说既简单又高效</li><li>Engines 提供对数据的自然语言访问，例如<br>查询引擎是用于知识增强输出的强大检索接口。<br>聊天引擎是用于与数据进行多消息、“来回”交互的对话界面。</li><li>Data Agents 是由 LLM 提供支持的知识工作者，并通过工具进行增强，从简单的辅助函数到 API 集成等。</li><li>Application integrations 将 LlamaIndex 重新融入生态系统的其余部分。这可以是 LangChain、Flask、Docker、ChatGPT，或者……其他任何东西！</li></ol><p>LlamaIndex 适合谁？</p><ol><li>LlamaIndex 为初学者、高级用户以及介于两者之间的每个人提供工具。 </li><li>我们的高级 API 允许初学者使用 LlamaIndex 通过 5 行代码获取和查询他们的数据。</li><li>对于更复杂的应用程序，我们的较低级别 API 允许高级用户自定义和扩展任何模块（数据连接器、索引、检索器、查询引擎、重新排名模块）以满足他们的需求。</li></ol><h1 id="LlamaIndex的安装"><a href="#LlamaIndex的安装" class="headerlink" title="LlamaIndex的安装"></a>LlamaIndex的安装</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install llama-index</span><br></pre></td></tr></table></figure><p>这个包中包含了以下包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">llama-index-core</span><br><span class="line">llama-index-legacy  # temporarily included</span><br><span class="line">llama-index-llms-openai</span><br><span class="line">llama-index-embeddings-openai</span><br><span class="line">llama-index-program-openai</span><br><span class="line">llama-index-question-gen-openai</span><br><span class="line">llama-index-agent-openai</span><br><span class="line">llama-index-readers-file</span><br><span class="line">llama-index-multi-modal-llms-openai</span><br></pre></td></tr></table></figure><p>LlamaIndex 可以下载并存储各种软件包的本地文件（NLTK、HuggingFace 等）。使用环境变量“LLAMA_INDEX_CACHE_DIR”来控制这些文件的保存位置。</p><p>默认情况下，llamaIndex 使用 OpenAI gpt-3.5-turbo 模型进行文本生成，使用 text-embedding-ada-002 进行检索和嵌入。为了使用它，必须将 OPENAI_API_KEY 设置为环境变量。</p><h1 id="LlamaIndex的使用"><a href="#LlamaIndex的使用" class="headerlink" title="LlamaIndex的使用"></a>LlamaIndex的使用</h1><p>下面是一个在 LlamaIndex 中使用 Ollama 的例子，需要首先安装 llama-index-llms-ollama：pip install llama-index-llms-ollama。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> SummaryIndex, SimpleDirectoryReader</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> llama_index.llms.ollama <span class="keyword">import</span> Ollama</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 llm</span></span><br><span class="line">Settings.llm = Ollama(model=<span class="string">"llama2"</span>, request_timeout=<span class="number">60.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">"./data"</span>).load_data()</span><br><span class="line"><span class="comment"># 根据数据创建index</span></span><br><span class="line">index = SummaryIndex.from_documents(documents)</span><br><span class="line"><span class="comment"># 创建查询引擎</span></span><br><span class="line">query_engine = index.as_query_engine()</span><br><span class="line"><span class="comment"># 查询数据</span></span><br><span class="line">response = query_engine.query(<span class="string">"What did the author do growing up?"</span>)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出，使用 LlamaIndex 开发的大致步骤如下：</p><ol><li>创建一个 LLM 对象</li><li>加载数据</li><li>根据数据创建索引</li><li>创建查询引擎</li><li>查询引擎调用接口获取接口</li></ol><p>下面具体介绍每个步骤如何执行。</p><h2 id="如何加载数据"><a href="#如何加载数据" class="headerlink" title="如何加载数据"></a>如何加载数据</h2><h3 id="从目录中加载数据"><a href="#从目录中加载数据" class="headerlink" title="从目录中加载数据"></a>从目录中加载数据</h3><p>最容易使用的 reader 是我们的 SimpleDirectoryReader，它可以根据给定目录中的每个文件创建文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> SimpleDirectoryReader</span><br><span class="line"><span class="comment"># 从 data 目录中加载数据</span></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">"./data"</span>).load_data()</span><br></pre></td></tr></table></figure><h3 id="从数据库查询数据"><a href="#从数据库查询数据" class="headerlink" title="从数据库查询数据"></a>从数据库查询数据</h3><p>可以使用 DatabaseReader 连接器，该连接器对 SQL 数据库运行查询并将结果的每一行作为文档返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> download_loader</span><br><span class="line"><span class="keyword">from</span> llama_index.readers.database <span class="keyword">import</span> DatabaseReader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库连接器</span></span><br><span class="line">reader = DatabaseReader(</span><br><span class="line">    scheme=os.getenv(<span class="string">"DB_SCHEME"</span>),</span><br><span class="line">    host=os.getenv(<span class="string">"DB_HOST"</span>),</span><br><span class="line">    port=os.getenv(<span class="string">"DB_PORT"</span>),</span><br><span class="line">    user=os.getenv(<span class="string">"DB_USER"</span>),</span><br><span class="line">    password=os.getenv(<span class="string">"DB_PASS"</span>),</span><br><span class="line">    dbname=os.getenv(<span class="string">"DB_NAME"</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">query = <span class="string">"SELECT * FROM users"</span></span><br><span class="line">documents = reader.load_data(query=query)</span><br></pre></td></tr></table></figure><h2 id="如何处理数据"><a href="#如何处理数据" class="headerlink" title="如何处理数据"></a>如何处理数据</h2><p>加载数据后，您需要处理和转换数据，然后再将其放入存储系统。这些转换包括分块、提取元数据和嵌入每个块。这是确保 LLM 能够检索和最佳使用数据所必需的。<br>处理和转换输入/输出是 Node 对象（Document 是 Node 的子类），也可以对它们进行堆叠和重新排序。</p><p>加载数据的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex</span><br><span class="line"></span><br><span class="line">vector_index = VectorStoreIndex.from_documents(documents)</span><br><span class="line">vector_index.as_query_engine()</span><br></pre></td></tr></table></figure><p>上面的代码是没有经过文本分割处理的，from_documents() 方法可以接受 Document 对象数组，并正确解析它们并将它们分块。但是，有时您需要更好地控制文档的拆分方式，此时可以自定义文本拆分对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义文档拆分对象</span></span><br><span class="line">text_splitter = SentenceSplitter(chunk_size=<span class="number">512</span>, chunk_overlap=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex</span><br><span class="line"></span><br><span class="line">Settings.text_splitter = text_splitter</span><br><span class="line"></span><br><span class="line">index = VectorStoreIndex.from_documents(</span><br><span class="line">    documents, transformations=[text_splitter]</span><br></pre></td></tr></table></figure><h2 id="创建索引index"><a href="#创建索引index" class="headerlink" title="创建索引index"></a>创建索引index</h2><p>加载数据后，我们已经拥有文档对象列表（或节点列表）。是时候为这些对象构建索引了，以便您可以开始查询它们。<br>在 LlamaIndex 中，索引是由 Document 对象组成的数据结构，旨在支持 LLM 进行查询。您的索引旨在补充您的查询策略。<br>LlamaIndex 提供了几种不同的索引类型，包括：VectorStoreIndex、SummaryIndex。</p><p>VectorStoreIndex 是最常见的索引类型。矢量存储索引获取您的文档并将它们分成节点。然后，它创建每个节点文本的向量嵌入，以供 LLM 查询。<br>VectorStoreIndex 的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex</span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br></pre></td></tr></table></figure><p>什么是向量嵌入？<br>向量嵌入是 LLM 应用程序运行的核心。<br>向量嵌入（通常简称为嵌入）是文本语义或含义的数字表示，具有相似含义的两段文本将具有数学上相似的嵌入，即使实际文本完全不同。<br>这种数学关系支持语义搜索，用户提供查询术语，LlamaIndex 可以定位与查询术语含义相关的文本，而不是简单的关键字匹配。这是检索增强生成的工作原理以及 LLM 的一般运作方式的重要组成部分。<br>嵌入有多种类型，它们的效率、有效性和计算成本各不相同。默认情况下，LlamaIndex 使用 text-embedding-ada-002，这是 OpenAI 使用的默认嵌入。如果您使用不同的 LLM，您通常会想要使用不同的嵌入。<br>VectorStoreIndex 使用 LLM 的 API 将所有文本转换为嵌入；这就是我们说它“嵌入您的文本”的意思。如果您有大量文本，则生成嵌入可能需要很长时间，因为它涉及许多往返 API 调用。<br>当您想要搜索嵌入时，您的查询本身会转换为向量嵌入，然后由 VectorStoreIndex 执行数学运算，根据所有嵌入与您的查询在语义上的相似程度对它们进行排名。<br>排名完成后，VectorStoreIndex 会返回最相似的嵌入作为相应的文本块。它返回的嵌入数量称为 k，因此控制返回多少嵌入的参数称为 top_k。因此，整个类型的搜索通常被称为“top-k 语义检索”。Top-k 检索是查询向量索引的最简单形式。<br>也可以查看一下 OpenAI 关于 embeddings 的文档：<a href="https://platform.openai.com/docs/guides/embeddings" target="_blank" rel="noopener">https://platform.openai.com/docs/guides/embeddings</a></p><p>SummaryIndex 是一种更简单的索引形式，最适合查询，顾名思义，您试图生成文档中文本的摘要。它只是存储所有文档并将它们全部返回到您的查询引擎。</p><h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><p>加载数据并建立索引后，您可能需要存储它以避免重新索引的时间和成本。默认情况下，索引数据仅存储在内存中，也可以将数据存储到磁盘中或者存储到向量数据库中。</p><h3 id="使用磁盘存储"><a href="#使用磁盘存储" class="headerlink" title="使用磁盘存储"></a>使用磁盘存储</h3><p>存储索引数据的最简单方法是使用每个 Index 的内置 .persist() 方法，该方法将所有数据写入磁盘的指定位置。这适用于任何类型的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.storage_context.persist(persist_dir=<span class="string">"&lt;persist_dir&gt;"</span>)</span><br></pre></td></tr></table></figure><p>然后，你可以通过加载持久索引来避免重新加载和重新索引数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> StorageContext, load_index_from_storage</span><br><span class="line">storage_context = StorageContext.from_defaults(persist_dir=<span class="string">"&lt;persist_dir&gt;"</span>)</span><br><span class="line">index = load_index_from_storage(storage_context)</span><br></pre></td></tr></table></figure><h3 id="使用向量存储"><a href="#使用向量存储" class="headerlink" title="使用向量存储"></a>使用向量存储</h3><p>正如索引中所讨论的，最常见的索引类型之一是 VectorStoreIndex。在 VectorStoreIndex 中创建嵌入的 API 调用在时间和金钱方面可能会很昂贵，因此您需要存储它们以避免不断地重新索引。<br>LlamaIndex 支持大量向量存储，这些向量存储的架构、复杂性和成本各不相同。下面将使用 Chroma，一个开源矢量存储数据库。<br>安装 Chroma：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install chromadb</span><br></pre></td></tr></table></figure><p>使用 Chroma 存储 VectorStoreIndex 中嵌入的步骤：</p><ol><li>初始化 Chroma 客户端 </li><li>创建一个集合来将您的数据存储在 Chroma 中 </li><li>将 Chroma 指定为 StorageContext 中的 vector_store</li><li>使用 StorageContext 初始化您的 VectorStoreIndex</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chromadb</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex, SimpleDirectoryReader</span><br><span class="line"><span class="keyword">from</span> llama_index.vector_stores.chroma <span class="keyword">import</span> ChromaVectorStore</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> StorageContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">"./data"</span>).load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Chroma 客户端</span></span><br><span class="line">db = chromadb.PersistentClient(path=<span class="string">"./chroma_db"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建集合或者获取集合</span></span><br><span class="line">chroma_collection = db.get_or_create_collection(<span class="string">"quickstart"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 chroma 作为 vector_store</span></span><br><span class="line">vector_store = ChromaVectorStore(chroma_collection=chroma_collection)</span><br><span class="line">storage_context = StorageContext.from_defaults(vector_store=vector_store)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建索引</span></span><br><span class="line">index = VectorStoreIndex.from_documents(</span><br><span class="line">    documents, storage_context=storage_context</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询</span></span><br><span class="line">query_engine = index.as_query_engine()</span><br><span class="line">response = query_engine.query(<span class="string">"What is the meaning of life?"</span>)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>现在已经加载了数据，构建了索引，并存储了该索引以供以后使用，可以进行查询了。<br>LlamaIndex 中查询就是调用 LLM 时传入一个 prompt：它可以是一个问题并获得答案，或者是一个总结请求，或者是一个更复杂的指令。<br>更复杂的查询可能涉及重复/链式的 prompt + LLM 调用，甚至跨多个组件的推理循环。<br>所有查询的基础是 QueryEngine。获取 QueryEngine 最简单的方法是让索引为您创建一个，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query_engine = index.as_query_engine()</span><br><span class="line">response = query_engine.query(</span><br><span class="line">    <span class="string">"Write an email to the user given their background information."</span></span><br><span class="line">)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>查询由三个不同的阶段组成：</p><ol><li>Retrieval 是指您从索引中找到并返回与您的查询最相关的文档。最常见的 Retrieval 类型是“top-k”语义检索，但还有许多其他检索策略。</li><li>Postprocessing 是指对检索到的数据进行可选的重新排序、转换或过滤，例如要求它们具有特定的元数据，例如附加的关键字。</li><li>Response Synthesis 是将您的查询、最相关的数据和提示组合起来并发送给您的法学硕士以返回响应。</li></ol><p>LlamaIndex 有更低级的 API，可以对上面查询的三个阶段进行精细控制。下面是例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex, get_response_synthesizer</span><br><span class="line"><span class="keyword">from</span> llama_index.core.retrievers <span class="keyword">import</span> VectorIndexRetriever</span><br><span class="line"><span class="keyword">from</span> llama_index.core.query_engine <span class="keyword">import</span> RetrieverQueryEngine</span><br><span class="line"><span class="keyword">from</span> llama_index.core.postprocessor <span class="keyword">import</span> SimilarityPostprocessor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建索引</span></span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 retriever</span></span><br><span class="line">retriever = VectorIndexRetriever(</span><br><span class="line">    index=index,   <span class="comment"># 配置 index</span></span><br><span class="line">    similarity_top_k=<span class="number">10</span>,   <span class="comment"># 设置返回最相似的10个embedding</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 response</span></span><br><span class="line">response_synthesizer = get_response_synthesizer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组成一个 query engine</span></span><br><span class="line">query_engine = RetrieverQueryEngine(</span><br><span class="line">    retriever=retriever,</span><br><span class="line">    response_synthesizer=response_synthesizer,</span><br><span class="line">    node_postprocessors=[SimilarityPostprocessor(similarity_cutoff=<span class="number">0.7</span>)],  <span class="comment"># 设置检索到的节点达到要包含的最小相似度分数。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询</span></span><br><span class="line">response = query_engine.query(<span class="string">"What did the author do growing up?"</span>)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><h3 id="配置Postprocessor"><a href="#配置Postprocessor" class="headerlink" title="配置Postprocessor"></a>配置Postprocessor</h3><p>上面的例子中，使用到了 node_postprocessors，在 LlamaIndex 中支持高级节点过滤和增强，可以进一步提高检索到的节点对象的相关性。这可以帮助减少 LLM 执行的时间/次数/成本或提高响应质量。<br>node 的 Postprocessor 有下面几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KeywordNodePostprocessor: 通过required_keywords和exclusion_keywords过滤节点。</span><br><span class="line">SimilarityPostprocessor: 通过设置相似度分数的阈值来过滤节点（因此仅受基于嵌入的检索器支持）</span><br><span class="line">PrevNextNodePostprocessor：使用基于节点关系的附加相关上下文来增强检索到的节点对象。</span><br></pre></td></tr></table></figure><p>配置一个 KeywordNodePostprocessor 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node_postprocessors = [</span><br><span class="line">    KeywordNodePostprocessor(</span><br><span class="line">        required_keywords=[<span class="string">"Combinator"</span>], exclude_keywords=[<span class="string">"Italy"</span>]</span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line">query_engine = RetrieverQueryEngine.from_args(</span><br><span class="line">    retriever, node_postprocessors=node_postprocessors</span><br><span class="line">)</span><br><span class="line">response = query_engine.query(<span class="string">"What did the author do growing up?"</span>)</span><br></pre></td></tr></table></figure><h3 id="配置Response-synthesis"><a href="#配置Response-synthesis" class="headerlink" title="配置Response synthesis"></a>配置<strong>Response synthesis</strong></h3><p>检索器获取相关节点后，BaseSynthesizer 通过组合信息来合成最终响应，可以通过一下代码配置它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query_engine = RetrieverQueryEngine.from_args(</span><br><span class="line">    retriever, response_mode=response_mode</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面的配置中，我们的 response synthesis 使用的是默认的 BaseSynthesizer，response_mode 参数有如下可选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default：通过顺序遍历每个检索到的节点来“创建和完善”答案；这使得每个节点都有一个单独的 LLM 调用。适合更详细的答案。</span><br><span class="line">compact：在每次 LLM 调用期间“压缩”提示，通过填充尽可能多的节点文本块来适应最大提示大小。如果一个提示中的内容太多，无法填充，通过多个提示来“创建和完善”答案。</span><br><span class="line">tree_summarize：给定一组 Node 对象和查询，递归构造一棵树并返回根节点作为响应。适合总结目的。</span><br><span class="line">no_text：仅运行检索器来获取本应发送到 LLM 的节点，而不实际发送它们。然后可以通过检查response.source_nodes来检查。</span><br><span class="line">accumulate：给定一组 Node 对象和查询，将查询应用于每个 Node 文本块，同时将响应累积到数组中。返回所有响应的串联字符串。适合当您需要对每个文本块单独运行相同的查询时。</span><br></pre></td></tr></table></figure><p>上面简单介绍了一下 LlamaIndex 的基本使用流程。</p><p>参考文档：<a href="https://docs.llamaindex.ai/en/stable/" target="_blank" rel="noopener">https://docs.llamaindex.ai/en/stable/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LlamaIndex 是一个基于 LLM 应用程序的数据框架，受益于上下文增强。它提供了必要的抽象，可以更轻松地摄取、构建和访问私有或特定领域的数据，以便将这些数据安全可靠地注入 LLM 中，以实现更准确的文本生成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>AutoGen的介绍和使用</title>
    <link href="http://wyzane.gitee.io/blog/2024/02/27/AutoGen%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2024/02/27/AutoGen%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-27T04:36:59.000Z</published>
    <updated>2024-02-27T04:45:09.641Z</updated>
    
    <content type="html"><![CDATA[<p>AutoGen 是由微软、宾夕法尼亚州立大学和华盛顿大学合作开发的一个框架，它支持使用多个代理来开发 LLM 应用程序，这些代理可以相互对话来完成任务。</p><a id="more"></a><p>AutoGen 中的代理是可定制的、可对话的，并且无缝地允许人类参与。AutoGen 有如下特点：</p><ol><li><p>可以轻松构建基于多代理对话的下一代 LLM 应用程序。它简化了复杂的 LLM 工作流程的编排、自动化和优化。它最大限度地提高了 LLM 模型的性能并克服了它们的弱点。</p></li><li><p>它支持复杂工作流程的多种对话模式。借助可定制和可对话的代理，开发人员可以使用 AutoGen 构建各种涉及对话自主性、代理数量和代理对话拓扑的对话模式。</p></li><li><p>它提供了一系列具有不同复杂性的工作系统。这些系统涵盖各种领域和复杂性的广泛应用。</p></li><li><p>它提供增强的 LLM 推理。它提供 API 和缓存等实用程序，以及错误处理、多配置推理、上下文编程等高级使用模式。</p></li></ol><p>AutoGen 的功能类似于 LangChain 中的 agents。</p><h1 id="AutoGen的安装"><a href="#AutoGen的安装" class="headerlink" title="AutoGen的安装"></a>AutoGen的安装</h1><p>首先，我们需要安装 AutoGen 的 Python 包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyautogen docker</span><br></pre></td></tr></table></figure><p>安装完成后，我们就可以使用了。</p><h1 id="AutoGen的使用"><a href="#AutoGen的使用" class="headerlink" title="AutoGen的使用"></a>AutoGen的使用</h1><h2 id="加载配置数据"><a href="#加载配置数据" class="headerlink" title="加载配置数据"></a>加载配置数据</h2><p>使用 AutoGen 时，我们首先需要加载配置，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> autogen</span><br><span class="line"></span><br><span class="line"><span class="comment"># config_list = [</span></span><br><span class="line"><span class="comment">#     &#123;</span></span><br><span class="line"><span class="comment">#         "model": "gpt-4-32k",</span></span><br><span class="line"><span class="comment">#         "api_key": os.environ["OPENAI_API_KEY"],</span></span><br><span class="line"><span class="comment">#         "tags": ["gpt-4-32"]</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &#123;</span></span><br><span class="line"><span class="comment">#         "model": "gpt-4",</span></span><br><span class="line"><span class="comment">#         "api_key": os.environ["OPENAI_API_KEY"],</span></span><br><span class="line"><span class="comment">#         "tags": ["gpt-4"]</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &#123;</span></span><br><span class="line"><span class="comment">#          "model": "llama2",</span></span><br><span class="line"><span class="comment">#          "tags": ["llama2"]</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择需要使用的模型</span></span><br><span class="line">filter_dict = &#123;</span><br><span class="line">    <span class="string">"model"</span>: <span class="string">"gpt-4"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config_list = autogen.config_list_from_json(</span><br><span class="line">    <span class="string">"OAI_CONFIG_LIST"</span>,</span><br><span class="line">    filter_dict=filter_dict,   <span class="comment"># 指定需要使用的模型</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># agent访问 LLM 的相关配置</span></span><br><span class="line">llm_config = &#123;</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="number">600</span>,</span><br><span class="line">    <span class="string">"cache_seed"</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="string">"config_list"</span>: config_list,   <span class="comment"># LLM 配置列表</span></span><br><span class="line">    <span class="string">"temperature"</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 config_list 中，可以配置很多模型供不同的 task 使用。config_list 可以直接是一个列表，也可以使用 autogen.config_list_from_json() 从 OAI_CONFIG_LIST 中加载配置数据，OAI_CONFIG_LIST 可以是一个json文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;model&quot;: &quot;gpt-4-32k&quot;,</span><br><span class="line">        &quot;api_key&quot;: &quot;xxx&quot;,</span><br><span class="line">        &quot;tags&quot;: [&quot;gpt-4-32&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;model&quot;: &quot;gpt-4&quot;,</span><br><span class="line">        &quot;api_key&quot;: &quot;xxx&quot;,</span><br><span class="line">        &quot;tags&quot;: [&quot;gpt-4&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;model&quot;: &quot;llama2&quot;,</span><br><span class="line">        &quot;tage&quot;: [&quot;llama2&quot;, &quot;local&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>agent 会使用 config_list 中可用的第一个模型，并针对该模型进行 LLM 调用。如果第一个模型调用失败，agent 将针对第二个模型重试请求，依此类推，直到收到提示完成消息。</p><p>如果我们有多个 LLM，但是想指定使用其中的一个，可以使用 filter_dict 进行过滤，比如要指定使用 gpt-4 这个模型，就可以这样配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择需要使用的模型</span></span><br><span class="line">filter_dict = &#123;</span><br><span class="line">    <span class="string">"model"</span>: <span class="string">"gpt-4"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config_list = autogen.config_list_from_json(</span><br><span class="line">    <span class="string">"OAI_CONFIG_LIST"</span>,</span><br><span class="line">    filter_dict=filter_dict,   <span class="comment"># 指定需要使用的模型</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然，我们也可以使用 tags 进行过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter_dict = &#123;</span><br><span class="line">    <span class="string">"tags"</span>: [<span class="string">"gpt-4"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 tags 进行过滤时，tags 的值是一个列表，列表中可以指定多个 LLM。</p><h2 id="创建并运行agent"><a href="#创建并运行agent" class="headerlink" title="创建并运行agent"></a>创建并运行agent</h2><p>创建 agent 时，上面的 llm_config 配置需要作为参数传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assistant = autogen.AssistantAgent(</span><br><span class="line">    name=<span class="string">"assistant"</span>,   <span class="comment"># agent名称</span></span><br><span class="line">    llm_config=llm_config,   <span class="comment"># agent配置</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个用户代理，该代理可以执行代码，并将结果反馈给其他代理</span></span><br><span class="line">user_proxy = autogen.UserProxyAgent(</span><br><span class="line">    name=<span class="string">"user_proxy"</span>,</span><br><span class="line">    human_input_mode=<span class="string">"NEVER"</span>,</span><br><span class="line">    max_consecutive_auto_reply=<span class="number">10</span>,</span><br><span class="line">    is_termination_msg=<span class="keyword">lambda</span> x: x.get(<span class="string">"content"</span>, <span class="string">""</span>).rstrip().endswith(<span class="string">"TERMINATE"</span>),</span><br><span class="line">    code_execution_config=&#123;</span><br><span class="line">        <span class="string">"work_dir"</span>: <span class="string">"web"</span>,</span><br><span class="line">        <span class="string">"use_docker"</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;, </span><br><span class="line">    llm_config=llm_config,</span><br><span class="line">    system_message=<span class="string">"""Reply TERMINATE if the task has been solved at full satisfaction.</span></span><br><span class="line"><span class="string">Otherwise, reply CONTINUE, or the reason why the task is not solved yet."""</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>创建 UserProxyAgent 对象时，参数的含义为：</p><p>name：指定用户代理的名称</p><p>human_input_mode：用户输入的模式，即是否在每次收到消息时请求人工输入。可能的值有 “ALWAYS”，”NEVER”，”TERMINATE”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS：表示每次收到消息时，代理都会提示人工输入，这种模式下，当用户输入 exit 或者 is_termination_msg 参数为 True 时，对话会退出。</span><br><span class="line">NEVER：表示代理永远不会提示人工输入，这种模式下，当自动回复次数达到 max_consecutive_auto_reply 设置的值或者 is_termination_msg 为 True 时，对话会停止。</span><br><span class="line">TERMINATE：表示仅当收到终止消息或自动回复数量达到 max_consecutive_auto_reply 设置的值时，代理才会提示人工输入。</span><br></pre></td></tr></table></figure><p>max_consecutive_auto_reply：一个 int 值，设置最大连续自动回复数，默认为 None，没有限制。该限制仅在 human_input_mode 不是“ALWAYS”时起作用。</p><p>is_termination_msg：该参数值是一个函数，它接受字典形式的消息并返回一个布尔值，指示收到的消息是否是终止消息，该字典可以包含以下键：“content”、“role”、“name”、“function_call”。</p><p>code_execution_config：是一个字典或者 False，表示执行的代码需要的配置。字典中的配置项有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">work_dir（可选，str）：代码执行的工作目录。如果没有，将使用默认工作目录。默认工作目录是“path_to_autogen”下的“extensions”目录。</span><br><span class="line">use_docker（可选，list、str 或 bool）：用于执行代码的 docker 容器。默认值为 True，这意味着代码将在 docker 容器中执行。将使用默认的镜像列表。如果提供了镜像名称的列表或字符串，则代码将在 docker 容器中执行，并成功拉取第一个镜像。如果为 False，则代码将在当前环境中执行。</span><br><span class="line">timeout（可选，int类型）：最大执行时间（以秒为单位）。</span><br><span class="line">last_n_messages（可选，int类型）：要回顾代码执行的消息数。默认为 1。</span><br></pre></td></tr></table></figure><p>llm_config：LLM 的配置信息</p><p>system_message：str 或者 list 类型，用于 ChatCompletion 聊天的系统消息，仅当 llm_config 不为 False 时使用。</p><p>最后，执行 user agent 初始化聊天：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user_proxy.initiate_chat(</span><br><span class="line">    assistant,   <span class="comment"># 接收消息的 agent，就是我们上面创建的 assistant agent</span></span><br><span class="line">    message=<span class="string">"""帮我分析一下过去一个月A股中药明康德这只股票的变化情况"""</span>,   <span class="comment"># 传递的消息内容</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面是它的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">[user_proxy[0m (to assistant):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">帮我分析一下过去一个月A股中药明康德这只股票的变化情况</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[assistant[0m (to user_proxy):</span><br><span class="line"></span><br><span class="line">首先，我们需要从网络上获取股票数据。我们可以使用Python的pandas_datareader库来获取这些数据。以下是获取过去一个月药明康德（股票代码：603259.SH）股票数据的代码。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># filename: stock_analysis.py</span><br><span class="line"></span><br><span class="line">import pandas_datareader as pdr</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># Define the stock to be analyzed</span><br><span class="line">stock_code &#x3D; &#39;603259.SS&#39;</span><br><span class="line"></span><br><span class="line"># Define the time period</span><br><span class="line">end_date &#x3D; datetime.datetime.now()</span><br><span class="line">start_date &#x3D; end_date - datetime.timedelta(days&#x3D;30)</span><br><span class="line"></span><br><span class="line"># Get the stock data</span><br><span class="line">stock_data &#x3D; pdr.get_data_yahoo(stock_code, start_date, end_date)</span><br><span class="line"></span><br><span class="line"># Print the stock data</span><br><span class="line">print(stock_data)</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">请运行这段代码，它将输出过去一个月药明康德的股票数据，包括每天的开盘价、最高价、最低价、收盘价和成交量。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[31m</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; EXECUTING CODE BLOCK 0 (inferred language is python)...[0m</span><br><span class="line">[33muser_proxy[0m (to assistant):</span><br><span class="line"></span><br><span class="line">exitcode: 1 (execution failed)</span><br><span class="line">Code output: </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;stock_analysis.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    stock_data &#x3D; pdr.get_data_yahoo(stock_code, start_date, end_date)</span><br><span class="line">                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;zanwang&#x2F;dev&#x2F;AutoGenproject&#x2F;pyautogen&#x2F;lib&#x2F;python3.11&#x2F;site-packages&#x2F;pandas_datareader&#x2F;data.py&quot;, line 80, in get_data_yahoo</span><br><span class="line">    return YahooDailyReader(*args, **kwargs).read()</span><br><span class="line">           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;zanwang&#x2F;dev&#x2F;AutoGenproject&#x2F;pyautogen&#x2F;lib&#x2F;python3.11&#x2F;site-packages&#x2F;pandas_datareader&#x2F;base.py&quot;, line 253, in read</span><br><span class="line">    df &#x3D; self._read_one_data(self.url, params&#x3D;self._get_params(self.symbols))</span><br><span class="line">         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;zanwang&#x2F;dev&#x2F;AutoGenproject&#x2F;pyautogen&#x2F;lib&#x2F;python3.11&#x2F;site-packages&#x2F;pandas_datareader&#x2F;yahoo&#x2F;daily.py&quot;, line 153, in _read_one_data</span><br><span class="line">    data &#x3D; j[&quot;context&quot;][&quot;dispatcher&quot;][&quot;stores&quot;][&quot;HistoricalPriceStore&quot;]</span><br><span class="line">           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">TypeError: string indices must be integers, not &#39;str&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[33massistant[0m (to user_proxy):</span><br><span class="line"></span><br><span class="line">看起来我们在获取Yahoo财经数据时遇到了问题。这可能是由于Yahoo财经的API发生了变化或者是由于网络问题。我们可以尝试使用另一个库，如yfinance，它专门用于从Yahoo财经获取数据。</span><br><span class="line"></span><br><span class="line">以下是使用yfinance库获取过去一个月药明康德（股票代码：603259.SS）股票数据的代码。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># filename: stock_analysis.py</span><br><span class="line"></span><br><span class="line">import yfinance as yf</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># Define the stock to be analyzed</span><br><span class="line">stock_code &#x3D; &#39;603259.SS&#39;</span><br><span class="line"></span><br><span class="line"># Define the time period</span><br><span class="line">end_date &#x3D; datetime.datetime.now()</span><br><span class="line">start_date &#x3D; end_date - datetime.timedelta(days&#x3D;30)</span><br><span class="line"></span><br><span class="line"># Get the stock data</span><br><span class="line">stock_data &#x3D; yf.download(stock_code, start_date, end_date)</span><br><span class="line"></span><br><span class="line"># Print the stock data</span><br><span class="line">print(stock_data)</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">请运行这段代码，它将输出过去一个月药明康德的股票数据，包括每天的开盘价、最高价、最低价、收盘价和成交量。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[31m</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; EXECUTING CODE BLOCK 0 (inferred language is python)...[0m</span><br><span class="line">[33muser_proxy[0m (to assistant):</span><br><span class="line"></span><br><span class="line">exitcode: 0 (execution succeeded)</span><br><span class="line">Code output: </span><br><span class="line">                 Open       High        Low      Close  Adj Close     Volume</span><br><span class="line">Date                                                                        </span><br><span class="line">2024-01-29  63.000000  63.980000  59.360001  59.360001  59.360001  106097922</span><br><span class="line">2024-01-30  56.400002  58.599998  56.180000  56.849998  56.849998   87396491</span><br><span class="line">2024-01-31  56.000000  56.549999  53.900002  54.200001  54.200001   65697194</span><br><span class="line">2024-02-01  54.560001  56.939999  53.730000  55.799999  55.799999   58337298</span><br><span class="line">2024-02-02  56.910000  57.430000  50.220001  50.220001  50.220001   65707485</span><br><span class="line">2024-02-05  46.279999  51.730000  45.200001  48.230000  48.230000  159302508</span><br><span class="line">2024-02-06  46.860001  52.810001  45.369999  52.250000  52.250000  113259142</span><br><span class="line">2024-02-07  53.610001  56.380001  53.610001  55.250000  55.250000  111295644</span><br><span class="line">2024-02-08  53.650002  54.500000  52.000000  53.119999  53.119999   99007432</span><br><span class="line">2024-02-19  50.500000  51.279999  48.619999  50.049999  50.049999  132806402</span><br><span class="line">2024-02-20  49.849998  51.639999  49.330002  51.570000  51.570000  100319873</span><br><span class="line">2024-02-21  51.000000  55.500000  50.820000  53.740002  53.740002  108874573</span><br><span class="line">2024-02-22  53.090000  54.360001  52.880001  54.110001  54.110001   62886204</span><br><span class="line">2024-02-23  54.040001  54.180000  52.549999  53.580002  53.580002   69410659</span><br><span class="line">2024-02-26  53.840000  55.299999  53.750000  55.000000  55.000000   50604459</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[assistant[0m (to user_proxy):</span><br><span class="line"></span><br><span class="line">根据输出的数据，我们可以看到过去一个月药明康德（股票代码：603259.SS）的股票每天的开盘价、最高价、最低价、收盘价和成交量。这些数据可以帮助我们了解股票的变化情况。</span><br><span class="line"></span><br><span class="line">接下来，我们可以对这些数据进行一些基本的分析，例如计算平均收盘价、最高价和最低价，以及成交量。以下是进行这些计算的代码：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># filename: stock_analysis.py</span><br><span class="line"></span><br><span class="line">import yfinance as yf</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># Define the stock to be analyzed</span><br><span class="line">stock_code &#x3D; &#39;603259.SS&#39;</span><br><span class="line"></span><br><span class="line"># Define the time period</span><br><span class="line">end_date &#x3D; datetime.datetime.now()</span><br><span class="line">start_date &#x3D; end_date - datetime.timedelta(days&#x3D;30)</span><br><span class="line"></span><br><span class="line"># Get the stock data</span><br><span class="line">stock_data &#x3D; yf.download(stock_code, start_date, end_date)</span><br><span class="line"></span><br><span class="line"># Calculate the average close price</span><br><span class="line">average_close &#x3D; stock_data[&#39;Close&#39;].mean()</span><br><span class="line"></span><br><span class="line"># Calculate the highest price</span><br><span class="line">highest_price &#x3D; stock_data[&#39;High&#39;].max()</span><br><span class="line"></span><br><span class="line"># Calculate the lowest price</span><br><span class="line">lowest_price &#x3D; stock_data[&#39;Low&#39;].min()</span><br><span class="line"></span><br><span class="line"># Calculate the average volume</span><br><span class="line">average_volume &#x3D; stock_data[&#39;Volume&#39;].mean()</span><br><span class="line"></span><br><span class="line"># Print the results</span><br><span class="line">print(f&#39;Average close price: &#123;average_close&#125;&#39;)</span><br><span class="line">print(f&#39;Highest price: &#123;highest_price&#125;&#39;)</span><br><span class="line">print(f&#39;Lowest price: &#123;lowest_price&#125;&#39;)</span><br><span class="line">print(f&#39;Average volume: &#123;average_volume&#125;&#39;)</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">请运行这段代码，它将输出过去一个月药明康德的平均收盘价、最高价、最低价和平均成交量。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[31m</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; EXECUTING CODE BLOCK 0 (inferred language is python)...[0m</span><br><span class="line">[33muser_proxy[0m (to assistant):</span><br><span class="line"></span><br><span class="line">exitcode: 0 (execution succeeded)</span><br><span class="line">Code output: </span><br><span class="line">Average close price: 53.55533345540365</span><br><span class="line">Highest price: 63.97999954223633</span><br><span class="line">Lowest price: 45.20000076293945</span><br><span class="line">Average volume: 92733552.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[assistant[0m (to user_proxy):</span><br><span class="line"></span><br><span class="line">根据输出的结果，我们可以得到以下分析：</span><br><span class="line"></span><br><span class="line">- 过去一个月药明康德的平均收盘价为53.56元。</span><br><span class="line">- 过去一个月药明康德的最高价为63.98元。</span><br><span class="line">- 过去一个月药明康德的最低价为45.20元。</span><br><span class="line">- 过去一个月药明康德的平均成交量为92733552.4股。</span><br><span class="line"></span><br><span class="line">这些数据可以帮助我们了解药明康德在过去一个月的股票表现。然而，这只是基本的分析，如果需要更深入的分析，可能需要考虑更多的因素，如市场环境、公司基本面、行业动态等。</span><br><span class="line"></span><br><span class="line">TERMINATE</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>从上面的输出可以看出，assistant agent 编写了数据抓取代码和数据分析代码并执行了它们，并且可以处理遇到的错误，还是非常强大的。这个问题如果直接问 ChatGPT，它是不会直接给出答案的，但是通过使用 AutoGen 就可以获取答案，用来获取和分析实时数据是非常不错的。</p><p>我们还可以创建一个 chat group，这个 chat group 中可以有多个 assistant agent，每个 assistant agent 可以有不同的功能。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">user_proxy = autogen.UserProxyAgent(</span><br><span class="line">    name=<span class="string">"User_proxy"</span>,</span><br><span class="line">    system_message=<span class="string">"A human admin."</span>,</span><br><span class="line">    code_execution_config=&#123;</span><br><span class="line">        <span class="string">"last_n_messages"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">"work_dir"</span>: <span class="string">"groupchat"</span>,</span><br><span class="line">        <span class="string">"use_docker"</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    human_input_mode=<span class="string">"TERMINATE"</span>,</span><br><span class="line">)</span><br><span class="line">coder = autogen.AssistantAgent(</span><br><span class="line">    name=<span class="string">"Coder"</span>,</span><br><span class="line">    llm_config=llm_config,</span><br><span class="line">)</span><br><span class="line">pm = autogen.AssistantAgent(</span><br><span class="line">    name=<span class="string">"Product_manager"</span>,</span><br><span class="line">    system_message=<span class="string">"Creative in software product ideas."</span>,</span><br><span class="line">    llm_config=llm_config,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个聊天组</span></span><br><span class="line">groupchat = autogen.GroupChat(agents=[user_proxy, coder, pm], messages=[], max_round=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 创建一个管理员</span></span><br><span class="line">manager = autogen.GroupChatManager(groupchat=groupchat, llm_config=llm_config)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始聊天</span></span><br><span class="line">user_proxy.initiate_chat(</span><br><span class="line">    manager, message=<span class="string">"Find a latest paper about gpt-4 on arxiv and find its potential applications in software."</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>关于 AutoGen 使用的更多例子，可以查看官方文档：<a href="https://microsoft.github.io/autogen/docs/Examples" target="_blank" rel="noopener">https://microsoft.github.io/autogen/docs/Examples</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AutoGen 是由微软、宾夕法尼亚州立大学和华盛顿大学合作开发的一个框架，它支持使用多个代理来开发 LLM 应用程序，这些代理可以相互对话来完成任务。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Ollama的介绍和使用</title>
    <link href="http://wyzane.gitee.io/blog/2024/02/25/Ollama%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2024/02/25/Ollama%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-25T02:32:44.000Z</published>
    <updated>2024-02-25T03:03:05.940Z</updated>
    
    <content type="html"><![CDATA[<p>Ollama是一个开源工具，它能帮助我们在本地搭建和运行Llama2、Mistral、Gemma等开源LLM服务，方便我们构建自己的 LLM 应用。</p><p>今天介绍下它的使用。</p><a id="more"></a><h1 id="Ollama的安装"><a href="#Ollama的安装" class="headerlink" title="Ollama的安装"></a>Ollama的安装</h1><p>Linux环境下，Ollama的安装方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;ollama.com&#x2F;install.sh | sh</span><br></pre></td></tr></table></figure><p>Mac环境下，去官网下载安装包进行安装，下载地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;ollama.com&#x2F;download&#x2F;mac</span><br></pre></td></tr></table></figure><p>安装完成后，我们可以执行 ollama 命令查看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  ollama [flags]</span><br><span class="line">  ollama [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  serve       Start ollama</span><br><span class="line">  create      Create a model from a Modelfile</span><br><span class="line">  show        Show information for a model</span><br><span class="line">  run         Run a model</span><br><span class="line">  pull        Pull a model from a registry</span><br><span class="line">  push        Push a model to a registry</span><br><span class="line">  list        List models</span><br><span class="line">  cp          Copy a model</span><br><span class="line">  rm          Remove a model</span><br><span class="line">  help        Help about any command</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help      help for ollama</span><br><span class="line">  -v, --version   Show version information</span><br><span class="line"></span><br><span class="line">Use &quot;ollama [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><h1 id="Ollama的使用"><a href="#Ollama的使用" class="headerlink" title="Ollama的使用"></a>Ollama的使用</h1><p>通过查看 Ollama 的命令，可以发现它很像 Docker。</p><p>需要拉取模型到本地时，我们可以使用 ollama pull 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ollama pull gemma</span><br><span class="line">ollama pull llama2</span><br><span class="line">ollama pull mistral</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看本地已存在的模型时，可以运行：ollama list</p><p>在本地运行一个模型时，可以执行：ollama run gemma</p><p>运行模型后，会出现这样的对话界面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zanwang@zan ~ % ollama run gemma</span><br><span class="line">&gt;&gt;&gt; hello</span><br><span class="line">Hello, hello! 👋</span><br><span class="line">It&#39;s nice to hear from you. What would you like to talk about today?</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; who are you</span><br><span class="line">I am an AI language model, designed to provide you with information and </span><br><span class="line">engage in conversation on various topics. I am still under development, </span><br><span class="line">but I am constantly learning new things.</span><br><span class="line">Would you like me to tell you more about myself or would you like to ask </span><br><span class="line">me a question?</span><br></pre></td></tr></table></figure><p>我们可以输入问题，然后等待模型的回答。</p><p>我们还可以使用 ollama create 命令来创建一个 LLM.</p><p>首先要编写一个 Modefile 文件，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM qwen</span><br><span class="line"></span><br><span class="line"># set the temperature to 1 [higher is more creative, lower is more coherent]</span><br><span class="line">PARAMETER temperature 1</span><br><span class="line">PARAMETER max_tokens 10</span><br><span class="line"></span><br><span class="line"># set the system message</span><br><span class="line">SYSTEM &quot;&quot;&quot;</span><br><span class="line">You are Tracy, a execllent teacher. Answer as Tracy, the assistant, only.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>我上面基于通义千问qwen模型创建了一个LLM，设置它的 temperature 为1。</p><p>执行以下命令创建该模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama create tracy(模型名称) -f .&#x2F;Modefile</span><br></pre></td></tr></table></figure><p>创建完成后，我们可以执行 ollama list 查看模型列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zanwang@zan ollamaproject % ollama list</span><br><span class="line">NAME                 ID          SIZE  MODIFIED      </span><br><span class="line">codellama:latest     8fdf8f752f6e3.8 GB47 hours ago </span><br><span class="line">gemma:latest         430ed35350495.2 GB47 hours ago </span><br><span class="line">llama2:latest        78e26419b4463.8 GB2 days ago   </span><br><span class="line">llama2-chinese:latestcee11d703eee3.8 GB47 hours ago </span><br><span class="line">mistral:latest       61e88e8845074.1 GB47 hours ago </span><br><span class="line">qwen:latest          d53d042900642.3 GB46 hours ago </span><br><span class="line">tracy:latest         e941b7cd9ad82.3 GB9 seconds ago</span><br></pre></td></tr></table></figure><p>然后我们就可以使用它了：ollama run tracy</p><h1 id="Ollama-API的使用"><a href="#Ollama-API的使用" class="headerlink" title="Ollama API的使用"></a>Ollama API的使用</h1><p>除了直接聊天，ollama 还提供了 REST API 供我们使用，我们可以像调用 OpenAI 接口那样调用 ollama 的接口。启动 ollama 服务以后，我们可以直接调用接口获取 LLM 的响应，</p><p>我们可以调用聊天接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zanwang@zan blog % curl http:&#x2F;&#x2F;localhost:11434&#x2F;api&#x2F;chat -d &#39;&#123;</span><br><span class="line">  &quot;model&quot;: &quot;qwen&quot;,</span><br><span class="line">  &quot;messages&quot;: [</span><br><span class="line">    &#123; &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure><p>api/chat 接口可以传入以下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model: 模型名称</span><br><span class="line">messages: 消息内容</span><br><span class="line">format: 响应数据的格式，默认是json</span><br><span class="line">template: prompt的模板</span><br><span class="line">stream: 是否流式输出, 默认true</span><br></pre></td></tr></table></figure><p>也可以调用 generate 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:11434&#x2F;api&#x2F;generate -d &#39;&#123;</span><br><span class="line">  &quot;model&quot;: &quot;llama2-chinese&quot;,</span><br><span class="line">  &quot;prompt&quot;:&quot;你好，你是谁&quot;</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure><p>ollama rest api文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ollama&#x2F;ollama&#x2F;blob&#x2F;main&#x2F;docs&#x2F;api.md</span><br></pre></td></tr></table></figure><h1 id="Ollama-UI的使用"><a href="#Ollama-UI的使用" class="headerlink" title="Ollama UI的使用"></a>Ollama UI的使用</h1><p>使用 Ollama 创建好模型后，我们离创建一个聊天应用就差web界面了，下面是几个基于 ollama 的chat ui，有请兴趣的同学可以试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chatbot ollama：https:&#x2F;&#x2F;github.com&#x2F;ivanfioravanti&#x2F;chatbot-ollama</span><br><span class="line">open webui：https:&#x2F;&#x2F;github.com&#x2F;open-webui&#x2F;open-webui</span><br><span class="line">ollama ui：https:&#x2F;&#x2F;github.com&#x2F;ollama-webui&#x2F;ollama-webui-lite</span><br></pre></td></tr></table></figure><p>参考链接：</p><p>Ollama官网：<a href="https://ollama.com/" target="_blank" rel="noopener">https://ollama.com/</a></p><p>Ollama Github：<a href="https://github.com/ollama/ollama" target="_blank" rel="noopener">https://github.com/ollama/ollama</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ollama是一个开源工具，它能帮助我们在本地搭建和运行Llama2、Mistral、Gemma等开源LLM服务，方便我们构建自己的 LLM 应用。&lt;/p&gt;
&lt;p&gt;今天介绍下它的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>LangChain的基本使用</title>
    <link href="http://wyzane.gitee.io/blog/2024/02/22/LangChain%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2024/02/22/LangChain%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-22T03:46:53.000Z</published>
    <updated>2024-02-22T03:49:53.247Z</updated>
    
    <content type="html"><![CDATA[<p>LangChain 是一个开源框架，它的出现是为了简化和加速大语言模型相关应用的开发，比如开发基于OpenAI的应用，开发基于百度千帆大模型的应用。</p><a id="more"></a><p>那你可能会说，平时我们开发基于大模型的应用或者功能时，比如开发基于OpenAI的的应用时，我们都是直接调用OpenAI的chat接口或者assistants接口，并没有使用LangChain框架和它的接口。是的，平时我们开发时，可以直接调用相应大模型的接口，但当我们考虑到易用性、扩展性，使用LangChain是一个更好地选择，并且LangChain中还整合了很多组件和功能，包括：支持多种大语言模型、支持多种数据源连接、支持文本处理数据分析agent、提供部署和运维工具等。</p><p>下面基于Python和OpenAI介绍下LangChain的基本使用方式。</p><p>安装LangChain：pip install langchain</p><p>执行上面的命令后，会安装langchain、langchain-community、langchain-core等langchain相关的包。</p><p>安装openai：pip install openai</p><h1 id="创建一个llm"><a href="#创建一个llm" class="headerlink" title="创建一个llm"></a>创建一个llm</h1><p>安装好后，我们就可以使用LangChain就行开发了，先看一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个基于OpenAI的llm模块</span></span><br><span class="line">    llm = OpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>, max_tokens=<span class="number">10</span>, model_name=<span class="string">'gpt-3.5-turbo-instruct'</span>)</span><br><span class="line">    <span class="comment"># 调用模块的方法进行提问</span></span><br><span class="line">    resp = llm.predict(prompt)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt = <span class="string">'你是谁？'</span></span><br><span class="line">    resp = call(prompt)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure><p>上面的例子中，我们使用 OpenAI 创建了一个 llm 对象，创建 llm 对象时传入的参数和直接调用 OpneAI Chat 接口时传入的参数几乎是一样的，具体有哪些参数，可以查看Python源码或者 LangChain 文档。</p><p>对于上面的例子，我们也可以使用 langchain-openai 库来实现。</p><p>首先安装 langchain-openai：pip install langchain-openai</p><p>安装好后，使用 langchain-openai 开发：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">    llm = OpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    resp = llm.predict(prompt)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt = <span class="string">'你是谁？'</span></span><br><span class="line">    resp = call(prompt)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure><p>使用 langchain.llms 的 OpenAI 和 langchain_openai 的 OpenAI 输出的效果是一样的，通过查看源码可以发现，这两个类最终都是继承的 BaseLLM 类。</p><h1 id="创建一个chat-llm"><a href="#创建一个chat-llm" class="headerlink" title="创建一个chat llm"></a>创建一个chat llm</h1><p>在 langchain 中，chat消息有四种类型，分别是：AIMessage, HumanMessage, SystemMessage、ChatMessage，</p><p>其中，AIMessage是 llm 的消息，HumanMessage是用户输入的消息，SystemMessage是系统的消息，ChatMessage是自定义的消息。</p><p>我们使用 langchain.chat_models 中的 ChatOpenAI 创建一个 chat llm：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个基于Chat OpenAI的llm模块</span></span><br><span class="line">    llm = ChatOpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    resp = llm.predict(prompt)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt = <span class="string">'今天晚饭吃什么'</span></span><br><span class="line">    resp = call(prompt)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure><p>当然，也可以将上面的 langchain.chat_models 替换成 langchain_openai，效果是一样的。</p><p>创建chat llm后，除了简单的调用 predict() 聊天之外，还可以通过使用 HumanMessage、SystemMessage 进行聊天，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> HumanMessage, SystemMessage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">    llm = ChatOpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    system_msg = <span class="string">'你是一个非常有经验的高级厨师，请帮我推荐有益健康的菜谱！'</span></span><br><span class="line"></span><br><span class="line">    messages = [SystemMessage(content=system_msg), HumanMessage(content=prompt)]</span><br><span class="line">    resp = llm.predict_messages(messages)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt = <span class="string">'今天晚饭吃什么'</span></span><br><span class="line">    resp = call(prompt)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure><p>我们也可以通过 generate() 方法进行多组chat：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> HumanMessage, SystemMessage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt1=<span class="string">''</span>, prompt2=<span class="string">''</span>)</span>:</span></span><br><span class="line">    llm = ChatOpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    system_msg1 = <span class="string">'你是一个非常有经验的高级厨师，轻轻帮我推荐有益健康的菜谱！'</span></span><br><span class="line">    system_msg2 = <span class="string">'你是一个资深训练师，请给出如何保持身材的建议！'</span></span><br><span class="line"></span><br><span class="line">    batch_messages = [</span><br><span class="line">        [</span><br><span class="line">            SystemMessage(content=system_msg1),</span><br><span class="line">            HumanMessage(content=prompt1)</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            SystemMessage(content=system_msg2),</span><br><span class="line">            HumanMessage(content=prompt2)</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">    resp = llm.generate(batch_messages)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt1 = <span class="string">'今天晚饭吃什么'</span></span><br><span class="line">    prompt2 = <span class="string">'今天有什么锻炼计划'</span></span><br><span class="line">    resp = call(prompt1, prompt2)</span><br><span class="line">    print(resp.generations[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">"==================="</span>)</span><br><span class="line">    print(resp.generations[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h1 id="使用prompt模板"><a href="#使用prompt模板" class="headerlink" title="使用prompt模板"></a>使用prompt模板</h1><p>上面的几个例子中，都是使用的固定的prompt，如果我们想更加灵活的使用prompt，可以使用prompt模板，看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> LLMChain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(who)</span>:</span></span><br><span class="line">    llm = OpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个prompt模板</span></span><br><span class="line">    prompt = PromptTemplate.from_template(<span class="string">"如果&#123;who&#125;生气了，我该怎么哄她？"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个llm chain对象</span></span><br><span class="line">    chain = LLMChain(llm=llm, prompt=prompt)</span><br><span class="line">    <span class="comment"># 运行chain时，将prompt模板的参数传入</span></span><br><span class="line">    resp = chain.run(who=who)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    resp = call(<span class="string">"女朋友"</span>)</span><br><span class="line">    print(resp)</span><br><span class="line">    print(<span class="string">"========================="</span>)</span><br><span class="line">    resp = call(<span class="string">"小猫"</span>)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure><p>代码中使用 PromptTemplate 创建了一个 prompt 模板，通过使用 LLMChain 模块，将 prompt 和 llm 串联起来，最后执行并获取结果。</p><p>上面的例子中我们使用到了 LangChain中的 chain 模块：LLMChain。chain是 LangChain 中非常重要的一部分知识，通过使用 chain，我们将以模块化的方式调用大模型，即把 prompt 分成一个模块，调用 llm 分成一个模块，这两个模块之间互不影响，我们修改 prompt 时不会影响 llm，切换 llm 时也不会影响 prompt。chain 通过把调用大模型的过程切分成几个部分，降低了这几个部分之间的依赖关系，从而更加灵活，降低了后期更新和修改的成本。</p><p>LangChain中不只有 LLMChain，还有LLMRouterChain、LLMCheckerChain等，感兴趣的可以查看官方文档了解更多。</p><h1 id="创建一个ConversationChain"><a href="#创建一个ConversationChain" class="headerlink" title="创建一个ConversationChain"></a>创建一个ConversationChain</h1><p>在 LangChain 中，我们可以使用 ConversationChain 创建一个用于对话的应用。使用 ConversationChain 的好处在于，它会缓存聊天记录的上下文，使我们在对话时，大模型能够知道之前的聊天数据，从而给出更好地回答。下面看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> ConversationChain</span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line">llm = OpenAI(openai_api_key=OPENAI_API_KEY)</span><br><span class="line">conversion = ConversationChain(llm=llm)</span><br><span class="line">conversion.run(<span class="string">"你好呀"</span>)</span><br><span class="line">conversion.run(<span class="string">"我叫小明"</span>)</span><br><span class="line">conversion.run(<span class="string">"帮我写一份简历"</span>)</span><br><span class="line">conversion.run(<span class="string">"我是谁"</span>)</span><br></pre></td></tr></table></figure><p>代码中使用了 ConversationChain ，查看源码会发现，ConversationChain 中有一个 memory 参数，这个参数指定了聊天记录的缓存信息，使大模型能够知道之前对话的内容。memory 参数的默认值就是 ConversationBufferMemory。</p><p>我们可以使用下面的方式查看 memory 中缓存的所有内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(conversation.memory.load_memory_variables(&#123;&#125;))</span><br></pre></td></tr></table></figure><p>memory 除了使用 ConversationBufferMemory之外，还可以使用 ConversationBufferWindowMemory，它可以指定缓存最后 n 轮的对话内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> ConversationChain</span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferWindowMemory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个llm对象</span></span><br><span class="line">    llm = OpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 只缓存最近一轮的对话内容</span></span><br><span class="line">    memory = ConversationBufferWindowMemory(k=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 创建一个ConversationChain对象</span></span><br><span class="line">    conversation = ConversationChain(llm=llm, memory=memory)</span><br><span class="line">    <span class="comment"># 运行conversation chain</span></span><br><span class="line">    resp = conversation.run(<span class="string">"你好呀"</span>)</span><br><span class="line">    print(resp)</span><br><span class="line">    print(<span class="string">"==========="</span>)</span><br><span class="line">    resp = conversation.run(<span class="string">"我是小明"</span>)</span><br><span class="line">    print(resp)</span><br><span class="line">    print(<span class="string">"==========="</span>)</span><br><span class="line">    resp = conversation.run(<span class="string">"你能做什么"</span>)</span><br><span class="line">    print(resp)</span><br><span class="line">    print(<span class="string">"==========="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查看memory中的内容</span></span><br><span class="line">    print(conversation.memory.load_memory_variables(&#123;&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    call()</span><br></pre></td></tr></table></figure><p>以上就是本文介绍的 LangChain 的一些基本用法。</p><p>LangChain 官方文档：<a href="https://python.langchain.com/docs/get_started/introduction" target="_blank" rel="noopener">https://python.langchain.com/docs/get_started/introduction</a></p><p>LangChain GitHub仓库：<a href="https://github.com/langchain-ai/langchain" target="_blank" rel="noopener">https://github.com/langchain-ai/langchain</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LangChain 是一个开源框架，它的出现是为了简化和加速大语言模型相关应用的开发，比如开发基于OpenAI的应用，开发基于百度千帆大模型的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>通过cloudflare的tunnel技术实现内网穿透</title>
    <link href="http://wyzane.gitee.io/blog/2024/02/02/%E9%80%9A%E8%BF%87cloudflare%E7%9A%84tunnel%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://wyzane.gitee.io/blog/2024/02/02/%E9%80%9A%E8%BF%87cloudflare%E7%9A%84tunnel%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2024-02-02T06:25:31.000Z</published>
    <updated>2024-02-22T03:51:33.862Z</updated>
    
    <content type="html"><![CDATA[<p>cloudflare是一家提供一系列面向网站、应用程序和API的互联网安全性和性能增强服务的公司，它提供的服务主要包括内容分发网络（CDN）、分布式域名系统（DNS）服务、防御分布式拒绝服务（DDoS）攻击的解决方案和安全防护措施等。</p><a id="more"></a><p>我们在cloudflare上购买域名后，可以使用它的 tunnel 技术实现内网穿透，将我们的域名绑定到一个本地服务上。</p><p>下面分享一下操作步骤。</p><p>操作步骤（以windows为例）：</p><ol><li><p>安装 cloudflared（在官网或者github下载并安装，<a href="https://github.com/cloudflare/cloudflared/releases）" target="_blank" rel="noopener">https://github.com/cloudflare/cloudflared/releases）</a></p></li><li><p>执行以下命令，登录到cloudflare进行授权</p><p>cloudflared tunnel login<br>执行后会弹出一个页面，进行授权即可。授权完成后，会在 .cloudflare 目录下生成一个 cert.pem 文件</p></li><li><p>创建隧道 tunnel</p><p>cloudflared tunnel create &lt;隧道名字&gt;<br>创建完成后，会在 .cloudflare 目录中生成一个 uuid.json 的文件</p></li><li><p>把域名指向对应的隧道</p><p>cloudflared tunnel route dns &lt;隧道名字&gt; &lt;域名&gt;<br>完成后，cloudflare 会自动添加一条 CNAME 记录到对应的域名</p></li><li><p>配置 cloudflared</p><p>编辑文件 .\cloudflared\config.yml，添加如下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tunnel:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">credentials-file:</span> <span class="string">C:\Users\10579\.cloudflared\e9e54272-7145-485d-af9f-d620558d5c7a.json</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">blog.wangzan.net</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">service:</span> <span class="string">http_status:404</span></span><br></pre></td></tr></table></figure><p>配置完成后，可以测试一下文件是否正确：</p><p>cloudflared tunnel –config .\cloudflared\config.yml ingress validate</p><p>测试规则是否命中：</p><p>cloufdlared tunnel –config .\cloudflared\config.yml ingress rule <a href="http://wangzan.net" target="_blank" rel="noopener">http://wangzan.net</a></p></li><li><p>测试运行</p><p>.\cloudflared.exe –loglevel debug –transport-loglevel warn –config C:\Users\wyzane.cloudflared\config.yml tunnel run &lt;隧道UUID&gt;</p></li></ol><p>以上就是通过cloudflare配置内网穿透的步骤。</p><p>参考：</p><p><a href="https://blog.cloudflare.com/zh-cn/elevate-load-balancing-with-private-ips-and-cloudflare-tunnels-a-secure-path-to-efficient-traffic-distribution-zh-cn/" target="_blank" rel="noopener">https://blog.cloudflare.com/zh-cn/elevate-load-balancing-with-private-ips-and-cloudflare-tunnels-a-secure-path-to-efficient-traffic-distribution-zh-cn/</a></p><p><a href="https://bra.live/setup-home-server-with-cloudflare-tunnel/" target="_blank" rel="noopener">https://bra.live/setup-home-server-with-cloudflare-tunnel/</a></p><p><a href="https://github.com/anderspitman/awesome-tunneling" target="_blank" rel="noopener">https://github.com/anderspitman/awesome-tunneling</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cloudflare是一家提供一系列面向网站、应用程序和API的互联网安全性和性能增强服务的公司，它提供的服务主要包括内容分发网络（CDN）、分布式域名系统（DNS）服务、防御分布式拒绝服务（DDoS）攻击的解决方案和安全防护措施等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://wyzane.gitee.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://wyzane.gitee.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器之间免密登录的配置</title>
    <link href="http://wyzane.gitee.io/blog/2021/09/04/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://wyzane.gitee.io/blog/2021/09/04/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2021-09-04T08:34:49.000Z</published>
    <updated>2024-02-02T09:00:05.808Z</updated>
    
    <content type="html"><![CDATA[<p>下面的步骤中以 ubuntu1804 为例，介绍服务器之间配置免密登录的步骤。</p><a id="more"></a><p>三台服务器的 ip 为：192.168.0.101、192.168.0.103、192.168.0.104，配置使101可以在不需要密码（通过配置密钥）的情况下访问103和104。</p><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 三台服务器都安装 ssh 服务端和客户端</span><br><span class="line"></span><br><span class="line">2. 修改 103 和 104 服务器的 ssh 配置 &#x2F;etc&#x2F;ssh&#x2F;sshd_config，增加如下配置：</span><br><span class="line">PermitRootLogin yes  # 允许 root 用户通过 ssh 登录</span><br><span class="line">   修改完成保存后，重启 ssh 服务：service ssh restart</span><br><span class="line">   </span><br><span class="line">3. 在 101 上切换到 root 用户，然后执行：ssh-keygen -t rsa，执行后一路回车，生成公钥和私钥对</span><br><span class="line"></span><br><span class="line">4. 在 101 上执行：ssh-copy-id 192.168.0.103</span><br><span class="line">   输入 103 的 root 密码后（如果忘记 root 密码，可以使用 sudo passwd root 重新设置 root 密码），会出现如下信息：</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: Source of key(s) to be installed: &quot;&#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub&quot;</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@192.168.0.103&#39;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#39;192.168.0.103&#39;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br><span class="line">  </span><br><span class="line">   上面的信息表示，已经成功将 101 的公钥添加到了 103 服务器的 &#x2F;root&#x2F;.ssh&#x2F;authored_keys 文件中。</span><br><span class="line">   </span><br><span class="line">5. 执行: ssh 192.168.0.103 即可登录 103 服务器，也可以执行 scp file 192.168.0.103:&#x2F;home&#x2F;wyzane 将需要的文件拷贝到 103 服务器上</span><br><span class="line"></span><br><span class="line">6. 配置 104 服务器时， 重复执行步骤 4 即可。</span><br></pre></td></tr></table></figure><p>上面就是配置服务器之间免密登录的步骤，当我们在 101 服务器的 /etc/hosts 文件中添加如下配置后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.103  app-01</span><br><span class="line">192.168.0.104  app-02</span><br></pre></td></tr></table></figure><p>可以使用 ssh app-01 和 ssh app-02 之类的命令通过 DNS 解析来访问 103 和 104 服务器。</p><h2 id="ansible的使用"><a href="#ansible的使用" class="headerlink" title="ansible的使用"></a>ansible的使用</h2><p>如果有多台服务器需要配置密钥登录，可以使用Ansible进行批量配置。</p><p>Ansible 是一个开源的自动化平台，它用于配置管理、应用部署、任务自动执行等，下面介绍如何使用它进行批量密钥登录的配置。</p><p>假设我们有若干个员工，需要密钥登录多台服务器，那么就需要把多个员工的公钥上传到多台服务器上。</p><ol><li>首先创建一个hosts文件，文件中保存了服务器的信息：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[test]</span><br><span class="line">test_ip ansible_user&#x3D;test_user ansible_ssh_pass&#x3D;test_pass ansible_port&#x3D;22</span><br><span class="line"></span><br><span class="line">[preprod]</span><br><span class="line">preprod_ip ansible_user&#x3D;preprod_user ansible_ssh_pass&#x3D;preprod_pass ansible_port&#x3D;2000</span><br><span class="line"></span><br><span class="line">[prod]</span><br><span class="line">prod_ip ansible_user&#x3D;prod_user ansible_ssh_pass&#x3D;prod_pass ansible_port&#x3D;22</span><br><span class="line"></span><br><span class="line">[nginx]</span><br><span class="line">nginx_ip ansible_user&#x3D;nginx_user ansible_ssh_pass&#x3D;nginx_pass ansible_port&#x3D;22</span><br></pre></td></tr></table></figure><p>文件中，中括号的内容可以理解为服务器名称，这个名称在下面的文件中会用到，名称下面分别指定了对应的服务器ip、用户名、密码、端口信息。</p><ol start="2"><li>创建一个 Ansible playbook 配置文件 test.yml，用于保存需要执行的任务</li></ol><p>内容可以像下面这样：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">SSH</span> <span class="string">Keys</span>   <span class="comment"># 操作的名称</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">test:preprod</span>        <span class="comment"># 指定hosts文件中的哪些服务器执行这个操作</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span>                <span class="comment"># become表示是否使用特权提升，yes表示任务将以超级用户权限运行</span></span><br><span class="line">  <span class="attr">vars:</span>                      <span class="comment"># playbook运行时使用的变量</span></span><br><span class="line">    <span class="attr">ansible_become_pass:</span> <span class="string">"Dy18Zz@!@"</span>   <span class="comment"># 在提升权限时使用的密码</span></span><br><span class="line">  <span class="attr">tasks:</span>                               <span class="comment"># 这个操作中有哪些任务需要执行</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">authorized</span> <span class="string">key</span>         <span class="comment"># 任务名称，设置ssh授权密钥</span></span><br><span class="line">      <span class="attr">authorized_key:</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">lxtech</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('file', item) &#125;&#125;</span>"</span>    <span class="comment"># 使用了lookup从文件中读取密钥</span></span><br><span class="line">      <span class="attr">loop:</span>                                  <span class="comment"># 通过循环添加多个密钥文件，配置这些员工密钥登录test和preprod服务器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../pub/001.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../pub/002.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../pub/003.pub</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ensure</span> <span class="string">PubkeyAuthentication</span> <span class="string">is</span> <span class="string">enabled</span>   <span class="comment"># 任务名称，更新sshd_config文件，设置PubkeyAuthentication yes，允许密钥登录</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PubkeyAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PubkeyAuthentication yes'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Disable</span> <span class="string">Password</span> <span class="string">Authentication</span>   <span class="comment"># 禁止账号密码登录</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PasswordAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PasswordAuthentication no'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Disable</span> <span class="string">Root</span> <span class="string">SSH</span> <span class="string">Login</span>   <span class="comment"># 禁止使用root用户登录</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PermitRootLogin'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PermitRootLogin no'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">SSH</span> <span class="string">service</span>    <span class="comment"># 重启ssh服务</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">sshd</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">Nginx</span> <span class="string">SSH</span> <span class="string">Keys</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">nginx:prod</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">ansible_become_pass:</span> <span class="string">"!zE4s678g@"</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">authorized</span> <span class="string">key</span></span><br><span class="line">      <span class="attr">authorized_key:</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('file', item) &#125;&#125;</span>"</span></span><br><span class="line">      <span class="attr">loop:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/home/dytech/pkgs/ansible/pub/005.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/home/dytech/pkgs/ansible/pub/006.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/home/dytech/pkgs/ansible/pub/007.pub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ensure</span> <span class="string">PubkeyAuthentication</span> <span class="string">is</span> <span class="string">enabled</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PubkeyAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PubkeyAuthentication yes'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Disable</span> <span class="string">Password</span> <span class="string">Authentication</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PasswordAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PasswordAuthentication no'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">SSH</span> <span class="string">service</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">sshd</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p>配置完成后，执行命令 ansible-playbook -i hosts test.yml 批量执行任务就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面的步骤中以 ubuntu1804 为例，介绍服务器之间配置免密登录的步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://wyzane.gitee.io/blog/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://wyzane.gitee.io/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>jenkins的安装与简单使用</title>
    <link href="http://wyzane.gitee.io/blog/2021/08/24/jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2021/08/24/jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-24T14:09:49.000Z</published>
    <updated>2021-08-24T14:33:36.249Z</updated>
    
    <content type="html"><![CDATA[<p>jenkins是一个持续集成和自动化部署的工具，使用它可以快速方便的部署项目。下面介绍下 jenkins 的安装、git中央仓库的创建，及使用 jenkins 实现自动化部署。</p><a id="more"></a><p>以下例子中使用的服务器是 Ubuntu 18.04。</p><h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 去官网下载 jdk: jdk-8u251-linux-i586.tar.gz</span><br><span class="line">2. 解压并配置环境变量，在配置文件 &#x2F;etc&#x2F;profile 中加入以下内容（路径可根据自己情况更改）：</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib:$CLASSPATH</span><br><span class="line">export JAVA_PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JRE_HOME&#125;&#x2F;bin</span><br><span class="line">export PATH&#x3D;$PATH:$&#123;JAVA_PATH&#125;</span><br><span class="line">3. 执行 source &#x2F;etc&#x2F;profile，并执行 java 查看是否安装成功</span><br><span class="line">4. 安装成功后，配置软连接 ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java</span><br><span class="line">5. 安装 jenkins</span><br><span class="line">1) wget -q -O - https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian&#x2F;jenkins.io.key | sudo apt-key add -</span><br><span class="line">2) sudo sh -c &#39;echo deb http:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian-stable binary&#x2F; &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;jenkins.list&#39;</span><br><span class="line">3) sudo apt-get update</span><br><span class="line">4) sudo apt-get install jenkins</span><br><span class="line">6. 安装完成后，查看jenkins的状态，jenkins默认运行在8080端口（可以在 &#x2F;etc&#x2F;default&#x2F;jenkins文件中修改默认端口）</span><br><span class="line">service jenkins status</span><br><span class="line">service jenkins start</span><br><span class="line">service jenkins restart</span><br></pre></td></tr></table></figure><h2 id="git中央仓库的搭建"><a href="#git中央仓库的搭建" class="headerlink" title="git中央仓库的搭建"></a>git中央仓库的搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 安装 git</span><br><span class="line">sudo apt install git</span><br><span class="line">2. 添加 git 用户，添加时输入密码</span><br><span class="line">adduser git</span><br><span class="line">3. 服务器打开 RSA 验证： vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config，添加下面的配置</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile  .ssh&#x2F;authorized_keys</span><br><span class="line">4. 切换到git用户，</span><br><span class="line">1）创建目录：mkdir .ssh</span><br><span class="line">2）生成密钥对：ssh-keygen -t rsa -C &quot;12345678@qq.com&quot;</span><br><span class="line">5. 在 .ssh 目录下添加 authorized_keys 文件，并把客户端的公钥添加到文件中</span><br><span class="line">6. 创建一个裸仓库：git init --bare pro1.git</span><br><span class="line">7. 在客户端克隆仓库： git clone git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;pro1.git</span><br></pre></td></tr></table></figure><h2 id="使用jenkins实现自动化部署"><a href="#使用jenkins实现自动化部署" class="headerlink" title="使用jenkins实现自动化部署"></a>使用jenkins实现自动化部署</h2><p>实现功能：使用jenkins将代码从一台服务器拉取到另一台服务器上，并将代码移动到指定目录中。</p><p>上面步骤中创建的 git 中央仓库就是此次例子中的源代码仓库。</p><p>配置 jenkins 前，我们需要先修改 jenkins 的配置文件，以便使用 jenkins 用户执行 shell 脚本时不会出现权限问题。修改步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 修改配置文件 &#x2F;etc&#x2F;default&#x2F;jenkins，让 jenkins 以 root 用户执行脚本</span><br><span class="line">JENKINS_USER&#x3D;&quot;root&quot;</span><br><span class="line">JENKINS_GROUP&#x3D;&quot;root&quot;</span><br><span class="line"></span><br><span class="line">2. 修改 jenkins 相关目录的属性</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;lib&#x2F;jenkins</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;cache&#x2F;jenkins</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;log&#x2F;jenkins</span><br><span class="line"></span><br><span class="line">3. 重启 jenkins 服务: service jenkins restart</span><br><span class="line">重启后，可能会遇到以下几个问题：</span><br><span class="line">1）mesg: ttyname failed: Inappropriate ioctl for device</span><br><span class="line">处理：使用 root 用户修改文件 &#x2F;root&#x2F;.profile，将 mesg n || true 替换成 tty -s &amp;&amp; mesg n。</span><br><span class="line">2）daemon: fatal: refusing to execute unsafe program: &#x2F;usr&#x2F;bin&#x2F;java (&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin is group and world writable)</span><br><span class="line">处理：执行 chmod -R 755 &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin</span><br><span class="line"></span><br><span class="line">4. 执行以上步骤后，重启服务器和 jenkins 服务就行了，下面就能使用 jenkins 执行 shell 脚本了。</span><br></pre></td></tr></table></figure><p>启动 jenkins 服务后，访问 127.0.0.1:8080，输入密码后进入jenkins。配置步骤如下：</p><p>首先，在 Dashboard 上创建一个 Item，输入 Item 名称并选择 Freestyle project。</p><p><img src="new_item.png" alt="new_item"></p><p>选择好以后，点击 OK。进入 Item 后，主要配置以下两个部分。</p><p>然后，配置源代码的 git 地址，如下图：</p><p><img src="source_code_git.png" alt="source_code_git"></p><p>配置 git 地址前，需要先在 jenkins 用户下创建秘钥（命令：ssh-keygen -t rsa -C “<a href="mailto:12345678@qq.com">12345678@qq.com</a>“），然后将生成的公钥放入 192.168.0.104 git用户下的 authorized_keys 文件中，否则会报错提示没有权限。</p><p>然后，再配置构建时要执行的 shell 脚本，如下图：</p><p><img src="build_shell.png" alt="build_shell"></p><p>上面的 shell 脚本就一行，将远程服务器上 git 仓库的代码拉取后（test目录，默认情况下，jenkins 会把拉取的代码放到其 workspace 目录下），再将代码放到 /home/wyzane/GitProject 目录下。</p><p>上图的 shell 脚本很简单，若需要执行其他的一些部署、重启服务等命令，可以再根据需要添加。</p><p>最后，可以保存并 Build 一下 Item，上面例子中控制台的输出日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Started by user wyzane</span><br><span class="line">Running as SYSTEM</span><br><span class="line">Building in workspace &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;test</span><br><span class="line">[WS-CLEANUP] Deleting project workspace...</span><br><span class="line">[WS-CLEANUP] Deferred wipeout is used...</span><br><span class="line">The recommended git tool is: NONE</span><br><span class="line">No credentials specified</span><br><span class="line">Cloning the remote Git repository</span><br><span class="line">Cloning repository git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git</span><br><span class="line"> &gt; git init &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;test # timeout&#x3D;10</span><br><span class="line">Fetching upstream changes from git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git</span><br><span class="line"> &gt; git --version # timeout&#x3D;10</span><br><span class="line"> &gt; git --version # &#39;git version 2.17.1&#39;</span><br><span class="line"> &gt; git fetch --tags --progress -- git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;* # timeout&#x3D;10</span><br><span class="line"> &gt; git config remote.origin.url git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git # timeout&#x3D;10</span><br><span class="line"> &gt; git config --add remote.origin.fetch +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;* # timeout&#x3D;10</span><br><span class="line">Avoid second fetch</span><br><span class="line"> &gt; git rev-parse refs&#x2F;remotes&#x2F;origin&#x2F;master^&#123;commit&#125; # timeout&#x3D;10</span><br><span class="line">Checking out Revision 8d114db052b5c4914e56a1e5848a2c5df9bca69e (refs&#x2F;remotes&#x2F;origin&#x2F;master)</span><br><span class="line"> &gt; git config core.sparsecheckout # timeout&#x3D;10</span><br><span class="line"> &gt; git checkout -f 8d114db052b5c4914e56a1e5848a2c5df9bca69e # timeout&#x3D;10</span><br><span class="line">Commit message: &quot;add test03&quot;</span><br><span class="line"> &gt; git rev-list --no-walk 8d114db052b5c4914e56a1e5848a2c5df9bca69e # timeout&#x3D;10</span><br><span class="line">[test] $ &#x2F;bin&#x2F;sh -xe &#x2F;tmp&#x2F;jenkins7411340475787087463.sh</span><br><span class="line">+ cp -r &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;test &#x2F;home&#x2F;wyzane&#x2F;GitProject</span><br><span class="line">Finished: SUCCESS</span><br></pre></td></tr></table></figure><p>jenkins 中还有很多其他配置项和插件，在后面还会整理一部分它们的使用方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jenkins是一个持续集成和自动化部署的工具，使用它可以快速方便的部署项目。下面介绍下 jenkins 的安装、git中央仓库的创建，及使用 jenkins 实现自动化部署。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>提高文本查询效率的几个命令</title>
    <link href="http://wyzane.gitee.io/blog/2021/05/22/%E6%8F%90%E9%AB%98%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/"/>
    <id>http://wyzane.gitee.io/blog/2021/05/22/%E6%8F%90%E9%AB%98%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/</id>
    <published>2021-05-22T13:15:54.000Z</published>
    <updated>2021-05-25T13:51:56.199Z</updated>
    
    <content type="html"><![CDATA[<p> 查找日志定位问题时，往往被查询的日志可能是一个很大的文件或者是压缩文件，查找时为了提高效率，我们可以使用 more、zgrep 等命令来查找。</p><a id="more"></a><h1 id="more"><a href="#more" class="headerlink" title="more"></a>more</h1><p>more 命令与 cat 命令类似，但是查找文件时，more 是一页一页的显示，这样更方便我们查找。</p><p>我们执行 more –help ，可以看看 more 有哪些参数可以使用。</p><p>more 的基本用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 空格键：往下显示一页</span><br><span class="line">2. b键：往上显示一页</span><br><span class="line">3. more +n：从第n行开始显示</span><br><span class="line">4. more -n: 自定义每页显示行数</span><br><span class="line">5. &#x2F;待查找字符串：查找特定的字符串</span><br><span class="line">6. q：退出more命令</span><br><span class="line"></span><br><span class="line">还可以使用 more --help 查看更多参数。</span><br></pre></td></tr></table></figure><h1 id="zgrep"><a href="#zgrep" class="headerlink" title="zgrep"></a>zgrep</h1><p>zgrep 命令与 grep 命令功能一样，只不过 zgrep 可以用来查找压缩文件中的特定内容而不用将文件解压，这对于查询大压缩文件的查找很有帮助。</p><p>zgrep 的基本用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. zgrep 待查找内容 压缩文件（若查找的是二进制文件，需要加上参数 -a，下同）</span><br><span class="line">2. zgrep -A n 待查找内容 压缩文件 （获取待查找内容的后面 n 行内容）</span><br><span class="line">3. zgrep -B n 待查找内容 压缩文件 （获取待查找内容的前面 n 行内容）</span><br><span class="line">4. zgrep -C n 待查找内容 压缩文件 （获取待查找内容的前后 n 行内容）</span><br></pre></td></tr></table></figure><p>类似的命令还有 zmore、zcat 等，感兴趣的同学可以下去学习一下。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>less  命令与 more 命令类似，但是功能比 more 更强大，它的基本用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">less用法：</span><br><span class="line">1. less 文件名 查找指定的文件</span><br><span class="line">常用参数：</span><br><span class="line"> -i：搜索时忽略大小写</span><br><span class="line"> -m：增加百分比的显示</span><br><span class="line"> -s：合并连续空行为一行</span><br><span class="line"> -N：显示行号</span><br><span class="line">2. d 向下翻页</span><br><span class="line">3. u 向上翻页</span><br><span class="line">4. g 跳到第一行</span><br><span class="line">5. G 跳到最后一行</span><br><span class="line">6. &#x2F;字符串：向下搜索字符串</span><br><span class="line">7. ?字符串：向上搜索字符串</span><br></pre></td></tr></table></figure><p>less 的更多用法，可以执行 less –help 查看。</p><p>以上就是文本查找中可能常用到的几个查找命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 查找日志定位问题时，往往被查询的日志可能是一个很大的文件或者是压缩文件，查找时为了提高效率，我们可以使用 more、zgrep 等命令来查找。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://wyzane.gitee.io/blog/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://wyzane.gitee.io/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵模式的配置与使用</title>
    <link href="http://wyzane.gitee.io/blog/2021/05/19/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2021/05/19/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-19T14:23:08.000Z</published>
    <updated>2021-05-22T12:57:46.219Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍下 Redis 哨兵模式的配置与使用方法。</p><p>在 Redis 中，哨兵是一个独立的进程，它用来监控 Redis 集群中中主从服务器的运行状态，当发现 Redis 主服务器宕机后，哨兵会从集群剩下服务器中重新选择一个主服务器，从而保证集群的正常运行，即保证 Redis 集群的高可用性。</p><a id="more"></a><p>以下例子中使用的 Redis 版本均为 6.0。</p><h1 id="哨兵模式的配置"><a href="#哨兵模式的配置" class="headerlink" title="哨兵模式的配置"></a>哨兵模式的配置</h1><p>以搭建三个哨兵为例，Redis 哨兵模式的配置步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 首先，进入 Redis 所在目录，复制三份 sentinel.conf 文件，分别命名为 sentinel01.conf、sentinel02.conf、sentinel03.conf</span><br><span class="line"></span><br><span class="line">2. 配置 sentinel01.conf 文件的如下内容：</span><br><span class="line">sentinel monitor mymaster 192.168.172.130 6379 2</span><br><span class="line"># 监控名为 mymaster 的主服务器，主服务器ip和端口为192.168.172.130，6379，当至少有两个sentinel同意时，该主服务器才会被判定为失效</span><br><span class="line"></span><br><span class="line">sentinel auth-pass mymaster &quot;wyzane&quot;</span><br><span class="line"># 设置连接主服务器的密码</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds mymaster 10000</span><br><span class="line"># 如果服务器在给定的毫秒数之内，没有返回 Sentinel 发送的 PING 命令的回复，或者返回一个错误，那么 Sentinel 将这个服务器标记为主观下线（subjectively down，简称 SDOWN ）。</span><br><span class="line"></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"># 指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步，这个数字越小，完成故障转移所需的时间就越长。</span><br><span class="line"></span><br><span class="line">3. 对 sentinel02.conf 和 sentinel03.conf 进行同样的配置</span><br></pre></td></tr></table></figure><p>配置完成后，使用以下方式启动哨兵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方式一，分别执行以下命令：</span><br><span class="line">redis-sentinel sentinel01.conf</span><br><span class="line">redis-sentinel sentinel02.conf</span><br><span class="line">redis-sentinel sentinel03.conf</span><br><span class="line">方式二，分别执行以下命令：</span><br><span class="line">redis-server sentinel01.conf --sentinel</span><br><span class="line">redis-server sentinel02.conf --sentinel</span><br><span class="line">redis-server sentinel03.conf --sentinel</span><br></pre></td></tr></table></figure><p>以上就是 Redis 哨兵的配置和启动，下面介绍下 Redis 哨兵模式的工作原理。</p><h1 id="哨兵模式的原理"><a href="#哨兵模式的原理" class="headerlink" title="哨兵模式的原理"></a>哨兵模式的原理</h1><p>哨兵模式运行的大致流程如下：</p><p>当 Redis 集群和 Redis 哨兵启动后，哨兵通过向主服务器和从服务器发送命令，来获取主、从服务器的运行状态，参数 sentinel down-after-milliseconds 用来控制，主、从服务器收到命令后返回响应的时间。如果在给定时间内，哨兵没有收到服务器发回的响应信息，那么该哨兵就将对应的服务器标记为主观下线状态(subjectively down，简称 SDOWN ），当有多个（一般是半数以上）哨兵都把该服务器标记为主观下线状态时，那么该服务器就被标记为客观下线（objectively down， 简称 ODOWN），此时才会发生故障迁移操作。</p><p>Redis 的 Sentinel 中关于下线（down）有两个不同的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</span><br><span class="line">2. 客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</span><br></pre></td></tr></table></figure><p>下面，我们来搭建一个含有一主两从的 Redis 集群，并配置三个哨兵，看一下哨兵是怎么运行的。</p><p>Redis 主从的配置就不多做介绍了，下面直接看启动后的日志信息。</p><p>Redis 主从信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主：192.168.172.131 6380</span><br><span class="line">从：192.168.172.131 6381</span><br><span class="line">从：192.168.172.131 6382</span><br></pre></td></tr></table></figure><p>启动 192.168.172.131 6380 和 192.168.172.131 6381 后，主服务器的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">16243:M 22 May 2021 00:56:23.056 * Replica 192.168.172.131:6381 asks for synchronization</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Full resync requested by replica 192.168.172.131:6381</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Replication backlog created, my new replication IDs are &#39;b643fa0d90a895b29c82b71446167e6b60d52283&#39; and &#39;0000000000000000000000000000000000000000&#39;</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Background saving started by pid 16254</span><br><span class="line">16254:C 22 May 2021 00:56:23.058 * DB saved on disk</span><br><span class="line">16254:C 22 May 2021 00:56:23.059 * RDB: 0 MB of memory used by copy-on-write</span><br><span class="line">16243:M 22 May 2021 00:56:23.095 * Background saving terminated with success</span><br><span class="line">16243:M 22 May 2021 00:56:23.097 * Synchronization with replica 192.168.172.131:6381 succeeded</span><br></pre></td></tr></table></figure><p>192.168.172.131 6381 服务器的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">16249:S 22 May 2021 00:56:23.054 * Master replied to PING, replication can continue...</span><br><span class="line">16249:S 22 May 2021 00:56:23.055 * Partial resynchronization not possible (no cached master)</span><br><span class="line">16249:S 22 May 2021 00:56:23.057 * Full resync from master: b643fa0d90a895b29c82b71446167e6b60d52283:0</span><br><span class="line">16249:S 22 May 2021 00:56:23.096 * MASTER &lt;-&gt; REPLICA sync: receiving 680 bytes from master to disk</span><br><span class="line">16249:S 22 May 2021 00:56:23.096 * MASTER &lt;-&gt; REPLICA sync: Flushing old data</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * Loading RDB produced by version 6.0.6</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * RDB age 0 seconds</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * RDB memory usage when created 1.83 Mb</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * MASTER &lt;-&gt; REPLICA sync: Finished with success</span><br></pre></td></tr></table></figure><p>上面的过程表示，从服务器连接上主服务器后，进行了数据的全量同步。同样的，启动 192.168.172.131 6382 后，数据也会进行全量同步。</p><p>下面再启动 Redis 哨兵。</p><p>执行 redis-sentinel sentinel.conf 后，哨兵服务器的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16392:X 22 May 2021 01:13:36.020 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.</span><br><span class="line">16392:X 22 May 2021 01:13:36.020 # Sentinel ID is 8fd93d8d9547434177903ba11cb5ae0bf603f358</span><br><span class="line">16392:X 22 May 2021 01:13:36.020 # +monitor master mymaster 192.168.172.131 6380 quorum 2</span><br><span class="line">16392:X 22 May 2021 01:13:36.022 * +slave slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380</span><br><span class="line">16392:X 22 May 2021 01:13:36.024 * +slave slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380</span><br></pre></td></tr></table></figure><p>若将主服务器的进程关掉，则哨兵的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">16481:X 22 May 2021 01:24:02.032 # +sdown master mymaster 192.168.172.131 6380（当前哨兵认为主服务器宕机，主观下线）</span><br><span class="line">16481:X 22 May 2021 01:24:02.093 # +odown master mymaster 192.168.172.131 6380 （有三个哨兵认为主服务器宕机，超过了两个，客观下线）#quorum 3&#x2F;2</span><br><span class="line">16481:X 22 May 2021 01:24:02.093 # +new-epoch 9（递增的集群版本号）</span><br><span class="line">16481:X 22 May 2021 01:24:02.093 # +try-failover master mymaster 192.168.172.131 6380（开始尝试对集群进行故障迁移）</span><br><span class="line">16481:X 22 May 2021 01:24:02.097 # +vote-for-leader 12e1af953d931b8ac097876d7bdf803ba39c52f6 9（选出一个哨兵，作为故障迁移的leader，当前哨兵，投票给 Sentinel ID 为 12e1af953d931b8ac097876d7bdf803ba39c52f6 的哨兵）</span><br><span class="line">16481:X 22 May 2021 01:24:02.103 # 2c2c810af7936fba2facbeb159b0f7fa1e87d325 voted for 2c2c810af7936fba2facbeb159b0f7fa1e87d325 9（其它哨兵投票）</span><br><span class="line">16481:X 22 May 2021 01:24:02.106 # 8fd93d8d9547434177903ba11cb5ae0bf603f358 voted for 12e1af953d931b8ac097876d7bdf803ba39c52f6 9（其它哨兵投票）</span><br><span class="line">16481:X 22 May 2021 01:24:02.187 # +elected-leader master mymaster 192.168.172.131 6380（当前的主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.188 # +failover-state-select-slave master mymaster 192.168.172.131 6380（分析从节点的状态）</span><br><span class="line">16481:X 22 May 2021 01:24:02.265 # +selected-slave slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（选出一个从节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.265 * +failover-state-send-slaveof-noone slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（将上面选出的从节点与现在的主节点进行主从切换）</span><br><span class="line">16481:X 22 May 2021 01:24:02.355 * +failover-state-wait-promotion slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（等待从节点升级成主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.531 # +promoted-slave slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（从节点已经升级为主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.532 # +failover-state-reconf-slaves master mymaster 192.168.172.131 6380（修改原来主节点的配置文件）</span><br><span class="line">16481:X 22 May 2021 01:24:02.586 * +slave-reconf-sent slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380（重写从节点的配置文件，即为从节点配置新的主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:03.229 # -odown master mymaster 192.168.172.131 6380</span><br><span class="line">16481:X 22 May 2021 01:24:03.565 * +slave-reconf-inprog slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380（从节点正在重新指向为新的主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:03.565 * +slave-reconf-done slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380（从节点配置完毕）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 # +failover-end master mymaster 192.168.172.131 6380（故障迁移结束）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 # +switch-master mymaster 192.168.172.131 6380 192.168.172.131 6382（故障迁移成功，哨兵开始监控新的主服务器）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 * +slave slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6382（确认新主节点的从节点）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 * +slave slave 192.168.172.131:6380 192.168.172.131 6380 @ mymaster 192.168.172.131 6382（确认新主节点的从节点）</span><br><span class="line">16481:X 22 May 2021 01:24:08.662 # +sdown slave 192.168.172.131:6380 192.168.172.131 6380 @ mymaster 192.168.172.131 6382（原主节点变为slave节点并且主观下线）</span><br></pre></td></tr></table></figure><p>上面的日志是哨兵发现主服务器宕机后，故障恢复的的一个过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天介绍下 Redis 哨兵模式的配置与使用方法。&lt;/p&gt;
&lt;p&gt;在 Redis 中，哨兵是一个独立的进程，它用来监控 Redis 集群中中主从服务器的运行状态，当发现 Redis 主服务器宕机后，哨兵会从集群剩下服务器中重新选择一个主服务器，从而保证集群的正常运行，即保证 Redis 集群的高可用性。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://wyzane.gitee.io/blog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Python3中生成器和协程的使用</title>
    <link href="http://wyzane.gitee.io/blog/2020/09/13/Python3%E4%B8%AD%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2020/09/13/Python3%E4%B8%AD%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-09-13T13:24:11.000Z</published>
    <updated>2024-02-25T03:03:54.810Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理下 Python3 中生成器和协程的使用。</p><a id="more"></a><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><h2 id="生成器输出数据"><a href="#生成器输出数据" class="headerlink" title="生成器输出数据"></a>生成器输出数据</h2><p>python 中可以使用 yield 关键字实现生成器，简单点说就是：一个函数中，如果包含 yield 关键字，那么这个函数就是一个生成器。下面看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""生成器：yield的使用</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    print(<span class="string">"=======start======="</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"=====flag:"</span>, flag)</span><br><span class="line">        flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">"========end========="</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""调用生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    t = test()</span><br><span class="line">    print(t)</span><br><span class="line">    print(next(t))</span><br><span class="line">    print(next(t))</span><br><span class="line">    print(next(t))</span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上面代码的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object test at 0x000001726581C2B0&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flag: 0</span><br><span class="line">0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flag: 1</span><br><span class="line">1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flag: 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>从上面的输出结果中可以看出，每次调用next()，都会从上一次结束的地方执行。 相当于遇到 yield 时，会跳出当前代码的执行，再次调用next()时，会从上一次跳出的地方开始执行 (即print(“========end=========”)这行代码试下一次执行的开始)。调用生成器时可以使用 next() 函数，也可以使用生成器的 <code>__next__</code>() 方法来获取值。</p><h2 id="生成器接收外部数据"><a href="#生成器接收外部数据" class="headerlink" title="生成器接收外部数据"></a>生成器接收外部数据</h2><p>在生成器中，yield 还可以接收外部传进来的值，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""生成器：yield接收外部传入的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        x = <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">"=====x:"</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"OK"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t = test()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 第一次调用生成器的send()方法时，传入一个None值，用于启动生成器。</span></span><br><span class="line">        <span class="comment"># 调用 send()，相当于调用 next()，执行到 yield 时，会返回 yield 后面的值</span></span><br><span class="line">        ret = t.send(<span class="literal">None</span>)</span><br><span class="line">        print(<span class="string">"=====ret1:"</span>, ret)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二次调用 send() 时，执行到 x = yield i 部分，相当于 x 接收到了通过 send() 传入的值</span></span><br><span class="line">        ret = t.send(<span class="number">9</span>)</span><br><span class="line">        print(<span class="string">"=====ret2:"</span>, ret)</span><br><span class="line"></span><br><span class="line">        ret = t.send(<span class="number">8</span>)</span><br><span class="line">        print(<span class="string">"=====ret3:"</span>, ret)</span><br><span class="line"></span><br><span class="line">        ret = t.send(<span class="number">7</span>)</span><br><span class="line">        print(<span class="string">"=====ret4:"</span>, ret)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exp:</span><br><span class="line">        print(<span class="string">"=====value:"</span>, exp.value)</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上面代码的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ret1: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;x: 9</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ret2: 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;x: 8</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;value: OK</span><br></pre></td></tr></table></figure><p>当生成器中 yield 后没有值返回时，再调用 send() 或者 next() 会抛出 StopIteration 异常，所以我们需要捕获该异常。若生成器中有返回值，可以在捕获异常时获取它。</p><h2 id="使用for循环遍历生成器"><a href="#使用for循环遍历生成器" class="headerlink" title="使用for循环遍历生成器"></a>使用for循环遍历生成器</h2><p>生成器中的值也可以通过 for 循环获取，类似于调用 next() 方法，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""使用 for 循环调用生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    t = test()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">        print(i)</span><br><span class="line">          </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>协程，更像是一个过程，类似线程和进程，协程是由调用方来控制程序执行和切换的过程。python 中的协程是由生成器转化而来，即通过扩展生成器的功能来实现协程。</p><p>python中，生成器和协程一样，都是使用了 yield 关键字的函数，但是通常来说，生成器仅仅是向外部输出数据，并将代码的执行交给调用方，协程不仅可以向外部输出数据，还能通过 send() 方法接收外部传进来的数据，即 yield data 和 x = yield data。yield 类似于一种控制流程的方式。</p><h1 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h1><p>一个含有 yield from 的方法也是一个生成器，与 yield 不同的是，yield from 后面如果跟一个生成器，那么可以直接调用这个生成器，而不再需要 next() 函数。yield from 后面也可一跟一个可迭代对象，此时相比于 for 循环加 yield 输出数据要方便。例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test01</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""yield from 后面可以跟一个可迭代对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test02</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""yield from 后面跟一个生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"=====start====="</span>)</span><br><span class="line">    ret = <span class="keyword">yield</span> <span class="keyword">from</span> test01()</span><br><span class="line">    <span class="comment"># 还可以获取子生成器的值</span></span><br><span class="line">    print(<span class="string">"=====ret:"</span>, ret)</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t = test02()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">"=====t1:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t2:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t3:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t4:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t5:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t6:"</span>, next(t))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上面代码的输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t1: 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t2: 2</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t3: 3</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t4: 4</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t5: 5</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ret: ok</span><br></pre></td></tr></table></figure><p>可以看出，生成器 test02() 里面嵌套了一个生成器 test01()。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天整理下 Python3 中生成器和协程的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="python" scheme="http://wyzane.gitee.io/blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>openrestry的安装</title>
    <link href="http://wyzane.gitee.io/blog/2020/08/30/openresty%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://wyzane.gitee.io/blog/2020/08/30/openresty%E7%9A%84%E5%AE%89%E8%A3%85/</id>
    <published>2020-08-30T01:18:00.000Z</published>
    <updated>2020-09-06T07:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>OpenResty 是一个基于 Nginx 的可伸缩的 Web 平台，提供了很多高质量的第三方模块；它也是一个强大的 Web 应用服务器，开发人员可以使用 Lua 脚本语言调用 Nginx 支持的各种 C 以及 Lua 模块。</p><p>今天介绍下 OpenResty 在 Ubuntu 1804 上的安装。</p><a id="more"></a><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>安装依赖时，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libpcre3-dev libssl-dev perl make build-essential curl</span><br></pre></td></tr></table></figure><p>需要注意的是，执行上面的命令时，可能会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E: py3compile:243: Requested versions are not installed</span><br></pre></td></tr></table></figure><p>这是因为我们安装的 python3 版本与 py3compile 不一致引起的，py3compile 是属于 python3-minimal 的，我们只需要安装对应的 python3-minimal 即可。python3-minimal 的下载地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mirrors.edge.kernel.org&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;p&#x2F;python3-defaults&#x2F;</span><br></pre></td></tr></table></figure><p>下载完成后，执行以下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i python3-minimal_3.6.7-1~18.04_amd64.deb</span><br></pre></td></tr></table></figure><p>安装 python3-minimal 可能还会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#x2F;python3-minimal.postinst: py3compile: not found</span><br></pre></td></tr></table></figure><p>这是因为安装过程中，python3-minimal 会寻找 python3.6（根据安装版本不同而不同），我的系统中 /usr/bin 下只有python3，这时候添加一个 python3.6 的软链接即可。</p><h1 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h1><p>依赖安装完成后，可以到以下地址下载相应版本的 OpenResty ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;openresty.org&#x2F;cn&#x2F;download.html</span><br></pre></td></tr></table></figure><p>下载完成后，解压缩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf openresty-1.17.8.2.tar.gz</span><br></pre></td></tr></table></figure><p>执行配置及安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty --with-luajit</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>命令执行完成后，在 /usr/local 下会生成一个 openrestry 目录，里面就行 openrestry 的一些源码文件、配置文件和可执行文件。</p><p>其它系统的安装步骤可以参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;openresty.org&#x2F;cn&#x2F;installation.html</span><br></pre></td></tr></table></figure><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="hello-world的例子"><a href="#hello-world的例子" class="headerlink" title="hello world的例子"></a>hello world的例子</h2><p>我们可以在 /usr/local/openresty 目录下新建一个文件 conf/openrestry.conf 配置文件，文件内容如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">error_log</span> logs/error.log;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">                ngx.say("&lt;p&gt;hello, world&lt;/p&gt;")</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动 openrestry 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;conf&#x2F;openrestry.conf</span><br></pre></td></tr></table></figure><p>执行命令，请求 openrestry 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:8080&#x2F;</span><br></pre></td></tr></table></figure><p>请求后，会返回下面的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;hello, world&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h2 id="接收请求参数"><a href="#接收请求参数" class="headerlink" title="接收请求参数"></a>接收请求参数</h2><p>openresty 中接收客户端请求参数的配置为：</p><p>conf/params.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">                local params = ngx.req.get_uri_args();</span></span><br><span class="line"><span class="string">                ngx.print(params.name);</span></span><br><span class="line"><span class="string">                ngx.print(params.age);</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端请求 <a href="http://localhost:8080/test/?name=aaa&amp;age=12" target="_blank" rel="noopener">http://localhost:8080/test/?name=aaa&amp;age=12</a> 时，返回的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaa12</span><br></pre></td></tr></table></figure><p>ngx.req.get_uri_args 的用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args, err &#x3D; ngx.req.get_uri_args()，用于获取客户端请求 uri 中的参数。</span><br><span class="line"></span><br><span class="line">它的说明文档为：https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;lua-nginx-module#ngxreqget_uri_args</span><br></pre></td></tr></table></figure><p>其中，ngx.print() 函数的功能是将参数作为响应体返回给调用的客户端，未返回响应头时，首先返回响应头，再返回响应体。</p><p>还有一个 ngx.say() 方法，它与 ngx.print() 方法的功能一样，但是 ngx.say() 最后会返回一个换行符。</p><p>上面的方法 ngx.req.get_uri_args() 是接收 get 请求的参数，接收 post 请求参数的配置为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">                ngx.req.read_body();</span><br><span class="line">                <span class="attribute">local</span> params = ngx.req.get_post_args();</span><br><span class="line">                ngx.say(params.name);</span><br><span class="line">                ngx.say(params.age);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:8080&#x2F;test -X POST -d &#39;name&#x3D;aaa&amp;age&#x3D;12&#39;</span><br></pre></td></tr></table></figure><p>得到的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>接收 post 请求使用的是 ngx.req.get_post_args()。，在使用该方法之前，需要调用方法：ngx.req.read_body()。ngx.req.read_body() 的作用是：在不阻塞 nginx event loop 的请求下，异步读取客户端的请求体数据。</p><h2 id="内部调用"><a href="#内部调用" class="headerlink" title="内部调用"></a>内部调用</h2><p>在 openresty 中，可以进行内部 location 之间的调用，配置例子如下：</p><p>conf/inner.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">                local res = ngx.location.capture(</span></span><br><span class="line"><span class="string">                    "/getname", &#123;args=&#123;name=ngx.var["arg_name"], age=18&#125;&#125;</span></span><br><span class="line"><span class="string">                )</span></span><br><span class="line"><span class="string">                ngx.say(ngx.var["arg_name"]);</span></span><br><span class="line"><span class="string">                ngx.say("status:", res.status, " resp:", res.body)</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /getname &#123;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">                local params = ngx.req.get_uri_args();</span></span><br><span class="line"><span class="string">                ngx.print(params.name);</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，当访问 <a href="http://localhost:8080/test/?name=xxx" target="_blank" rel="noopener">http://localhost:8080/test/?name=xxx</a> 时，会打印出以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br><span class="line">status:200 resp:aaa</span><br></pre></td></tr></table></figure><p>配置文件中，ngx.location.capture 的作用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">功能：在 nginx 内部调用其它 location 块</span><br><span class="line">语法：res &#x3D; ngx.location.capture(uri, options)</span><br><span class="line">上面的配置文件中，它的作用域是 content_by_lua 开头的模块</span><br><span class="line"></span><br><span class="line">ngx.location.capture 会返回一个 lua table 对象，有以下4个属性：res.status, res.header, res.body, and res.truncated</span><br><span class="line"></span><br><span class="line">ngx.location.capture 的说明文档为：https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;lua-nginx-module#ngxlocationcapture</span><br></pre></td></tr></table></figure><h2 id="指定lua脚本文件"><a href="#指定lua脚本文件" class="headerlink" title="指定lua脚本文件"></a>指定lua脚本文件</h2><p>在 openresty 的 location 中，可以指定 lua 脚本来执行，配置例子为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> = /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">content_by_lua_file</span> /usr/local/openresty/lua_code/test.lua;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，使用 content_by_lua_file 来指定请求进来时需要运行的 lua 脚本文件。</p><p>test.lua 的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(&quot;lua test file&quot;);</span><br></pre></td></tr></table></figure><p>在终端执行  curl <a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a> 后，会返回 lua test file。</p><h2 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis"></a>连接redis</h2><p>openresty 中通过 lua 连接 redis 的例子如下：redis.lua：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-- redis use</span><br><span class="line"></span><br><span class="line">local resty_redis &#x3D; require(&#39;resty.redis&#39;)</span><br><span class="line">local redis &#x3D; resty_redis:new()</span><br><span class="line"></span><br><span class="line">redis:settimeout(1000)</span><br><span class="line"></span><br><span class="line">local ok, err &#x3D; redis:connect(&#39;127.0.0.1&#39;, 6379)</span><br><span class="line">if not ok then</span><br><span class="line">        ngx.say(err)</span><br><span class="line">        ngx.eof()</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 连接 redis 后进行密码验证</span><br><span class="line">local res, err &#x3D; redis:auth(&#39;wyzane&#39;)</span><br><span class="line">if not res then</span><br><span class="line">        ngx.say(&quot;failed to auth:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local res, err &#x3D; redis:get(&quot;name&quot;)</span><br><span class="line">if not res then</span><br><span class="line">        ngx.say(&quot;failed to get name:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ngx.say(res)</span><br><span class="line"></span><br><span class="line">local ok, err &#x3D; redis:set_keepalive(10000, 100)</span><br><span class="line">if not ok then</span><br><span class="line">        ngx.say(&quot;failed to set keeplive:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>redis.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line"></span><br><span class="line">        location &#x3D; &#x2F;test &#123;</span><br><span class="line">            default_type text&#x2F;html;</span><br><span class="line"></span><br><span class="line">            content_by_lua_file &#x2F;home&#x2F;wyzane&#x2F;lua_code&#x2F;redis.lua;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h2><p>openresty 中使用 lua 连接 mysql 的例子如下：mysql.lua：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql use</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> resty_mysql = <span class="built_in">require</span>(<span class="string">"resty.mysql"</span>)</span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">"cjson"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> db, err = resty_mysql:new()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> db <span class="keyword">then</span></span><br><span class="line">        ngx.say(<span class="string">'init mysql failed'</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">db:set_timeout(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ok, err, errcode, sqlstate = db:connect(&#123;</span><br><span class="line">    host = <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    post = <span class="number">3306</span>,</span><br><span class="line">    database = <span class="string">"test_koa"</span>,</span><br><span class="line">    user = <span class="string">"root"</span>,</span><br><span class="line">    password = <span class="string">"wyzane"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.say(<span class="string">"failed to connect mysql:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res, err, errcode, sqlstate = db:query(<span class="string">"select * from tb_user"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">        nga.say(<span class="string">"query failed:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">db:set_keepalive(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">ngx.say(cjson.encode(res))</span><br></pre></td></tr></table></figure><p>mysql.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> = /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">content_by_lua_file</span> /home/wyzane/lua_code/mysql.lua;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Openresty 官网：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;openresty.org&#x2F;cn&#x2F;</span><br></pre></td></tr></table></figure><p>Openresty的 github 地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;openresty</span><br></pre></td></tr></table></figure><p>Openresty最佳实践：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.kancloud.cn&#x2F;allanyu&#x2F;openresty-best-practices&#x2F;82658</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenResty 是一个基于 Nginx 的可伸缩的 Web 平台，提供了很多高质量的第三方模块；它也是一个强大的 Web 应用服务器，开发人员可以使用 Lua 脚本语言调用 Nginx 支持的各种 C 以及 Lua 模块。&lt;/p&gt;
&lt;p&gt;今天介绍下 OpenResty 在 Ubuntu 1804 上的安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://wyzane.gitee.io/blog/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx中处理http请求的流程</title>
    <link href="http://wyzane.gitee.io/blog/2020/08/02/nginx%E4%B8%AD%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://wyzane.gitee.io/blog/2020/08/02/nginx%E4%B8%AD%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B/</id>
    <published>2020-08-02T13:27:23.000Z</published>
    <updated>2023-02-26T08:50:52.339Z</updated>
    
    <content type="html"><![CDATA[<p>今天总结下 nginx 处理http请求的流程，重点介绍下处理 http 请求的11个阶段。</p><p>nginx 处理 http 请求时，首先会对请求行和请求体进行解析，解析完成后进入11 个阶段，这 11 个阶段会根据 nginx.conf 中的配置信息进行相应的重定向、权限控制、日志记录等操作。</p><a id="more"></a><h1 id="http请求的11个阶段"><a href="#http请求的11个阶段" class="headerlink" title="http请求的11个阶段"></a>http请求的11个阶段</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST_READ：读取到请求头之后会进入该阶段，realip模块在该阶段使用</span><br><span class="line">SERVER_REWRITE：执行server块内，location块外的指令，rewrite 模块在该阶段生效</span><br><span class="line">FIND_CONFIG：根据配置，寻找对应的 location 块并执行</span><br><span class="line">REWRITE：执行 location 块中的重写指令</span><br><span class="line">POST_REWRITE：根据上阶段的重写指令跳转到合适的阶段</span><br><span class="line">PREACCESS：访问权限控制之前的阶段，执行访问频率、连接数等控制</span><br><span class="line">ACCESS：访问权限的控制阶段，例如基于ip黑名单的权限控制</span><br><span class="line">POST_ACCESS：访问权限控制的后一阶段，该阶段根据权限控制阶段的执行结果进行相应处理</span><br><span class="line">PRECONTENT：try_files指令的处理阶段，如果没有配置try_files指令，则该阶段被跳过</span><br><span class="line">CONTENT：内容生成阶段，该阶段产生响应，并发送到客户端</span><br><span class="line">LOG：记录访问日志</span><br></pre></td></tr></table></figure><p>各个请求阶段的顺序如下：</p><p><img src="nginx%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B52.png" alt="nginx处理http请求的11个阶段2"></p><p>上面简单介绍了 nginx 处理 http 请求的各个阶段，以及各个阶段使用到的模块（导数第二行是 content 阶段，最后一行是 log 阶段）。下面具体介绍各个阶段的功能。</p><h2 id="POST-READ"><a href="#POST-READ" class="headerlink" title="POST_READ"></a>POST_READ</h2><p>解析完请求体后，首先会进入 post_read 阶段，该阶段主要获取客户端真实 ip。</p><h3 id="realip模块"><a href="#realip模块" class="headerlink" title="realip模块"></a>realip模块</h3><p>realip 模块在 POST_READ 节点生效，可以用来获取客户端的真实 ip 地址。</p><p>在 http 请求中，可以通过请求头中的 X-Forwarded-For 和 X-Real-IP 获取 ip 地址，X-Forwarded-For 中可能保存了多个</p><p>ip，X-Real-IP 中保存了客户端的真实 ip。realip 模块会把从 X-Forwarded-For 和 X-Real-IP 获取的值赋值到 nginx 变量 binary_remote_addr 和 remote_addr 中，从而通过这两个变量就能获取客户端真实 ip 地址，后续会进一步做限流、限速等工作（在 limit_conn 模块中）。</p><p>realip 模块默认没有编译进 nginx ，可以通过 –with-http_realip_module 参数将其编译进 nginx。</p><p>realip 中的指令（具体说明可以查阅官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html）" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_realip_module.html）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. set_real_ip_from addr|CIDR|unix;</span><br><span class="line">作用：设置信任地址，从该地址过来的请求会被获取真实地址，并替换 remote_addr 中的值</span><br><span class="line">例子：set_real_ip_from  192.168.1.0&#x2F;24|192.168.2.1;</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. real_ip_header field | X-Real-IP | X-Forwarded-For | proxy_protocol;</span><br><span class="line">作用：从请求头的哪个参数中获取真实ip</span><br><span class="line">例子：real_ip_header X-Real-IP（默认）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. real_ip_recursive on | off;</span><br><span class="line">作用：设置为 off 时，匹配信任地址（由 set_real_ip_from 设置）的真实客户端地址会被一个值替换，这个值是 real_ip_header 指定的请求头参数中最后一个值；为 on 时，真实客户端地址会被一个非信任值替代，这个值也是 real_ip_header 指定的请求头参数中的值</span><br></pre></td></tr></table></figure><p>realip 中指令的配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> realip.wzblogs.cn;</span><br><span class="line">    <span class="attribute">set_real_ip_from</span> <span class="number">223.73.212.4</span>;</span><br><span class="line">    <span class="attribute">real_ip_recursive</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="comment"># real_ip_recursive on;</span></span><br><span class="line">    <span class="attribute">real_ip_header</span> X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">"client real ip is：<span class="variable">$remote_addr</span>\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SERVER-REWRITE"><a href="#SERVER-REWRITE" class="headerlink" title="SERVER_REWRITE"></a>SERVER_REWRITE</h2><p>该阶段中，在 server 块内，location 块外的指令会被执行。</p><h3 id="rewrite模块"><a href="#rewrite模块" class="headerlink" title="rewrite模块"></a>rewrite模块</h3><p>rewrite 模块在 server_write 阶段生效，该模块主要功能是改变请求 URI，主要有以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">1. return code URL | return URL | return code [text]</span><br><span class="line">作用：停止请求的访问，并返回给客户端状态码和重定向url</span><br><span class="line">例子：return 302 &#x2F;redirect_url;</span><br><span class="line">上下文：server, location, if</span><br><span class="line"></span><br><span class="line">return 中的一些状态码：</span><br><span class="line">HTTP 1.0：</span><br><span class="line">301 永久重定向（访问站点a时，被重定向到站点b，则下次遇到访问站点a的请求就会直接访问站点b）</span><br><span class="line">302 临时重定向，禁止被缓存（访问站点a时，被重定向到站点b，则下次还会先访问站点a，再被重定向到b）</span><br><span class="line"></span><br><span class="line">HTTP 1.1:</span><br><span class="line">303 临时重定向，允许改变请求方法，禁止被缓存</span><br><span class="line">307 临时重定向，不允许改变请求方法，禁止被缓存</span><br><span class="line">308 永久重定向，不允许改变请求方法</span><br><span class="line"></span><br><span class="line">error_page 指令与 return 指令的不同</span><br><span class="line">error_page code uri;</span><br><span class="line">作用：nginx接收到指定状态码时，返回特定的页面或者uri</span><br><span class="line">例子： error_page 404 &#x2F;404.html;|error_page 500 501 502 503 &#x2F;50x.html;</span><br><span class="line">error_page 404 &#x3D;200 &#x2F;empty.gif (接收到404时，返回一张图片，响应状态码是200)</span><br><span class="line">上下文：http, server, location, if in location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. rewrite regex replacement [flag]</span><br><span class="line">作用：用于修改接收到的uri，如果如果正则表达式匹配uri，则匹配的uri会被replacement替换。其中 flag 有以下几个值：last,break,redirect,permanent</span><br><span class="line">last： 使用 replacement 继续进行 location匹配</span><br><span class="line">break: 停止当前脚本指令的执行，等价于独立的 break 指令</span><br><span class="line">redirect: 返回302重定向</span><br><span class="line">permanent: 返回301重定向</span><br><span class="line">上下文：server, location, if</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. rewrite_log on | off;</span><br><span class="line">作用：是否记录 rewrite 模块产生的日志，默认为 off，为 on 时，会将日志记录在 error_log 指定的文件中</span><br><span class="line">上下文：http, server, location, if</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. if (condition) &#123; ... &#125;</span><br><span class="line">作用：判断变量的值，如果满足条件，则执行 if 块中的内容</span><br><span class="line">上下文：server, location</span><br><span class="line">condition中可以有下面的功能：</span><br><span class="line">1. 检查变量为空或者为0</span><br><span class="line">2. 将变量与字符串做匹配，使用&#x3D;或者!&#x3D;</span><br><span class="line">3. 将变量与正则表达式匹配</span><br><span class="line">4. 检查文件是否存在，使用 -f 或者 !-f</span><br><span class="line">5. 检查目录是否存在，使用 -d 或者 !-d</span><br><span class="line">6. 检查文件、目录、软链接是否存在，使用 -e 或者 !-e</span><br><span class="line">7. 检查是否为可执行文件，使用 -x 或者 !-x</span><br><span class="line"></span><br><span class="line">if 中也可以使用正则表达式匹配，正则表达式规则如下：</span><br><span class="line">&#x3D;&#x3D;:等值比较;</span><br><span class="line">~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br><span class="line">!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br></pre></td></tr></table></figure><h3 id="error-page与return的优先级"><a href="#error-page与return的优先级" class="headerlink" title="error_page与return的优先级"></a>error_page与return的优先级</h3><p>return.conf 的配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8095</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line">    <span class="attribute">error_page</span>  <span class="number">404</span> /<span class="number">403</span>.html;</span><br><span class="line">    <span class="comment"># return 405;</span></span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">        <span class="comment"># return 404 "find nothing\n";</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 nginx 后，执行请求 curl localhost:8095/xxx，会直接返回 html/403.html 中的内容；当打开 location 块中的 return 后，会返回 “find nothing”；同样的，将 server 块中的 return 打开，同样的请求，会返回 405 的错误；这说明 return 指令会覆盖 它前面的 error_page 指令。</p><h3 id="rewrite与return的使用"><a href="#rewrite与return的使用" class="headerlink" title="rewrite与return的使用"></a>rewrite与return的使用</h3><p>下面看一个 rewrite 指令的使用例子，rewrite.conf 配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /first &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /first(.*) /second<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'first\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /second &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /second(.*) /third<span class="variable">$1</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'second\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /third &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'third\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /redirect &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /redirect(.*) <span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，html 目录的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 403.html</span><br><span class="line">├── 50x.html</span><br><span class="line">├── first</span><br><span class="line">│   └── 1.txt</span><br><span class="line">├── index.html</span><br><span class="line">├── second</span><br><span class="line">│   └── 2.txt</span><br><span class="line">└── third</span><br><span class="line">    └── 3.txt</span><br></pre></td></tr></table></figure><p>启动 nginx 服务后，执行 curl localhost:8096/first/3.txt，返回的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">second</span><br></pre></td></tr></table></figure><p>可以看到，先匹配到了 location /first，然后再去匹配 location /second，最后执行了 return 指令，返回了结果。</p><p>在 location /second 中的 rewrite 指令后加上 break 后，返回的内容就是 third/3.txt 文件中的内容，此时说明 break 指令生效了，此时访问  curl localhost:8096/second/3.txt 也会得到相同结果。</p><h3 id="if-指令使用例子"><a href="#if-指令使用例子" class="headerlink" title="if 指令使用例子"></a>if 指令使用例子</h3><p>if 指令使用例子如下，server_if.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8097;</span><br><span class="line"></span><br><span class="line">    if ($request_uri ~* &#x2F;aaa&#x2F;test.html)&#123;</span><br><span class="line">        return 200 &quot;test.html returned\n&quot;;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        return 200 &quot;location returned\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 curl localhost:8097/aaa/test.html 时，会进入 if 块中，返回 test.html returned。</p><h2 id="FIND-CONFIG"><a href="#FIND-CONFIG" class="headerlink" title="FIND_CONFIG"></a>FIND_CONFIG</h2><p>find_config 阶段主要功能是选择哪个 location 块，并执行 location 块中的配置。location 块中常用指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location </span><br><span class="line">上下文：server，location</span><br><span class="line">location 后面可以跟以下数据：</span><br><span class="line">1. 前缀字符串</span><br><span class="line">&#x3D;：精确匹配</span><br><span class="line">^~：匹配成功后，则不再进行正则表达式匹配</span><br><span class="line">常规字符串</span><br><span class="line">2. 正则表达式</span><br><span class="line">~：大小写敏感</span><br><span class="line">~*：忽略大小写</span><br><span class="line">3. 内部跳转的命名location（使用@符号 + 名称）</span><br></pre></td></tr></table></figure><p>当 nginx 中配置了多个 location 块时，它的匹配规则是怎么样的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 首先会遍历所有前缀字符串，找到匹配的 location （与 location 顺序无关）</span><br><span class="line">1）&#x3D; 精确匹配优先级最高</span><br><span class="line">2）没有精确匹配时使用 ^~ 匹配上的location</span><br><span class="line">3）当有多个匹配上时，选择 location 中 url 最长的匹配 </span><br><span class="line">2. 按照正则表达式匹配（此时会根据 location 的顺序进行匹配）</span><br><span class="line">1）按照正则表达式，匹配上则使用该 location</span><br></pre></td></tr></table></figure><p>下面看一下 location 指令使用的具体例子，location.conf的配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8099</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    <span class="attribute">location</span> /aaa &#123;</span><br><span class="line">        <span class="comment"># 前缀匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'prefix string match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /aaa/$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配，大小写敏感</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex strict match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* /aaa/$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配，忽略大小写</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex none strice match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4</span></span><br><span class="line">    <span class="attribute">location</span> /aaa/bbb &#123;</span><br><span class="line">        <span class="comment"># 前缀最长匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'long prefix string match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* /aaa/(\w+)$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'long regex match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /aaa$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7</span></span><br><span class="line">    <span class="attribute">location</span> = /aaa &#123;</span><br><span class="line">        <span class="comment"># 精确匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'exatc match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 8</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /aaa &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'^~ match \n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当有前缀匹配、正则匹配、^~匹配、精确匹配时，优先精确匹配、其次^~匹配、然后正则匹配、最后前缀匹配，对应上面配置的顺序为7861</span><br><span class="line">curl localhost:8099&#x2F;aaa                                 </span><br><span class="line">响应：exatc match</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 正则匹配，优先匹配区分大小写的配置</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;                                </span><br><span class="line">响应：regex strict match</span><br><span class="line"></span><br><span class="line"># 正则匹配，不区分大小写</span><br><span class="line">curl localhost:8099&#x2F;Aaa&#x2F;</span><br><span class="line">响应：regex none strice match</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 正则匹配，优先匹配5中的配置而不是4</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;bbb</span><br><span class="line">响应：long regex match</span><br><span class="line"></span><br><span class="line"># 正则表达式未匹配到，使用字符串最长匹配规则，匹配4而不是5</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;bbb&#x2F;</span><br><span class="line">long prefix string match</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ^~，匹配后，则不再使用正选择匹配</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;ccc                             </span><br><span class="line">响应：^~ match </span><br><span class="line"></span><br><span class="line">如果加上配置：</span><br><span class="line">location &#x2F;aaa&#x2F;ccc &#123;</span><br><span class="line">    # 前缀最长匹配</span><br><span class="line">    return 200 &#39;long prefix string match ccc\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">则 curl localhost:8099&#x2F;aaa&#x2F;ccc 会返回 long prefix string match ccc</span><br></pre></td></tr></table></figure><h2 id="PREACCESS"><a href="#PREACCESS" class="headerlink" title="PREACCESS"></a>PREACCESS</h2><p>preaccess 阶段主要功能是对客户端的请求数或者连接数进行限制。</p><p>限制连接数时，需要用到 nginx 的 ngx_http_limit_conn_module 模块，限制请求数时，要使用 ngx_http_limit_req_module 模块。</p><h3 id="limit-conn"><a href="#limit-conn" class="headerlink" title="limit_conn"></a>limit_conn</h3><p>ngx_http_limit_conn_module 模块的生效范围是全部worker（基于共享内存），并且限制的有效性取决于 key 的设计（依赖于 postread 阶段中realip模块取到的真实ip）。 </p><p>常用指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone key zone&#x3D;name:size;</span><br><span class="line">功能：为一块共享内存指定一个 key，会记录每个 key 的状态（状态中包含了 key 对应的当前连接数）</span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_conn zone number;</span><br><span class="line">功能：限制 key 的并发连接数</span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_conn_log_level info | notice | warn | error;（默认 error）</span><br><span class="line">功能：发生限制并发连接时，打印日志的格式</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_conn_status code;（默认 503）</span><br><span class="line">功能：发生并发连接数限制时，向客户端返回的状态码</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><p>限制客户端连接数的配置例子为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=addr:<span class="number">10m</span>;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8099</span>;</span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line">    <span class="attribute">error_log</span>  logs/err_limit.log <span class="literal">info</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_conn_status</span> <span class="number">503</span>;</span><br><span class="line">        <span class="attribute">limit_conn_log_level</span>  <span class="literal">warn</span>;</span><br><span class="line">        <span class="comment"># 限制向客户端返回数据的速率（每秒50字节）</span></span><br><span class="line">        <span class="attribute">limit_rate</span> <span class="number">50</span>;</span><br><span class="line">        <span class="attribute">limit_conn</span> addr <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="limit-req"><a href="#limit-req" class="headerlink" title="limit_req"></a>limit_req</h3><p>ngx_http_limit_req_module 模块的生效范围也是全部 worker  进程，使用的算法是 leaky bucket 算法。</p><p>常用指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone key zone&#x3D;name:size rate&#x3D;rate;</span><br><span class="line">功能：与 limit_conn_zone 功能类似，定义共享内存大小，以及根据 key 关键字限制速率，rate 是每秒或每分钟处理的请求数（r&#x2F;s、r&#x2F;m）</span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req limit_req zone&#x3D;name [burst&#x3D;number] [nodelay | delay&#x3D;number];</span><br><span class="line">功能：限制并发连接数，burst表示最大请求数，nodelay表示对burst中的请求立刻处理</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req_log_level info | notice | warn | error;</span><br><span class="line">功能：限制发生时的日志级别</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req_status code;</span><br><span class="line">功能：限制发生时，返回给客户端的状态码</span><br><span class="line">上下文: http, server, location</span><br></pre></td></tr></table></figure><p>限制客户端请求数的配置例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 每分钟处理两次请求</span><br><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;req:10m rate&#x3D;2r&#x2F;m;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8099;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log  logs&#x2F;err_limit.log info;</span><br><span class="line">   </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        limit_req zone&#x3D;req burst&#x3D;3 nodelay;</span><br><span class="line">        # limit_req zone&#x3D;req;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当同时配置了 limit_conn 和 limit_req 时，由于 limt_req 模块在 limit_conn 模块之前，所以 limit_req 模块会先返回，limit_conn 模块则不会返回。</p><h2 id="ACCESS"><a href="#ACCESS" class="headerlink" title="ACCESS"></a>ACCESS</h2><p>access 阶段主要负责对 ip 访问的权限控制，常用模块 ngx_http_access_module（用户对 ip 做限制）、 ngx_http_auth_basic_module（校验用户名和密码）、ngx_http_auth_request_module（使用第三方的权限验证）</p><p>与 access 阶段相关的一个指令 satisfy ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">satisfy all | any;</span><br><span class="line">功能：配置为all时，所有模块（ngx_http_access_module, ngx_http_auth_basic_module, ngx_http_auth_request_module, ngx_http_auth_jwt_module）通过时，请求才能继续；为 any 时，至少有一个模块通过请求才能继续。默认为 all</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><p>access （ngx_http_access_module）模块常用指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allow address | CIDR | unix: | all;</span><br><span class="line">功能：允许哪些地址访问</span><br><span class="line">上下文：http, server, location, limit_except</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deny address | CIDR | unix: | all;</span><br><span class="line">功能：不允许哪些地址访问</span><br><span class="line">上下文：http, server, location, limit_except</span><br></pre></td></tr></table></figure><p>配置例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    deny 192.168.1.1;</span><br><span class="line">    allow 192.168.1.0&#x2F;24;</span><br><span class="line">    allow 10.1.1.0&#x2F;16;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auth_basic（ngx_http_auth_basic_module） 模块常用指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auth_basic string | off;</span><br><span class="line">功能：开启或者禁用 auth_basic，默认off，string表示浏览器上标签页显示的对话框名称</span><br><span class="line">上下文：http, server, location, limit_except</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth_basic_user_file file;</span><br><span class="line">功能：指定用户名、密码配置文件</span><br><span class="line">上下文：http, server, location, limit_except</span><br></pre></td></tr></table></figure><p>配置例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8099;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        satisfy any;</span><br><span class="line">        auth_basic &#39;auth_test&#39;;</span><br><span class="line">        # 指定密码文件为 passwd&#x2F;user.pass</span><br><span class="line">        auth_basic_user_file passwd&#x2F;user.pass;</span><br><span class="line">        deny all;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auth_request（ngx_http_auth_request_module） 模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原理：收到请求后，生成一个子请求，通过反向代理把子请求传到上游第三方服务器，根据上游服务器返回的响应来处理收到的原请求。若上游服务器范围的状态码为 2xx，则允许请求继续，若范围的是 401 或者 403，则将请求返回给客户端。</span><br></pre></td></tr></table></figure><p>常用指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auth_request uri | off;</span><br><span class="line">功能：配置子请求访问的url，默认为off</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth_request_set $variable value;</span><br><span class="line">功能：权限校验完成后，设置新的变量和值，值中可以包含上游请求的一些信息</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h2 id="PRECONTENT阶段"><a href="#PRECONTENT阶段" class="headerlink" title="PRECONTENT阶段"></a>PRECONTENT阶段</h2><h3 id="try-files模块"><a href="#try-files模块" class="headerlink" title="try_files模块"></a>try_files模块</h3><p>try_files 模块中有一个 try_files 指令，其功能如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能：依次访问文件，当文件存在时，返回文件中的内容，后面的文件将不再访问，若文件都不存在，返回最后的 url 或者 code</span><br><span class="line">语法：try_files file1 file2 file3 ... uri|&#x3D;code;</span><br><span class="line">上下文：server, location</span><br></pre></td></tr></table></figure><p>使用例子如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8090</span>;</span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /first &#123;</span><br><span class="line">        <span class="attribute">try_files</span> /tmp/index.html <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html <span class="variable">$uri</span>.html <span class="variable">@lasturl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@lasturl</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'lasturl \n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /second &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mirror模块"><a href="#mirror模块" class="headerlink" title="mirror模块"></a>mirror模块</h3><p>mirror 模块具有实时流量拷贝的功能，可以把生产环境的请求拷贝一份到测试环境中。该模块中提供了以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. mirror</span><br><span class="line">功能：处理请求时，生成子请求访问其他服务，对于子请求的返回值则不做处理</span><br><span class="line">语法：mirror uri | off(默认);</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. mirror_request_body</span><br><span class="line">功能：是否把请求体也转发到其他服务</span><br><span class="line">语法：mirror_request_body on(默认) | off;</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h2 id="CONTENT阶段"><a href="#CONTENT阶段" class="headerlink" title="CONTENT阶段"></a>CONTENT阶段</h2><h3 id="static模块"><a href="#static模块" class="headerlink" title="static模块"></a>static模块</h3><p>content阶段中有一个 static 模块，它提供了两个我们常用的指令：root 和 alias，这两个指令的功能都是将 url 映射为文件路径，以返回静态文件中的内容。其中 root 将完整的 url 映射为文件路径，alias 将 location 后的 url 映射为文件路径。两个指令的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. root</span><br><span class="line">语法：root path; （默认：root html）</span><br><span class="line">上下文：http, server, location, if in location</span><br><span class="line"></span><br><span class="line">2. alias</span><br><span class="line">语法：alias path;（无默认值）</span><br><span class="line">上下文：location</span><br></pre></td></tr></table></figure><p>static 模块中还提供了三个静态文件相关的变量：request_filename（待访问文件的完整路径）、document_root（由 URI 和 root/alias 指定的规则生成的文件对应的目录）、realpath_root（若document_root中有软链接，则会将软链接替换成真实路径）。</p><p>static模块中还提供了以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. types</span><br><span class="line">功能：映射文件扩展名和响应中的 content-type</span><br><span class="line">语法：types &#123;text&#x2F;html  html; image&#x2F;gif  gif; image&#x2F;jpeg jpg;&#125;</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. default_type</span><br><span class="line">功能：设置响应中默认的 content-type</span><br><span class="line">语法：default_type mime-type;</span><br><span class="line">默认：default_type text&#x2F;plain;</span><br><span class="line">上下文: http, server, location</span><br></pre></td></tr></table></figure><h3 id="index模块"><a href="#index模块" class="headerlink" title="index模块"></a>index模块</h3><p>index 模块的功能是：当访问的 url 以 / 结尾时，index 模块就会寻找该目录下是否有 index.html 文件，如果有，就会将 index.html 的内容返回。可以通过 index 指令指定要寻找的文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：index file;</span><br><span class="line">默认：index index.html;</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h3 id="autoindex模块"><a href="#autoindex模块" class="headerlink" title="autoindex模块"></a>autoindex模块</h3><p>audoindex 模块的功能是：当请求 url 以 / 结尾时，会尝试以 html/xml/jspn/jsonp 等形式返回 root/alias 所指向目录的目录结构。指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. autoindex</span><br><span class="line">功能：展示或者不展示目录结构</span><br><span class="line">用法：autoindex on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. autoindex_format</span><br><span class="line">功能：显示的格式</span><br><span class="line">用法：autoindex_format html | xml | json | jsonp;（默认 html）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. autoindex_localtime</span><br><span class="line">功能：是否显示本地时间（仅 html 格式生效）</span><br><span class="line">用法：autoindex_localtime on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. autoindex_exact_size</span><br><span class="line">功能：是否显示文件大小（仅 html 格式生效）</span><br><span class="line">用法：autoindex_exact_size on | off;（默认 off，显示字节数）</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h3 id="concat-模块"><a href="#concat-模块" class="headerlink" title="concat 模块"></a>concat 模块</h3><p>concat 模块的功能是：可以把多个小文件的内容合并到一个 http 响应中返回。该模块的 github 地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nginx-http-concat</span><br></pre></td></tr></table></figure><p>当请求多个文件内容时，请求url后需要跟两个?，再配合该模块，就可以接收多个文件的内容，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;example.com&#x2F;??style1.css,style2.css,foo&#x2F;style3.css</span><br><span class="line">http:&#x2F;&#x2F;example.com&#x2F;xxx&#x2F;??style1.css,style2.css,foo&#x2F;style3.css</span><br></pre></td></tr></table></figure><p>下载后，可以通过 –add-modules 来安装该模块。它提供的指令有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. concat</span><br><span class="line">功能：是否启用合并功能</span><br><span class="line">用法：concat on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. concat_types</span><br><span class="line">功能：指定对哪些文件类型做合并</span><br><span class="line">用法：concat_types MIME types</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. concat_delimiter</span><br><span class="line">功能：返回多个文件时，指定文件内容的分隔符</span><br><span class="line">用法：concat_delimiter: string;</span><br><span class="line">上下文：http, server, locatione</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. concat_unique</span><br><span class="line">功能：是否仅对一种文件类型合并</span><br><span class="line">用法：concat_unique on | off;（默认 on, 仅对一种文件类型合并）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. concat_ignore_file_error</span><br><span class="line">功能：是否忽略文件不存在等错误</span><br><span class="line">用法：concat_ignore_file_error: on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. concat_max_files</span><br><span class="line">功能：指定最多合并的文件数量</span><br><span class="line">用法：concat_max_files number（默认 10）</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure><h2 id="LOG阶段"><a href="#LOG阶段" class="headerlink" title="LOG阶段"></a>LOG阶段</h2><p>log阶段中有 log 模块，它的功能是把 http 请求相关的信息记录到日志文件中。常用指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. log_format</span><br><span class="line">功能：定义日志的格式</span><br><span class="line">用法：log_format name [escape&#x3D;default|json|none] string ...;</span><br><span class="line">默认：log_format combined &#39;...&#39;;（日志有一个默认格式）</span><br><span class="line">上下文: http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. access_log</span><br><span class="line">功能：指定日志文件路径和格式</span><br><span class="line">用法：access_log path [format [buffer&#x3D;size] [gzip[&#x3D;level]] [flush&#x3D;time] [if&#x3D;condition]];</span><br><span class="line">默认：access_log path combined;</span><br><span class="line">上下文：http, server, location, if in location, limit_except</span><br><span class="line"></span><br><span class="line">access_log 后的 path 中可以包含变量，它后面也可以跟 buffer、gzip、flush等参数，这些参数有如下功能：</span><br><span class="line">1. 日志缓存：批量将内存中的日志写入缓存中，写入磁盘的条件有1）所欲待写入磁盘的日志大小超出缓存大小 2）达到 flush 指定的过期时间 3）worker进程执行 reopen 命令</span><br><span class="line">2. 日志压缩：批量压缩内存中的日志，再写入磁盘，buffer参数值的默认大小为64k，压缩级别默认为1（1最快压缩压缩率最低 9最慢压缩压缩率最高）</span><br></pre></td></tr></table></figure><p>….. 未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天总结下 nginx 处理http请求的流程，重点介绍下处理 http 请求的11个阶段。&lt;/p&gt;
&lt;p&gt;nginx 处理 http 请求时，首先会对请求行和请求体进行解析，解析完成后进入11 个阶段，这 11 个阶段会根据 nginx.conf 中的配置信息进行相应的重定向、权限控制、日志记录等操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://wyzane.gitee.io/blog/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>django开发之在docker中部署项目</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/26/django%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9C%A8docker%E4%B8%AD%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/26/django%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9C%A8docker%E4%B8%AD%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-07-26T07:51:27.000Z</published>
    <updated>2020-07-26T08:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理了一下如何在docker中部署django项目。</p><a id="more"></a><h1 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.6 django2.0.5 nginx mysql5.7 gunicorn</span><br></pre></td></tr></table></figure><h1 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h1><p>项目主目录为 blog 目录，需要编写的文件包括（省去了其他django文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog&#x2F;Dockerfile, blog&#x2F;gunicorn.conf, blog&#x2F;start.sh, nginx&#x2F;Doickerfile, nginx&#x2F;nginx.conf, docker-conpose.yml</span><br></pre></td></tr></table></figure><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><h2 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h2><p>blog/Dockerfile 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6    # 选择基础镜像,这里的基础镜像也可以选择ubuntu,centos等，但是下面的配置就会发生变化</span><br><span class="line"></span><br><span class="line"># 创建工作目录</span><br><span class="line">RUN mkdir &#x2F;blog  </span><br><span class="line"></span><br><span class="line">#设置工作目录</span><br><span class="line">WORKDIR &#x2F;blog</span><br><span class="line"></span><br><span class="line">#将当前目录加入到工作目录中</span><br><span class="line">ADD . &#x2F;blog</span><br><span class="line">RUN pip3 install -r requirements.txt</span><br><span class="line">#对外暴露端口</span><br><span class="line">EXPOSE 80 8080 8000 5000</span><br><span class="line">#设置环境变量</span><br><span class="line">ENV SPIDER&#x3D;&#x2F;blog</span><br></pre></td></tr></table></figure><p>上面基础镜像使用的是python:3.6,而不是ubuntu、centos。如果是ubuntu、cenos，Dockerfile文件中需要配置python环境</p><p>nginx/Doickerfile 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx    # nginx镜像，最好是先拉取到本地</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对外暴露端口</span><br><span class="line">EXPOSE 80 8000</span><br><span class="line"></span><br><span class="line">RUN rm &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf  # 删除原有配置文件</span><br><span class="line">ADD nginx.conf  &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;   # 添加配置文件</span><br><span class="line">RUN mkdir -p &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static  # 创建静态资源文件夹</span><br></pre></td></tr></table></figure><p>docker-compose.yml 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">    image: mysql:5.7  # mysql镜像，最好先拉取到本地</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_HOST&#x3D;localhost</span><br><span class="line">      - MYSQL_DATABASE&#x3D;docker</span><br><span class="line">      - MYSQL_USER&#x3D;root</span><br><span class="line">      - MYSQL_PASSWORD&#x3D;wyzane</span><br><span class="line">      - MYSQL_ROOT_PASSWORD&#x3D;wyzane</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;home&#x2F;wyzane&#x2F;pyprojects&#x2F;db:&#x2F;var&#x2F;lib&#x2F;mysql  # 将宿主机与容器中的文件映射</span><br><span class="line">    restart: always  # 若容器运行出现问题，会自动重启容器</span><br><span class="line"></span><br><span class="line">  web:</span><br><span class="line">    build: .&#x2F;blog</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;8000:8000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;blog:&#x2F;blog</span><br><span class="line">    - &#x2F;tmp&#x2F;logs:&#x2F;tmp</span><br><span class="line">    command: bash start.sh  # 执行命令，有多种格式</span><br><span class="line">    links:</span><br><span class="line">    - db</span><br><span class="line">    depends_on:</span><br><span class="line">    - db</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">nginx:</span><br><span class="line">    build: .&#x2F;nginx</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;blog&#x2F;static:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static:ro</span><br><span class="line">    links:</span><br><span class="line">    - web</span><br><span class="line">    depends_on:</span><br><span class="line">    - web</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure><h2 id="gunicorn配置"><a href="#gunicorn配置" class="headerlink" title="gunicorn配置"></a>gunicorn配置</h2><p>blog/gunicorn.conf 的配置内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workers&#x3D;2</span><br><span class="line">bind&#x3D;&#39;0.0.0.0:8000&#39;</span><br><span class="line">proc_name&#x3D;&#39;blog&#39;</span><br></pre></td></tr></table></figure><h2 id="start文件配置"><a href="#start文件配置" class="headerlink" title="start文件配置"></a>start文件配置</h2><p>blog/start.sh 文件内容如下，用于启动项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">python manage.py collectstatic --noinput&amp;&amp;</span><br><span class="line">python manage.py makemigrations&amp;&amp;</span><br><span class="line">python manage.py migrate &amp;&amp;</span><br><span class="line">gunicornblog.wsgi:application -c gunicorn.conf</span><br></pre></td></tr></table></figure><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>nginx/nginx.conf 文件配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location &#x2F;static &#123;</span><br><span class="line">        alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;web:8000;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h1><p>配置完成后，依次执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>执行完成后，通过 docker images 命令可以查看新增了2个镜像，docker ps 命令可以查看启动了3个容器。</p><p>多执行几次docker ps，当容器的STATUS是以Restarting开头时，表示这个容器运行时发生了错误。执行docker logs CONTAINERID可以查看容器出错的具体原因。</p><p>若上述容器都成功运行，则在浏览器中输入<a href="http://127.0.0.1:80/api/v1/articles/info/时（这是django中的一个视图，在这里没有写出来，不同的小伙伴可以替换成不同的接口），视图会返回相应的结果。" target="_blank" rel="noopener">http://127.0.0.1:80/api/v1/articles/info/时（这是django中的一个视图，在这里没有写出来，不同的小伙伴可以替换成不同的接口），视图会返回相应的结果。</a><br>以交互方式进入容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it CONTAINERID &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>后，进入mysql数据库，会看到在数据库中生成了相应的表。</p><h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>在运行3个容器后，web容器一直报错，通过 docker logs CONTAINERID查看主要错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django.db.utils.OperationalError: (2003, &#39;Can\&#39;t connect to MySQL server on \&#39;mariadb55\&#39; (111 &quot;Connection refused&quot;)&#39;)</span><br></pre></td></tr></table></figure><p>解决方案在这里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;47979270&#x2F;django-cannot-connect-mysql-in-docker-compose</span><br></pre></td></tr></table></figure><p>主要是在settings.py中，将database配置中的HOST值改成db,而不是127.0.0.1，指向docker-compose.yml中的db服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天整理了一下如何在docker中部署django项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="django, docker" scheme="http://wyzane.gitee.io/blog/tags/django-docker/"/>
    
  </entry>
  
  <entry>
    <title>为已安装的nginx动态添加模块</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/25/%E4%B8%BA%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84nginx%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/25/%E4%B8%BA%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84nginx%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97/</id>
    <published>2020-07-25T09:47:09.000Z</published>
    <updated>2020-07-25T09:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍下如何为已安装的 nginx 动态添加模块。</p><a id="more"></a><p>首先，我们下载需要编译进 nginx 模块，或者使用 nginx 自带的模块如：realip 模块。</p><p>然后，执行 nginx -V，查看nginx信息和之前的安装记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  conf nginx -V                                  </span><br><span class="line">nginx version: nginx&#x2F;1.16.1</span><br><span class="line">built by gcc 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) </span><br><span class="line">built with OpenSSL 1.1.1  11 Sep 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic</span><br></pre></td></tr></table></figure><p>可以看到，我们之前编译 nginx 时使用的参数是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic</span><br></pre></td></tr></table></figure><p>那么，我们这次编译时，如果想把 nginx 自带的模块编译进去，如 realip，则执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic --with-http_realip_module</span><br></pre></td></tr></table></figure><p>如果想把第三方模块编译进去，则可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic -–add-module&#x3D;第三方模块所在目录</span><br></pre></td></tr></table></figure><p>上述命令执行完成后，再执行 make 命令（不需要指定 make install命令）就行了。</p><p>最后，将现有的 nginx 二进制文件备份（例如：备份文件 /usr/local/nginx/sbin/nginx），备份完成后，再使用刚刚生成的 nginx 二进制文件替换现有的 nginx 二进制文件既可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天介绍下如何为已安装的 nginx 动态添加模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://wyzane.gitee.io/blog/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>使用nginx搭建反向代理服务器</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/20/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/20/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-07-20T13:56:31.000Z</published>
    <updated>2020-07-26T02:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享下，如何使用 nginx 搭建具有反向代理功能的服务器。</p><p>首先把 nginx 官方文档地址贴出来，有问题可以随时查阅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>首先介绍下正向代理与反向代理的区别。</p><p>正向代理是发送请求时，隐藏了真正的客户端，即服务端不知道请求的客户端信息，客户端的请求都被代理服务器代替来请求。正向代理的常用场景就是在爬虫系统中。<br>反向代理是客户端不知道将要请求的服务器的信息，而是请求一个代理服务器，代理服务器再去请求上游服务器，并把上游服务器的响应返回给客户端。</p><p>其实，正向代理和反向代理的请求流程都是一样的，只是被代理对象不同。正向代理代理的对象是客户端，反向代理代理的对象是服务端，也就是说，谁被代理就隐藏了谁。</p><h2 id="反向代理服务器搭建"><a href="#反向代理服务器搭建" class="headerlink" title="反向代理服务器搭建"></a>反向代理服务器搭建</h2><p>下面看一个 nginx 配置反向代理的例子。</p><p>使用 nginx 搭建一个反向代理，上游服务器是一个静态资源 web 服务，配置如下：</p><p>nginx.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                  <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">127.0.0.1:8081</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span>  docs/;   <span class="comment"># 指定静态资源目录</span></span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;  <span class="comment"># 这个设置会显示docs目录结构</span></span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;  <span class="comment"># 限制速率</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反向代理服务器配置如下：</p><p>nginx2.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">include</span>       ../confs/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                  <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定上游服务,这里可以配置负载均衡算法</span></span><br><span class="line">    <span class="attribute">upstream</span> local &#123;</span><br><span class="line">        <span class="attribute">server</span>  <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8082</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">192.168.0.105</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将请求转发到指定的上游服务器</span></span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://local;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别启动两个服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">sudo nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx2.conf</span><br></pre></td></tr></table></figure><p>启动后，再浏览器地址栏输入 <a href="http://192.168.0.105:8082/" target="_blank" rel="noopener">http://192.168.0.105:8082/</a> 便可以访问静态资源了。</p><h2 id="反向代理服务加入缓存功能"><a href="#反向代理服务加入缓存功能" class="headerlink" title="反向代理服务加入缓存功能"></a>反向代理服务加入缓存功能</h2><p>如果想提高响应速率，可以在 nginx 反向代理服务器上增加缓存功能。</p><p>反向代理增加缓存后，客户端的请求会首先从nginx缓存中获取数据，并返回给客户端，当没有缓存数据或者缓存数据过期时，才会请求上游服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">include</span>       ../confs/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                  <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy_cache_path 参数用于设置缓存路径，并且可以指定其他参数</span></span><br><span class="line">    <span class="comment"># levels=1:2 参数指定缓存等级，值从1到3（暂时没弄明白这里的意思）</span></span><br><span class="line">    <span class="comment"># keys_zone  参数指定共享内存大小和名称</span></span><br><span class="line">    <span class="comment"># inactive 参数指定数据缓存的时长，默认10分钟</span></span><br><span class="line">    <span class="comment"># max_size 参数指定缓存数据的最大值</span></span><br><span class="line">    <span class="comment"># use_temp_path 指定是否使用临时文件存放缓存数据</span></span><br><span class="line">    指定保存缓存数据的路径, keys_zone表示开了一个10m的共享内存用于存放key，my_cache是共享内存名称 </span><br><span class="line">    <span class="attribute">proxy_cache_path</span>  /tmp/nginx_cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span> </span><br><span class="line">                      inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定上游服务,这里可以配置负载均衡算法</span></span><br><span class="line">    <span class="attribute">upstream</span> local &#123;</span><br><span class="line">        <span class="attribute">server</span>  <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8082</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">192.168.0.105</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 指定刚刚开辟的共享内存</span></span><br><span class="line">            <span class="attribute">proxy_cache</span>  my_cache;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定义缓存数据对应的 key 由什么组成</span></span><br><span class="line">            <span class="attribute">proxy_cache_key</span>  <span class="variable">$host</span><span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 给指定的想用窗台吗设置缓存过期时间，最后一个值时过期时间，可以是小时、分钟等单位</span></span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">302</span> <span class="number">1d</span>;            </span><br><span class="line">           </span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://local;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置中也介绍了一些常用的缓存参数，详细参数信息可以参考 nginx 的官方文档，文档地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_proxy_module.html#proxy_cache_path</span><br></pre></td></tr></table></figure><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>既然提到了反向代理，那么负载均衡是一定要说一下的。负载均衡的大意就是反向代理服务器把客户端的请求均匀的，或者按照一定的规则分发给上游服务器，从而保证服务可用性。</p><p>实现负载均衡有以下几种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 水平扩展：基于 Round-Robin或者least-connect算法进行请求分发</span><br><span class="line">2. 按功能扩展：根据请求URL，按照功能分发请求到上游服务器</span><br><span class="line">3. 基于用户信息扩展：根据请求客户端ip或者其他信息分发客户端请求（基于hash的某些算法）</span><br></pre></td></tr></table></figure><p>上面的方式可以组合起来使用，并不是只能单独使用。</p><p>nginx支持多种协议的反向代理，即客户端使用http协议请求服务时，nginx可以将其转换成fastcgi、uwsgi、rpc、websocket等协议，再向上游服务器发起请求。</p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>nginx 中负责与上游服务器交互的模块是 upstream 模块，该模块中提供了一个基本的负载均衡算法 Round-Robin。</p><p>upstream 模块中，指定上游服务器的指令是 upstream，上面的例子中已经见过，该指令的作用域是 http 上下文。在 upstream 中，使用 server 指令指定上游服务器地址信息。</p><p>Round-Robin负载均衡算法介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该算法功能：以轮询的方式访问 server 指令指定的上游服务器，该算法集成在 Nginx 的 upstream 模块中。</span><br></pre></td></tr></table></figure><p>该算法提供以下指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wieght: 上游服务器权重，默认1</span><br><span class="line">max_conns：上游服务器的最大并发连接数，仅用于单 worker 进程，默认0，表示没有限制</span><br><span class="line">max_fails: 与fail_timeout配合使用。在fail_timeout时间段内，最大的失败次数。当达到最大失败次数时，在fail_timeout时间内，该上游服务器不再被选择</span><br><span class="line">fail_timeout:单位秒，默认为10，与max_fails配合使用，有两个功能：，指定一段时间内最大的失败次数max_fails；当到达max_fails后，该上游服务器不能再被访问</span><br></pre></td></tr></table></figure><h2 id="反向代理服务中加入负载均衡"><a href="#反向代理服务中加入负载均衡" class="headerlink" title="反向代理服务中加入负载均衡"></a>反向代理服务中加入负载均衡</h2><h3 id="基于-Round-Robin-算法的负载均衡"><a href="#基于-Round-Robin-算法的负载均衡" class="headerlink" title="基于  Round-Robin 算法的负载均衡"></a>基于  Round-Robin 算法的负载均衡</h3><h4 id="反向代理服务配置"><a href="#反向代理服务配置" class="headerlink" title="反向代理服务配置"></a>反向代理服务配置</h4><p>nginx.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">        <span class="comment"># server_name  192.168.0.103;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line">        <span class="attribute">error_log</span>   logs/error.log;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span>  docs/;</span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;  <span class="comment"># 显示docs目录结构</span></span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;</span><br><span class="line">            <span class="comment"># index  index.html index.htm;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 指定反向代理的配置文件，配置文件中加入了负载均衡</span></span><br><span class="line">    <span class="attribute">include</span> reverse_proxy.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reverse_proxy.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> proxy &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8011</span> weight=<span class="number">2</span> max_conns=<span class="number">2</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8012</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8091</span>;</span><br><span class="line">    <span class="attribute">error_log</span>  logs/reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  http://proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上游服务配置"><a href="#上游服务配置" class="headerlink" title="上游服务配置"></a>上游服务配置</h4><p>nginx2.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">127.0.0.1:8082</span>;</span><br><span class="line">        <span class="comment"># server_name  192.168.0.103;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line">        <span class="attribute">error_log</span>   logs/error.log;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span>  docs/;</span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;  <span class="comment"># 显示docs目录结构</span></span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;</span><br><span class="line">            <span class="comment"># index  index.html index.htm;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 指定上游服务配置文件</span></span><br><span class="line">    <span class="attribute">include</span> upstream.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upstream.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 监听 8011 端口</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8011</span>;</span><br><span class="line"><span class="attribute">default_type</span> text/plain;</span><br><span class="line"><span class="attribute">return</span> <span class="number">200</span> <span class="string">'8011 server response'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 监听 8012 端口</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8012</span>;</span><br><span class="line"><span class="attribute">default_type</span> text/plain;</span><br><span class="line"><span class="attribute">return</span> <span class="number">200</span> <span class="string">'8012 server response'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的服务配置好以后，可以分别启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动反向代理服务：sudo nginx -c nginx.conf</span><br><span class="line">启动上游服务：sudo nginx -c nginx2.conf</span><br></pre></td></tr></table></figure><p>服务启动后，在终端多次执行 curl localhost:8091，可以发现，响应结果中，’8011 server response’ 和 ‘8012 server response’ 的比例大致为 2:1，这说明我们配置的负载均衡已经生效了。</p><h3 id="基于-ip-hash-的负载均衡"><a href="#基于-ip-hash-的负载均衡" class="headerlink" title="基于 ip hash 的负载均衡"></a>基于 ip hash 的负载均衡</h3><p>基于 ip 地址的 hash 算法可以根据客户端 ip 的不同，将请求转发到不同的上游服务器，它的配置如下（仅仅修改了 reverse_proxy.conf文件）：</p><p>reverse_proxy.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    set_real_ip_from  192.168.0.105;</span><br><span class="line">    real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，上面使用了 realip 模块的一些指令，现在的 nginx 版本中，realip模块默认没有编译进 nginx，如果要使用 该模块，需要将 realip 模块编译进 nginx 中。如何把某个模块编译进已安装的 nginx 中，可以查看我的另一篇博客。</p><p>上面指定的大致意思如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip_hash：根据用户的 ip 地址分发客户端的请求到上游服务器</span><br><span class="line">set_real_ip_from：设置可信任的地址</span><br><span class="line">real_ip_recursive on：表示原始客户端 ip 地址会被请求头中的某个非信任 ip 地址（由real_ip_header决定）替换</span><br><span class="line">real_ip_header X-Forwarded-For：表示以 X-Forwarded-For 中的最后一个 ip 作为 ip_hash 对应的 ip 地址</span><br></pre></td></tr></table></figure><p>具体解释可以查看官方文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_realip_module.html#set_real_ip_from</span><br></pre></td></tr></table></figure><p>配置完成重启后，我们可以在终端执行以下命令来测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;X-Forwarded-For: 10.112.23.45&quot; localhost:8091</span><br></pre></td></tr></table></figure><p>可以更换 ip ，查看返回的结果。</p><h3 id="基于关键字-hash-的负载均衡"><a href="#基于关键字-hash-的负载均衡" class="headerlink" title="基于关键字  hash 的负载均衡"></a>基于关键字  hash 的负载均衡</h3><p>使用关键字 hash 时，reverse_proxy.conf的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    # 使用特定的字符串作为hash值</span><br><span class="line">    hash user_$arg_username;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    set_real_ip_from  192.168.0.105;</span><br><span class="line">    real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求服务时时，传入不同的 username 参数，会请求不同的上游服务器。</p><h3 id="hash算法优化"><a href="#hash算法优化" class="headerlink" title="hash算法优化"></a>hash算法优化</h3><p>当有上游服务器宕机或者需要扩容时，hash 算法会导致负载均衡的路由发生变化，这样会导致一系列问题（例如缓存失效）。一致性 hash 算法可以解决这个问题。</p><p>nginx 中配置一致性 hash 比较简单，配置如下：</p><p>reverse_proxy.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    # 使用特定的字符串作为hash值</span><br><span class="line">    hash user_$arg_username consistent;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # set_real_ip_from  192.168.0.105;</span><br><span class="line">    # real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原来的 hash key 后面加上 consistent 即可实现一致性 hash，具体介绍可以查看官方文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_upstream_module.html#hash</span><br></pre></td></tr></table></figure><h3 id="基于最少连接数算法的负载均衡"><a href="#基于最少连接数算法的负载均衡" class="headerlink" title="基于最少连接数算法的负载均衡"></a>基于最少连接数算法的负载均衡</h3><p>最少连接数算法中，nginx 反向代理服务器会将客户端请求转发到连接数最少的上游服务器中。当有多个上游服务器最少连接数相同时，会按照 Roubd-Robin 算法将请求发送到这几个服务器中的一个。最少连接数算法的配置如下：</p><p>reverse_proxy.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # set_real_ip_from  192.168.0.105;</span><br><span class="line">    # real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 upstream 上下文中，加入 least_conn 指令即可配置最少连接数算法。</p><p>官方文档如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_upstream_module.html#least_conn</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天分享下，如何使用 nginx 搭建具有反向代理功能的服务器。&lt;/p&gt;
&lt;p&gt;首先把 nginx 官方文档地址贴出来，有问题可以随时查阅：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;nginx.org&amp;#x2F;en&amp;#x2F;docs&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://wyzane.gitee.io/blog/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>ice配合tornado搭建http服务</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/19/ice%E9%85%8D%E5%90%88tornado%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/19/ice%E9%85%8D%E5%90%88tornado%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-07-19T13:23:40.000Z</published>
    <updated>2020-07-19T13:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>tornado 是 python 中的一个 http 框架，以异步高性能著称，zeroc-ice 是一个分布式的 rpc 框架，将两者结合使用，可以搭建高性能的 web 应用服务。</p><p>下面写了一个小 demo，演示了如何在 tornado 中使用 ice。</p><a id="more"></a><h2 id="demo结构"><a href="#demo结构" class="headerlink" title="demo结构"></a>demo结构</h2><p>demo 的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.py</span><br><span class="line">├── handlers.py</span><br><span class="line">├── Test</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── Test.ice</span><br><span class="line">├── Test_ice.py</span><br><span class="line">└── user</span><br><span class="line">    ├── client.ini</span><br><span class="line">    ├── client.py</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── server.ini</span><br><span class="line">    └── server.py</span><br></pre></td></tr></table></figure><p>其中，Test.ice 是 slice 文件，其内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module Test</span><br><span class="line">&#123;</span><br><span class="line">    dictionary&lt;string, string&gt; Params;</span><br><span class="line"></span><br><span class="line">    interface User</span><br><span class="line">    &#123;</span><br><span class="line">        void printStr(string s);</span><br><span class="line"></span><br><span class="line">        int addMun(int num1, int num2);</span><br><span class="line"></span><br><span class="line">        string invoke(string fid, string params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行 slice2py 后，生成了 Test 目录和 Test_ics.py 文件。</p><p>handlers.py 和 app.py 是 tornado 文件，内容分别如下：</p><p>handlers.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 13:48 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">from user.client import IceCommunicator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserHandler(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    def post(self, url):</span><br><span class="line">        print(&quot;url:&quot;, url)</span><br><span class="line">        # print(&quot;params:&quot;, self.request.body.decode(&quot;utf-8&quot;))</span><br><span class="line">        print(&quot;params:&quot;, self.request.arguments)</span><br><span class="line"></span><br><span class="line">        path &#x3D; &quot;user&#x2F;&quot; + url</span><br><span class="line">        params &#x3D; self.request.arguments</span><br><span class="line">        params &#x3D; &#123;k: params.get(k)[0].decode(&quot;utf-8&quot;) for k in params.keys()&#125;</span><br><span class="line"></span><br><span class="line">        resp &#x3D; self.invoke(path, params)</span><br><span class="line">        self.write(resp)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line">    def invoke(self, path, params):</span><br><span class="line">        communicator &#x3D; IceCommunicator()</span><br><span class="line">        user &#x3D; communicator.init()</span><br><span class="line">        params &#x3D; json.dumps(params)</span><br><span class="line">        resp &#x3D; user.invoke(path, params)</span><br><span class="line">        return resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GoodsHandler(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    def post(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>app.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 13:46 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import tornado.web</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.options</span><br><span class="line">import tornado.httpserver</span><br><span class="line">from tornado.options import define, options</span><br><span class="line"></span><br><span class="line">from handlers import UserHandler, GoodsHandler</span><br><span class="line"></span><br><span class="line">define(&quot;port&quot;, default&#x3D;8000, help&#x3D;&quot;run on the given port&quot;, type&#x3D;int)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    handlers &#x3D; [</span><br><span class="line">        (r&quot;&#x2F;user&#x2F;(.*)&quot;, UserHandler),</span><br><span class="line">        (r&quot;&#x2F;goods&#x2F;(.*)&quot;, GoodsHandler)</span><br><span class="line">    ]</span><br><span class="line">    app &#x3D; tornado.web.Application(handlers&#x3D;handlers)</span><br><span class="line">    http_server &#x3D; tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>user目录下是 ice 相关的文件和配置，内容分别如下：</p><p>server.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 10:00 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import Ice</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">Ice.loadSlice(&quot;..&#x2F;Test.ice&quot;)</span><br><span class="line">import Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_resp(status&#x3D;None, msg&#x3D;None, data&#x3D;None):</span><br><span class="line">    &quot;&quot;&quot;获取响应信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    resp &#x3D; dict()</span><br><span class="line">    resp[&quot;status&quot;] &#x3D; status if status else &#39;10000&#39;</span><br><span class="line">    resp[&quot;msg&quot;] &#x3D; msg if msg else &#39;ok&#39;</span><br><span class="line">    resp[&quot;data&quot;] &#x3D; data if data else &#123;&#125;</span><br><span class="line">    return resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserI(Test.User):</span><br><span class="line"></span><br><span class="line">    def printStr(self, s, current&#x3D;None):</span><br><span class="line">        print(&quot;hello ice&quot;)</span><br><span class="line"></span><br><span class="line">    def addMun(self, n1, n2, current&#x3D;None):</span><br><span class="line">        ret &#x3D; n1 + n2</span><br><span class="line">        print(&quot;addMun result is:&quot;, ret)</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    def invoke(self, path, params, current&#x3D;None):</span><br><span class="line">        &quot;&quot;&quot;调用具体业务逻辑</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        user &#x3D; ViewUser()</span><br><span class="line"></span><br><span class="line">        params &#x3D; json.loads(params)</span><br><span class="line"></span><br><span class="line">        map &#x3D; &#123;</span><br><span class="line">            &quot;user&#x2F;list&quot;: user.list,</span><br><span class="line">            &quot;user&#x2F;detail&quot;: user.detail,</span><br><span class="line">            &quot;user&#x2F;add&quot;: user.add</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resp &#x3D; map.get(path, user.others)(params)</span><br><span class="line">        return resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ViewUser():</span><br><span class="line"></span><br><span class="line">    def list(self, params):</span><br><span class="line">        resp &#x3D; get_resp(data&#x3D;&#123;&quot;url&quot;: &quot;user&#x2F;list&quot;&#125;)</span><br><span class="line">        print(&quot;user list:&quot;, params)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line">    def detail(self, params):</span><br><span class="line">        resp &#x3D; get_resp(data&#x3D;&#123;&quot;url&quot;: &quot;user&#x2F;detail&quot;&#125;)</span><br><span class="line">        print(&quot;user detail:&quot;, params)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line">    def add(self, params):</span><br><span class="line">        resp &#x3D; get_resp(data&#x3D;&#123;&quot;url&quot;: &quot;user&#x2F;add&quot;&#125;)</span><br><span class="line">        print(&quot;user add:&quot;, params)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line">    def others(self, params):</span><br><span class="line">        resp &#x3D; get_resp(&#39;10001&#39;, &#39;not found&#39;)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with Ice.initialize(sys.argv, &quot;server.ini&quot;) as communicator:</span><br><span class="line">    adapter &#x3D; communicator.createObjectAdapter(&quot;User&quot;)</span><br><span class="line">    adapter.add(UserI(), Ice.stringToIdentity(&quot;user&quot;))</span><br><span class="line">    adapter.activate()</span><br><span class="line">    communicator.waitForShutdown()</span><br></pre></td></tr></table></figure><p>client.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 10:00 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import Ice</span><br><span class="line"></span><br><span class="line">Ice.loadSlice(&quot;Test.ice&quot;)</span><br><span class="line">import Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IceCommunicator:</span><br><span class="line"></span><br><span class="line">    def init(self):</span><br><span class="line">        communicator &#x3D; Ice.initialize(sys.argv, &#39;user&#x2F;client.ini&#39;)</span><br><span class="line">        user &#x3D; Test.UserPrx.checkedCast(communicator.propertyToProxy(&#39;User.Proxy&#39;)</span><br><span class="line">                                        .ice_twoway()</span><br><span class="line">                                        .ice_secure(False))</span><br><span class="line">        if not user:</span><br><span class="line">            print(&quot;invalid proxy&quot;)</span><br><span class="line">            sys.exit(1)</span><br><span class="line"></span><br><span class="line">        return user</span><br></pre></td></tr></table></figure><p>server.ini：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User.Endpoints&#x3D;tcp -p 10000</span><br><span class="line">Ice.Default.Host&#x3D;localhost</span><br><span class="line">Ice.Warn.Connections&#x3D;1</span><br></pre></td></tr></table></figure><p>client.ini：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User.Proxy&#x3D;user:tcp -p 10000</span><br><span class="line">Ice.Default.Host&#x3D;localhost</span><br><span class="line">Ice.Warn.Connections&#x3D;1</span><br></pre></td></tr></table></figure><h2 id="demo执行流程"><a href="#demo执行流程" class="headerlink" title="demo执行流程"></a>demo执行流程</h2><p>执行流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. app.py 中接受 http 请求，并将请求转发到对应的 handler</span><br><span class="line">2. 在 hendler 中调用 ice 客户端向 ice 服务端发送请求，请求 ice 服务端时会传入请求 path 和参数</span><br><span class="line">3. ice 服务端根据不同的请求 path 执行不同的操作，并返回响应结果</span><br></pre></td></tr></table></figure><p>上面仅仅是一个小的 demo，后面还会更近一步研究两者的结合使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tornado 是 python 中的一个 http 框架，以异步高性能著称，zeroc-ice 是一个分布式的 rpc 框架，将两者结合使用，可以搭建高性能的 web 应用服务。&lt;/p&gt;
&lt;p&gt;下面写了一个小 demo，演示了如何在 tornado 中使用 ice。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="tornado" scheme="http://wyzane.gitee.io/blog/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>Python中多个装饰器的执行顺序</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/13/Python%E4%B8%AD%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/13/Python%E4%B8%AD%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2020-07-13T14:04:07.000Z</published>
    <updated>2020-07-13T14:17:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天总结下 Python 中多个装饰器的执行顺序。</p><a id="more"></a><p>装饰器代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper_out1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'--out11--'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner1</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"--in11--"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"--in12--"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    print(<span class="string">"--out12--"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper_out2</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'--out21--'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner2</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"--in21--"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"--in22--"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    print(<span class="string">"--out22"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper_out2</span></span><br><span class="line"><span class="meta">@wrapper_out1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"--test--"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>执行后，打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">--out11--</span><br><span class="line">--out12--</span><br><span class="line">--out21--</span><br><span class="line">--out22--</span><br><span class="line">--in21--</span><br><span class="line">--in11--</span><br><span class="line">--test--</span><br><span class="line">--in12--</span><br><span class="line">--in22--</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>执行顺序以图片形式展示如下：</p><p><img src="python01.png" alt="python01"></p><p>先进入离test函数最近的装饰器，由于装饰器中返回的是函数的函数名引用，并非真正调用函数，所以先打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--out11--</span><br><span class="line">--out12--</span><br><span class="line">--out21--</span><br><span class="line">--out22--</span><br></pre></td></tr></table></figure><p>到inner2后，func会真正执行函数，会调用 inner1() ,所以再打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--in21--</span><br><span class="line">--in11--</span><br></pre></td></tr></table></figure><p>到 inner1 中，func 会调用test函数，所以会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--test--</span><br></pre></td></tr></table></figure><p>再从各个函数出来后，会依次打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--in12--</span><br><span class="line">--in22--</span><br></pre></td></tr></table></figure><p>合起来就是上面的执行结果。</p><p>以上就是多个装饰器的执行顺序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天总结下 Python 中多个装饰器的执行顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="python" scheme="http://wyzane.gitee.io/blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>zeroc ice在python中的使用</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/11/zeroc-ice%E5%9C%A8python%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/11/zeroc-ice%E5%9C%A8python%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-11T01:54:26.000Z</published>
    <updated>2020-07-19T13:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>zeroc ice 指的是 zeroc 公司开发的一款网络通讯引擎 ice。ice 是一个面向对象的 RPC 框架，可以搭建分布式应用。最主要的一点，它是跨语言的，不管你使用 Python、Java 还是 C++、Ruby、C# 等开发语言，它都支持。还有一点，ice 提供了其他功能，包括：IceStorm（一种订阅服务，类似于消息队列）、IceGrid 等。</p><a id="more"></a><p>下面从安装、使用等几个方面介绍下 ice 在 python 中的使用。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装环境是 python3.6.9，ubuntu18.04。</p><h2 id="安装方式一"><a href="#安装方式一" class="headerlink" title="安装方式一"></a>安装方式一</h2><p>安装步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. sudo apt-get install openssl libssl-dev libbz2-dev</span><br><span class="line">    第一步安装不成功时，可以使用 aptitude 来安装需要的包：</span><br><span class="line">sudo apt-get install aptitude </span><br><span class="line">sudo aptitude install xxxxx</span><br><span class="line">2. 安装 ice for python: pip install zeroc-ice</span><br><span class="line">3. 安装 ice for linux</span><br><span class="line">1）将源码克隆到本地: git clone https:&#x2F;&#x2F;github.com&#x2F;zeroc-ice&#x2F;ice.git</span><br><span class="line">若网速太慢，可以先在码云上创建项目并将ice.git克隆过去，再从码云上克隆</span><br><span class="line">2）克隆完成后，切换分支到3.7: git checkout 3.7（安装3.7版本）</span><br><span class="line">3）编译：make supported-languages&#x3D;&#39;cpp python&#39; （只编译c++和python，还可以编译其他语言）</span><br><span class="line">4）安装：make install supported-languages&#x3D;&#39;cpp python&#39; prefix&#x3D;&#x2F;opt&#x2F;zeroc-ice </span><br><span class="line">5）配置环境变量：在 .zshrc 中添加配置: PATH&#x3D;$PATH:&#x2F;opt&#x2F;zeroc-ice&#x2F;bin</span><br><span class="line">6）执行命令: icegridnode -v，会输出响应版本</span><br><span class="line">4. 安装完成后，可以从 github 上克隆 ice-demos 来学习。</span><br></pre></td></tr></table></figure><h2 id="安装方式二"><a href="#安装方式二" class="headerlink" title="安装方式二"></a>安装方式二</h2><p>或者，可以按照 zeroc 官方文档进行安装，官方文档如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;zeroc.com&#x2F;downloads&#x2F;ice&#x2F;3.7&#x2F;python</span><br></pre></td></tr></table></figure><h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><p>首先简单介绍下 ice 中相关概念和一些基础知识。</p><h2 id="slice语言"><a href="#slice语言" class="headerlink" title="slice语言"></a>slice语言</h2><p>Slice (Specification Language for Ice) 是实现 Ice 协议的开发语言，它可以把 Ice 接口的实现翻译成不同的开发语言版本。对于不同的应用开发语言，有不同的映射规则。</p><p>Slice 提供一个基本的抽象机制用于分离接口和他们的实现。Slice 用于描述接口，建立客户端和服务端之间的关系。Slice的接口描述与具体实现语言无关，即它可以让你定义 client 和 server 之间的交互而不用关心具体的开发语言，例如 C++，Java、Python等。通过编译，可以把 Slice对接口的描述转换成不同的开发语言。</p><h2 id="client-与-server"><a href="#client-与-server" class="headerlink" title="client 与 server"></a>client 与 server</h2><p>在 ice 中，client 和 server 不是指一个应用系统的特定部分，它们是在一个持续请求中扮演不同角色，具有不同的功能。</p><p>client 会主动向 server 发送服务请求，而 server 端只能被动的接收请求，并针对请求，为 client 端提供不同的服务。通常，client 会主动向 server 端发起请求，也可以接收 server 端的回调通知，这样看来，client 既有 client 端属性也有 server 端属性。</p><p>client 和 server 的结构如下：</p><p><img src="Ice_Client_and_Server_Structure.gif" alt="Ice_Client_and_Server_Structure"></p><p>上面的结构中，有以下几部分。</p><h3 id="Ice-Core"><a href="#Ice-Core" class="headerlink" title="Ice Core"></a>Ice Core</h3><p>ice core 包含了 client 和 server 的运行时，用于支持远程通信。这部分包含了网络通信、线程、字节序及其他网络相关的代码实现，并与应用层代码分离开来。ice core 提供了一系列库供 client 和 server 端调用。</p><h3 id="Ice-API"><a href="#Ice-API" class="headerlink" title="Ice API"></a>Ice API</h3><p>ice 中通过 ice api 来访问 ice core，使用 ice api 来做一些基础工作，例如初始化和资源回收。ice api 对于 client 和 server 端来说没有什么区别。</p><h3 id="Proxy-Code"><a href="#Proxy-Code" class="headerlink" title="Proxy Code"></a>Proxy Code</h3><p>proxy code 部分是根据 slice 文件中定义的内容生成的，它规定了对象和数据的类型。proxy code 主要有两个功能：</p><ol><li>为 client 端提供向下调用的接口，在 proxy API 调用函数最终会向 server 端发送一个 RPC 消息，然后在服务端执行响应的目标函数</li><li>提供组包和解包代码，组包是序列化复杂数据结构的过程，例如为了在网络上传送，序列化一个序列或者字典。组包会将数据转换成一种标准的数据传输格式，并且不受字节序的影响。解包就是相反的过程。</li></ol><h3 id="Skeleton-Code"><a href="#Skeleton-Code" class="headerlink" title="Skeleton Code"></a>Skeleton Code</h3><p>skeleton code 与 proxy code 功能相似，只是它在 server 端发挥作用，proxy code 是在 client 端的。它提供了向上调用的接口，并且允许 ice 运行时将控制线程转换为应用代码。skeleton 中也包含组包和解包的功能，以便 server 端能接收 client 端传入的参数，并且向 client 端返回结果或者异常。</p><h3 id="Object-Adapter"><a href="#Object-Adapter" class="headerlink" title="Object Adapter"></a>Object Adapter</h3><p>object adapter 是 ice api 的一部分，它只在 server 端使用，它由如下几个功能：</p><ol><li>将客户端请求与编程语言中的特定方法映射，即 object adapter 会找到内存中具有特定标识的对象</li><li>object adapter 与传输协议有关，如果一个 object adapter 对应多个传输协议，server 就能提供多种服务</li><li>object adapter 可以生成 proxy（proxy 会被发送到 client 端）。object adapter 中记录了每个对象的类型、名称、传输信息。当 server 端想要创建 proxy 时，object adapter 能创建 proxy 而不需要知道具体细节。</li></ol><h2 id="Ice-Objects"><a href="#Ice-Objects" class="headerlink" title="Ice Objects"></a>Ice Objects</h2><p>简单来说，ice object 对象中定义了一些接口，通过调用这些接口，client 能向服务器发送请求。我的理解是（以 Python 为例），ice object 中定义了一些方法，这些方法实现了请求创建、数据传递、数据接收等功能；我们在 slice 文件中定义的接口，经过转换后是 ice object 的子类；server 端需要继承 ice object 的子类来实现具体的功能。</p><h2 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h2><p>通过 proxy，client 能与 ice object 关联起来，proxy 就类似于 ice object 的一个使者。当 client 想调用 ice object 中的某个功能时（其实就是某个方法），需要通过 proxy ，这时会执行以下流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 定位 ice object</span><br><span class="line">2. 激活 ice object</span><br><span class="line">3. 激活 server 端的 ice object</span><br><span class="line">4. 传递入参到 ice object 中</span><br><span class="line">5. 等待操作完成</span><br><span class="line">6. 把出参和结果返回给 client 端</span><br></pre></td></tr></table></figure><p>proxy 信息可以用一个字符串表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimplePrinter:default -p 10000</span><br></pre></td></tr></table></figure><p>这种字符串形式的 proxy 更加易于理解和存储。</p><p>proxy 还分为 Direct Proxy 和 Indirect Proxy。Direct Proxy 通常包括 proxy 对象名称和服务器地址，包括以下两类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. a protocol identifier (such TCP&#x2F;IP or UDP)</span><br><span class="line">2. a protocol-specific address (such as a host name and port number)</span><br></pre></td></tr></table></figure><p>Indirect Proxy 有两种形式，一种是仅仅提供对象名称（如：SimplePrinter），另一种是提供对象名称和对象适配器名称（如：SimplePrinter@PrinterAdapter）。</p><h2 id="Ice-Protocol"><a href="#Ice-Protocol" class="headerlink" title="Ice Protocol"></a>Ice Protocol</h2><p>ice能提供 RPC 协议，这些 RPC 协议可以使用多种底层协议，最常用的是TCP和UDP，但是ice也支持 Websocket, Bluetooth 和 Apple’s iAP。Ice还可以使用 SSL 协议对传输数据加密。</p><p>Ice 协议中定义了以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 定义了一些消息类型，例如请求\应答的消息类型</span><br><span class="line">2. 定义了状态机，确定客户端和服务端如何交换数据</span><br><span class="line">3. 定义编码规则，确定怎样表示数据类型</span><br><span class="line">4. 定义了消息类型的头部，包括消息类型、消息大小、使用的协议等。</span><br></pre></td></tr></table></figure><p>Ice也支持数据压缩，当客户端与服务端传输的数据量非常大时，这很有用。<br>Ice 协议非常适合创建高效的事件分发机制，因为它允许我们分发消息而不用关心消息内部的实现。<br>Ice 协议也支持双向的操作，即：如果服务端传输数据到客户端提供的回调对象上，回调过程可以通过客户端最初创建的连接来完成。</p><h2 id="Ice-Service"><a href="#Ice-Service" class="headerlink" title="Ice Service"></a>Ice Service</h2><p>对于开发分布式应用程序，Ice Core提供了一个复杂的 client-server 平台，然而，实际开发中不仅仅需要远程处理能力，也需要按需提供服务、向客户端分发代理、分发异步任务、向应用程序分发补丁等等。Ice 提供了以下服务来实现上面的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. IceGrid</span><br><span class="line">2. IceStorm</span><br><span class="line">3. IcePatch2</span><br><span class="line">4. Glacier2</span><br><span class="line">5. IceBridge</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的介绍中，我们可以发现，开发 ice 的 client 和 server 时，我们需要以下几个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. slice 文件</span><br><span class="line">2. ice object</span><br><span class="line">3. proxy code</span><br><span class="line">4. object adapter</span><br></pre></td></tr></table></figure><p>上面这些都会在下面的代码中体现出来，可以回想一下它们的功能分别是什么。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>安装完成后，首先看第一个使用的例子。</p><h2 id="编写-Slice-File"><a href="#编写-Slice-File" class="headerlink" title="编写 Slice File"></a>编写 Slice File</h2><p>开发时，首先要编写 slice 文件，slice 文件是与开发语言无关的。编写完成后，需要使用编译器将其转换成不同的开发语言，例如转换成 Python 时，就需要使用 slice2py。slice 文件里面的内容其实就是一些接口，server 端开发时需要编写 Python 类来实现这些接口。</p><p>Printer.ice：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module Demo</span><br><span class="line">&#123;</span><br><span class="line">    interface Printer</span><br><span class="line">    &#123;</span><br><span class="line">        void printString(string s);</span><br><span class="line"></span><br><span class="line">        int addMun(int num1, int num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中， Demo 是模块名称，Printer 是接口名称，接口里面是方法的定义。</p><p>编写完成后，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice2py Printer.ice</span><br></pre></td></tr></table></figure><p>执行完成后，会生成 Printer_ice.py 文件和 Demo 文件夹。Demo文件夹下的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── __init__.py</span><br><span class="line">└── __pycache__</span><br><span class="line">    └── __init__.cpython-36.pyc</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Demo&#x2F;__init__.py 内容如下：</span><br><span class="line"># Generated by slice2py - DO NOT EDIT!</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">import Ice</span><br><span class="line">Ice.updateModule(&quot;Demo&quot;)</span><br><span class="line"></span><br><span class="line"># Modules:</span><br><span class="line">import Printer_ice</span><br><span class="line"></span><br><span class="line"># Submodules:</span><br></pre></td></tr></table></figure><p>Printer_ice.py 文件中的内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright (c) ZeroC, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Ice version 3.7.4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;auto-generated&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Generated from file `Printer.ice'</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Warning: do not edit this file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;/auto-generated&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> version_info <span class="keyword">as</span> _version_info_</span><br><span class="line"><span class="keyword">import</span> Ice, IcePy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start of module Demo</span></span><br><span class="line">_M_Demo = Ice.openModule(<span class="string">'Demo'</span>)</span><br><span class="line">__name__ = <span class="string">'Demo'</span></span><br><span class="line"></span><br><span class="line">_M_Demo._t_Printer = IcePy.defineValue(<span class="string">'::Demo::Printer'</span>, Ice.Value, <span class="number">-1</span>, (), <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">None</span>, ())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'PrinterPrx'</span> <span class="keyword">not</span> <span class="keyword">in</span> _M_Demo.__dict__:</span><br><span class="line">    _M_Demo.PrinterPrx = Ice.createTempClass()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PrinterPrx</span><span class="params">(Ice.ObjectPrx)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printString</span><span class="params">(self, s, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.invoke(self, ((s, ), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printStringAsync</span><span class="params">(self, s, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.invokeAsync(self, ((s, ), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">begin_printString</span><span class="params">(self, s, _response=None, _ex=None, _sent=None, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.begin(self, ((s, ), _response, _ex, _sent, context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">end_printString</span><span class="params">(self, _r)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.end(self, _r)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addMun</span><span class="params">(self, num1, num2, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.invoke(self, ((num1, num2), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addMunAsync</span><span class="params">(self, num1, num2, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.invokeAsync(self, ((num1, num2), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">begin_addMun</span><span class="params">(self, num1, num2, _response=None, _ex=None, _sent=None, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.begin(self, ((num1, num2), _response, _ex, _sent, context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">end_addMun</span><span class="params">(self, _r)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.end(self, _r)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">checkedCast</span><span class="params">(proxy, facetOrContext=None, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.PrinterPrx.ice_checkedCast(proxy, <span class="string">'::Demo::Printer'</span>, facetOrContext, context)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">uncheckedCast</span><span class="params">(proxy, facet=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.PrinterPrx.ice_uncheckedCast(proxy, facet)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_staticId</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'::Demo::Printer'</span></span><br><span class="line">    _M_Demo._t_PrinterPrx = IcePy.defineProxy(<span class="string">'::Demo::Printer'</span>, PrinterPrx)</span><br><span class="line"></span><br><span class="line">    _M_Demo.PrinterPrx = PrinterPrx</span><br><span class="line">    <span class="keyword">del</span> PrinterPrx</span><br><span class="line"></span><br><span class="line">    _M_Demo.Printer = Ice.createTempClass()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Printer</span><span class="params">(Ice.Object)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_ids</span><span class="params">(self, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">'::Demo::Printer'</span>, <span class="string">'::Ice::Object'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_id</span><span class="params">(self, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'::Demo::Printer'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_staticId</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'::Demo::Printer'</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printString</span><span class="params">(self, s, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">"servant method 'printString' not implemented"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addMun</span><span class="params">(self, num1, num2, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">"servant method 'addMun' not implemented"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> IcePy.stringify(self, _M_Demo._t_PrinterDisp)</span><br><span class="line"></span><br><span class="line">        __repr__ = __str__</span><br><span class="line"></span><br><span class="line">    _M_Demo._t_PrinterDisp = IcePy.defineClass(<span class="string">'::Demo::Printer'</span>, Printer, (), <span class="literal">None</span>, ())</span><br><span class="line">    Printer._ice_type = _M_Demo._t_PrinterDisp</span><br><span class="line"></span><br><span class="line">    Printer._op_printString = IcePy.Operation(<span class="string">'printString'</span>, Ice.OperationMode.Normal, Ice.OperationMode.Normal, <span class="literal">False</span>, <span class="literal">None</span>, (), (((), IcePy._t_string, <span class="literal">False</span>, <span class="number">0</span>),), (), <span class="literal">None</span>, ())</span><br><span class="line">    Printer._op_addMun = IcePy.Operation(<span class="string">'addMun'</span>, Ice.OperationMode.Normal, Ice.OperationMode.Normal, <span class="literal">False</span>, <span class="literal">None</span>, (), (((), IcePy._t_int, <span class="literal">False</span>, <span class="number">0</span>), ((), IcePy._t_int, <span class="literal">False</span>, <span class="number">0</span>)), (), ((), IcePy._t_int, <span class="literal">False</span>, <span class="number">0</span>), ())</span><br><span class="line"></span><br><span class="line">    _M_Demo.Printer = Printer</span><br><span class="line">    <span class="keyword">del</span> Printer</span><br><span class="line"></span><br><span class="line"><span class="comment"># End of module Demo</span></span><br></pre></td></tr></table></figure><p>从上面的内容中可以看出，Printer_ice.py 中主要有两个 Python 类 PrinterPrx 和 Printer。</p><h2 id="编写-Server-端"><a href="#编写-Server-端" class="headerlink" title="编写 Server 端"></a>编写 Server 端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, Ice</span><br><span class="line"><span class="keyword">import</span> Demo</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterI</span><span class="params">(Demo.Printer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printString</span><span class="params">(self, s, current=None)</span>:</span></span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addMun</span><span class="params">(self, n1, n2, current=None)</span>:</span></span><br><span class="line">        ret = n1 + n2</span><br><span class="line">        print(ret)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> Ice.initialize(sys.argv) <span class="keyword">as</span> communicator:</span><br><span class="line">    adapter = communicator.createObjectAdapterWithEndpoints(<span class="string">"SimplePrinterAdapter"</span>, <span class="string">"default -p 10000"</span>)</span><br><span class="line">    object = PrinterI()</span><br><span class="line">    adapter.add(object, communicator.stringToIdentity(<span class="string">"SimplePrinter"</span>))</span><br><span class="line">    adapter.activate()</span><br><span class="line">    communicator.waitForShutdown()</span><br></pre></td></tr></table></figure><p>server 端的代码中主要有两部分：一个 Python 类 PrinterI，继承了 Demo.Printer 并实现了其中的方法；with 代码块。</p><p>with 代码块中的含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Ice.initialize()初始化 Ice 运行环境，返回一个Ice.Communicator对象，它是 Ice 运行时的主要对象</span><br><span class="line">2. communicator.createObjectAdapterWithEndpoints()创建一个 Object Adapter 对象，</span><br><span class="line">   &quot;SimplePrinterAdapter&quot;表示 Adapter 对象名称，&quot;default -p 10000&quot; 表示使用 TCP&#x2F;IP协议并监听10000端口</span><br><span class="line">3. object &#x3D; PrinterI() 表示实例化 Printer 接口的子类</span><br><span class="line">4. 调用 Adapter 对象的 add 方法，将实例化的对象绑定到 Adapter 中。add() 方法的第一个参数就是 PrinterI 类的对    象，第二个参数是给 PrinterI 对象指定一个名称，如果有多个实例化的对象时，每个对象的名称都不能相同</span><br><span class="line">5. adapter.activate() 表示启用 Adapter </span><br><span class="line">6. 最后，调用 communicator.waitForShutdown() 会阻塞直到服务关闭</span><br></pre></td></tr></table></figure><h2 id="编写-Client-端"><a href="#编写-Client-端" class="headerlink" title="编写 Client 端"></a>编写 Client 端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, Ice</span><br><span class="line"><span class="keyword">import</span> Demo</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> Ice.initialize(sys.argv) <span class="keyword">as</span> communicator:</span><br><span class="line">    base = communicator.stringToProxy(<span class="string">"SimplePrinter:default -p 10000"</span>)</span><br><span class="line">    printer = Demo.PrinterPrx.checkedCast(base)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> printer:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"Invalid proxy"</span>)</span><br><span class="line"> </span><br><span class="line">    printer.printString(<span class="string">"Hello World!"</span>)</span><br><span class="line">    ret = printer.addMun(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"client:"</span>, ret)</span><br></pre></td></tr></table></figure><p>client 中只有一个 with 代码块，其含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Ice.initialize()：初始化 Ice 运行环境</span><br><span class="line">2. communicator.stringToProxy()：获得远端 printer 的一个代理对象，参数 &quot;SimplePrinter:default -p 10000&quot;    表示在服务端指定的 printer 对象名称和监听端口</span><br><span class="line">3. stringToProxy()方法返回的是一个Ice.ObjectPrx类型，它是其他所有接口的父类。但是，实际上我们是需要一个          Demo.Printer 类型，所以需要类型向下的转换。使用 Demo.PrinterPrx.checkedCast(base) 可以向服务器发送消息，    确认代理是否是 Demo.Printer类型，如果是，就返回一个 Demo.PrinterPrx 类型的代理，否则返回None</span><br><span class="line">4. printer.printString(&quot;Hello World!&quot;) 调用方法。</span><br></pre></td></tr></table></figure><p>编写完成后，执行 Python 文件就行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python server.py</span><br><span class="line">python client.py</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zeroc ice 指的是 zeroc 公司开发的一款网络通讯引擎 ice。ice 是一个面向对象的 RPC 框架，可以搭建分布式应用。最主要的一点，它是跨语言的，不管你使用 Python、Java 还是 C++、Ruby、C# 等开发语言，它都支持。还有一点，ice 提供了其他功能，包括：IceStorm（一种订阅服务，类似于消息队列）、IceGrid 等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="python" scheme="http://wyzane.gitee.io/blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制的搭建</title>
    <link href="http://wyzane.gitee.io/blog/2020/07/04/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://wyzane.gitee.io/blog/2020/07/04/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2020-07-04T02:01:34.000Z</published>
    <updated>2024-02-02T06:20:07.420Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的主从复制是一个很有用的功能，在大型系统中，为了分担 Redis 的读写压力，可以使用主从复制功能。下面介绍下 Redis 主从复制的搭建。</p><a id="more"></a><h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><h2 id="Redis-持久化方式"><a href="#Redis-持久化方式" class="headerlink" title="Redis 持久化方式"></a>Redis 持久化方式</h2><p>先介绍下 Redis 的持久化方式。Redis 的持久化方式有两种 rdb和 aof，默认是 rdb 的方式。</p><h3 id="rdb-备份方式"><a href="#rdb-备份方式" class="headerlink" title="rdb 备份方式"></a>rdb 备份方式</h3><p>rdb 是半持久化的存储方式，它会定期将内存中数据保存到磁盘上，从而保证数据的持久化，永久保存Redis数据。它是通过快照（snapshotting）的方式完成的，当满足在 Redis.conf 配置文件中设置的条件时 Redis 会自动将内存中的所有数据进行快照并存储在硬盘上，完成数据备份。</p><p>Redis进行 rdb 快照的条件由用户在配置文件中自定义，由两个参数构成：时间和改动键的个数。当在指定时间内被更改键的个数大于指定的数值时就会进行快照。配置文件中默认预值了3个条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1       #900秒内有至少1个键被更改则进行快照；</span><br><span class="line">save 300 10      #300秒内有至少10个键被更改则进行快照；</span><br><span class="line">save 60  10000   #60秒内有至少10000个键被更改则进行快照</span><br></pre></td></tr></table></figure><p>默认可以存在多个条件，条件之间是“或”的关系，只要满足其中任意一个，就会进行快照备份数据。若想要禁用自动快照，只需删除所有save参数即可。</p><p>Redis 默认会将快照文件存储在 Redis 数据目录中，默认文件名是：dump.rdb，可通过配置dir和dbfilename两个参数来指定快照文件的存储路径和文件名。</p><p>Redis快照过程：Redis使用fork函数复制一份当前进程（父进程）的副本（子进程），父进程负责接收和处理客户端发来的命令，而子进程负责将内存中的数据写入硬盘中的临时文件，当子进程写完所有数据后会用该临时文件替换旧的 rdb 文件，至此一次快照操作完成。<br>rdb 文件是经过压缩的二进制格式，所以占用的空间会小于内存中的数据大小。除了自动快照，还可以手动发送SAVE和BGSAVE 命令让Redis执行快照。两个命令区别是：SAVE是由主进程进行快照操作，会阻塞其他请求，BGSAVE会通过fork 子进程进行快照操作。</p><p>手动执行备份：redis-cli bgsave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save  &#x2F;&#x2F; 手动备份</span><br><span class="line">bgsave  &#x2F;&#x2F; 手动备份</span><br><span class="line">config get dir  &#x2F;&#x2F; 获取redis的dir</span><br></pre></td></tr></table></figure><h3 id="aof-备份方式"><a href="#aof-备份方式" class="headerlink" title="aof 备份方式"></a>aof 备份方式</h3><p>aof 是全持久化的备份方式，使用这种方式，Redis 会实时将内存中数据刷到磁盘上，从而保证数据的持久化，永久保存Redi s数据。如果数据非常重要无法承受任何损失，可以使用 aof 方式进行持久化，默认 Redis 没有开启 aof（append only file）方式的全持久化模式。</p><p>在启动时 Redis 会逐个执行 apf 文件中的命令来将硬盘中的数据载入到内存中，载入的速度相对于 rdb 方式慢些，开启 aof 持久化后每执行一条都会更改Redis中的数据的命令，Redis就会将命令写入硬盘中的 aof 文件。</p><p>Redis允许同时开启 aof 和 rdb ，既保证了数据安全又使得进行备份等操作十分容易。</p><p>Redis aof持久化参数配置详解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly  yes                   #开启AOF持久化功能；</span><br><span class="line">appendfilenameappendonly.aof      #AOF持久化保存文件名；</span><br><span class="line">appendfsyncalways                 #每次执行写入都会执行同步，最安全也最慢；</span><br><span class="line">#appendfsynceverysec              #每秒执行一次同步操作；</span><br><span class="line">#appendfsyncno                    #不主动进行同步操作，而是完全交由操作系统来做，每30秒一次，最快也最不安全；</span><br><span class="line">auto-aof-rewrite-percentage  100  #当AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据；</span><br><span class="line">auto-aof-rewrite-min-size    64mb #允许重写的最小AOF文件大小配置写入AOF文件后，要求系统刷新硬盘缓存的机制。</span><br></pre></td></tr></table></figure><p>在配置文件中进行以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>aof 刷新日志到disk的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always   #always 表示每次有写操作都进行同步，非常慢，非常安全。</span><br><span class="line">appendfsync everysec #everysec表示对写操作进行累积，每秒同步一次</span><br></pre></td></tr></table></figure><p>官方的建议的everysec，安全，就是速度不够快，如果是机器出现问题可能会丢失1秒的数据。</p><p>手动执行备份：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli bgrewriteaof</span><br></pre></td></tr></table></figure><h2 id="主从数据同步"><a href="#主从数据同步" class="headerlink" title="主从数据同步"></a>主从数据同步</h2><p>当 slave 初始化的时候，会将 master 上的数据复制一份到自己服务器上。此后，每当 master 新增数据后，都会将写命令发送一份到 slave 上，slave 接收到写命令后将数据写入。我们可以通过 monitor 命令来看 slave 的写入过程。</p><p>例如：当 master 执行 set name wyzane 后，使用 monitor 查看到 slave 的执行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1593857563.031330 [0 192.168.0.105:6379] &quot;PING&quot;</span><br><span class="line">1593857553.918113 [0 192.168.0.105:6379] &quot;set&quot; &quot;name&quot; &quot;wyzane&quot;</span><br><span class="line">1593857563.031330 [0 192.168.0.105:6379] &quot;PING&quot;</span><br></pre></td></tr></table></figure><h1 id="主从复制搭建"><a href="#主从复制搭建" class="headerlink" title="主从复制搭建"></a>主从复制搭建</h1><p>下面在一个服务器上开启三个 Redis 进程为例，来介绍下主从复制的搭建过程。</p><h2 id="不需要权限校验的主从复制"><a href="#不需要权限校验的主从复制" class="headerlink" title="不需要权限校验的主从复制"></a>不需要权限校验的主从复制</h2><p>配置的时候，需要修改 Redis .conf 配置文件，master 和 slave 的配置分别如下。其中，protected-mode no 表示 slave 连接 master 时不需要密码校验。</p><p>master配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.0.105</span><br><span class="line">protected-mode no</span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure><p>slqve1 的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.0.105</span><br><span class="line">slaveof 192.168.0.105 6379</span><br><span class="line">protected-mode no</span><br><span class="line">port 6380</span><br></pre></td></tr></table></figure><p>slave2 的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.0.105</span><br><span class="line">slaveof 192.168.0.105 6379</span><br><span class="line">protected-mode no</span><br><span class="line">port 6381</span><br></pre></td></tr></table></figure><p>配置完成后，执行以下命令启动这三个服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf （master）</span><br><span class="line">redis-server redis2.conf （slave1）</span><br><span class="line">redis-server redis3.conf （slave2）</span><br></pre></td></tr></table></figure><p>服务启动后，需要连接这三个服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.0.105 -p 6379</span><br><span class="line">redis-cli -h 192.168.0.105 -p 6380</span><br><span class="line">redis-cli -h 192.168.0.105 -p 6381</span><br></pre></td></tr></table></figure><p>连接上客户端，在 master 上 set 数据后，可以分别在 slave1、slave2 上看到这些数据。</p><h2 id="权限校验的主从配置"><a href="#权限校验的主从配置" class="headerlink" title="权限校验的主从配置"></a>权限校验的主从配置</h2><p>在生产环境上，为了保证安全性，权限校验是非常重要的。所以，我们配置主从复制时，一定要把权限校验的功能加上去。权限校验首先需要把 master redis.conf 中的 protected-mode 值设置为 yes（默认），然后再设置密码。设置密码的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected-mode yes</span><br><span class="line">requirepass wyzane  # wyzane 就是密码</span><br></pre></td></tr></table></figure><p>设置完成后，使用 redis-cli 时，需要执行 auth wyzane， 即输入密码。</p><p>slave1 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth wyzane</span><br></pre></td></tr></table></figure><p>slave2 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth wyzane</span><br></pre></td></tr></table></figure><p>设置完成后，重启 Redis 服务就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 的主从复制是一个很有用的功能，在大型系统中，为了分担 Redis 的读写压力，可以使用主从复制功能。下面介绍下 Redis 主从复制的搭建。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="Redis" scheme="http://wyzane.gitee.io/blog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>svn的简单使用</title>
    <link href="http://wyzane.gitee.io/blog/2020/06/27/svn%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://wyzane.gitee.io/blog/2020/06/27/svn%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-27T07:29:17.000Z</published>
    <updated>2020-06-27T13:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>与 git 一样，svn （Subversion）也是一个开源的版本控制系统，相比于 git 的分布式管理，svn是一个集中式的版本管理工具。今天介绍下它的简单使用。</p><a id="more"></a><p>svn 是集中式的版本管理工具，它依赖于 svn 服务器，所有的版本信息都保存在服务器上。</p><h1 id="svn使用总结"><a href="#svn使用总结" class="headerlink" title="svn使用总结"></a>svn使用总结</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>svn的使用步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">ubuntu安装svn</span><br><span class="line">1. apt-get update</span><br><span class="line">2. apt-get install subversion</span><br><span class="line">安装完成后，可以执行 svnserve --version 查看版本信息</span><br><span class="line"></span><br><span class="line">创建版本库：</span><br><span class="line">1. 在 &#x2F;home&#x2F;wyzane 下创建 svn 目录（作为中央仓库）</span><br><span class="line">2. 创建仓库：svnadmin create &#x2F;home&#x2F;wyzane&#x2F;svn</span><br><span class="line">3. 创建完成后，在 svn 下会生成 conf、db 等目录</span><br><span class="line">目录结构如下：</span><br><span class="line">        .</span><br><span class="line">        ├── conf</span><br><span class="line">        │   ├── authz</span><br><span class="line">        │   ├── hooks-env.tmpl</span><br><span class="line">        │   ├── passwd</span><br><span class="line">        │   └── svnserve.conf</span><br><span class="line">        ├── db</span><br><span class="line">        │   ├── current</span><br><span class="line">        │   ├── format</span><br><span class="line">        │   ├── fsfs.conf</span><br><span class="line">        │   ├── fs-type</span><br><span class="line">        │   ├── min-unpacked-rev</span><br><span class="line">        │   ├── rep-cache.db</span><br><span class="line">        │   ├── rep-cache.db-journal</span><br><span class="line">        │   ├── revprops</span><br><span class="line">        │   ├── revs</span><br><span class="line">        │   ├── transactions</span><br><span class="line">        │   ├── txn-current</span><br><span class="line">        │   ├── txn-current-lock</span><br><span class="line">        │   ├── txn-protorevs</span><br><span class="line">        │   ├── uuid</span><br><span class="line">        │   └── write-lock</span><br><span class="line">        ├── format</span><br><span class="line">        ├── hooks</span><br><span class="line">        │   ├── post-commit.tmpl</span><br><span class="line">        │   ├── post-lock.tmpl</span><br><span class="line">        │   ├── post-revprop-change.tmpl</span><br><span class="line">        │   ├── post-unlock.tmpl</span><br><span class="line">        │   ├── pre-commit.tmpl</span><br><span class="line">        │   ├── pre-lock.tmpl</span><br><span class="line">        │   ├── pre-revprop-change.tmpl</span><br><span class="line">        │   ├── pre-unlock.tmpl</span><br><span class="line">        │   └── start-commit.tmpl</span><br><span class="line">        ├── locks</span><br><span class="line">        │   ├── db.lock</span><br><span class="line">        │   └── db-logs.lock</span><br><span class="line">        └── README.txt</span><br><span class="line">其中，conf目录下存放了配置文件，passwd 是用户配置文件，可以配置用户名和密码。authz 是权限配置文件，可以配置用户对应的读写权限，也可以对用户进行分组配置。svnserve.conf 是基本的配置文件。</span><br><span class="line"></span><br><span class="line">启动服务：</span><br><span class="line">svnserve -d -r &#x2F;home&#x2F;wyzane&#x2F;svn  (默认端口 3690)</span><br><span class="line">其中：</span><br><span class="line">-d：表示在后台运行</span><br><span class="line">-r：指定服务器的根目录</span><br><span class="line">查看进程：ps aux | grep svnserve</span><br><span class="line"></span><br><span class="line">客户端 checkout 代码需要执行以下命令：</span><br><span class="line">svn checkout svn:&#x2F;&#x2F;192.168.0.105&#x2F; --username wyzane</span><br></pre></td></tr></table></figure><p>在 windows 下使用时，我们可以下载 svn 的 windows 版本进行安装，下载地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;subversion.apache.org&#x2F;packages.html</span><br></pre></td></tr></table></figure><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 首先创建 branches 目录并提交</span><br><span class="line">2. 创建分支：svn copy trunk&#x2F; branches&#x2F;sub，并使用 svn commit 提交（基于 trunk 的分支）</span><br><span class="line">3. 修改 sub 分支上的内容并提交</span><br><span class="line">4. 合并分支：切换到 trunk 目录，执行svn merge ..&#x2F;branches&#x2F;sub&#x2F;</span><br><span class="line">5. 提交合并后的内容：svn commit -m &quot;update&quot;</span><br></pre></td></tr></table></figure><h2 id="tag操作"><a href="#tag操作" class="headerlink" title="tag操作"></a>tag操作</h2><p>通过 tag 标签，可以给某一具体的版本加上一个有意义的名称，便于更好的管理，tag 的使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 创建 tags 目录并提交：mkdir tags &amp; svn add tags &amp; svn commit -m &quot;commit tags dir&quot;</span><br><span class="line">2. 在当前的 trunk 版本上打一个 tag：svn copy trunk&#x2F; tags&#x2F;v1.0</span><br><span class="line">3. 提交到版本库：svn commit -m &quot;v1.0&quot;</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">svn add test.txt   # 添加文件到版本库中</span><br><span class="line">A         test.txt</span><br><span class="line">svn status         # 查看状态</span><br><span class="line">A       test.txt  </span><br><span class="line">svn commit -m &quot;update&quot;   # 将改动的文件提交到版本库，此时再使用 svn status 时，就不会有输出信息了</span><br><span class="line"></span><br><span class="line">svn update  # 更新版本哭的改动到本地</span><br><span class="line"></span><br><span class="line">svn log   # 查看版本库的提交历史</span><br></pre></td></tr></table></figure><h1 id="使用时可能的错误"><a href="#使用时可能的错误" class="headerlink" title="使用时可能的错误"></a>使用时可能的错误</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. commit failed， 没有找到事务5-9</span><br><span class="line">解决：这是因为 svnserve 的服务没有开启，启动 svnserve 即可。</span><br><span class="line"></span><br><span class="line">2. the error was 条目不可读</span><br><span class="line">解决：配置文件中修改 anon-access 的值为 none，然后重启即可</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与 git 一样，svn （Subversion）也是一个开源的版本控制系统，相比于 git 的分布式管理，svn是一个集中式的版本管理工具。今天介绍下它的简单使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wyzane.gitee.io/blog/categories/Python/"/>
    
    
      <category term="SVN" scheme="http://wyzane.gitee.io/blog/tags/SVN/"/>
    
  </entry>
  
</feed>
