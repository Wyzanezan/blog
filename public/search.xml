<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020书单</title>
    <url>/blog/2020/05/30/2020%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<p>2020年，新的开始，计划会读以下书籍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《终身成长》 [美]卡罗尔-德韦克 </span><br><span class="line">《如何才能不焦虑》 [美]克里斯多夫-科特曼 [美]哈洛-辛尼斯基 [美]劳里-安-奥康娜</span><br><span class="line">《深度工作：如何有效使用每一点脑力》 [美]卡尔-纽波特</span><br></pre></td></tr></table></figure>

<p>书目后面还可能会增加。</p>
<p>每读完一本，会整理一份读书笔记分享给大家。有时间也会整理2020年之前的读书笔记并分享。</p>
<p>2020年，继续加油吧！</p>
]]></content>
      <categories>
        <category>reader</category>
      </categories>
      <tags>
        <tag>reader</tag>
      </tags>
  </entry>
  <entry>
    <title>Django3.0新功能介绍</title>
    <url>/blog/2019/12/08/Django3-0%E6%96%B0%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>最近，Django框架发布了3.0版本，同时为我们带来了一些新功能，其中最引人注目的一个新功能就是对异步的原生支持。</p>
<a id="more"></a>

<p>Django3.0版本发布说明：<a href="https://docs.djangoproject.com/en/3.0/releases/3.0/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.0/releases/3.0/</a></p>
<p>Django3.0仅支持Python3.6及以上的版本，不再支持Python3.5及以下的Python版本。</p>
<p>下面，介绍下Django3.0中的新功能。</p>
<h3 id="支持MariaDB"><a href="#支持MariaDB" class="headerlink" title="支持MariaDB"></a>支持MariaDB</h3><p>Django官方开始支持MariaDB10.1（MariaDB数据库管理系统是MySQL的一个分支，是MySQL的开源版本）及其更高版本。</p>
<h3 id="支持ASGI协议"><a href="#支持ASGI协议" class="headerlink" title="支持ASGI协议"></a>支持ASGI协议</h3><p>通常我们开发Django应用时，使用WSGI协议，它是Python的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。而ASGI协议是对WSGI的扩展，它在WSGI的基础上定义了实现异步通信的方式，遵循ASGI协议的Web程序可以实现异步通信。</p>
<p>以前我们在Django中实现异步通信,需要借助channels等第三方包。现在，Django3.0可以运行为一个ASGI应用程序，从而实现对异步的支持；即应用程序运行在ASGI协议下时，可以使用异步特性，运行在其他协议下则不能使用这个特性。</p>
<p>支持ASGI协议可能也会有负面影响，当你的代码中有异步非安全的的操作时（例如ORM操作），Django会阻塞代码的执行。当代码中抛出 <strong>SynchronousOnlyOperation</strong> 异常时，你应该检查异步代码并移除其中的数据库操作部分。</p>
<h3 id="支持PostgreSQL建立排他约束"><a href="#支持PostgreSQL建立排他约束" class="headerlink" title="支持PostgreSQL建立排他约束"></a>支持PostgreSQL建立排他约束</h3><p>ExclusionConstraint类可以在pg数据库上添加排他约束，将约束添加到Meta.constraints中，像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        constraints = [</span><br><span class="line">            models.CheckConstraint(check=models.Q(age__gte=<span class="number">18</span>), name=<span class="string">'age_gte_18'</span>),</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>



<h3 id="field-choice支持枚举类型"><a href="#field-choice支持枚举类型" class="headerlink" title="field choice支持枚举类型"></a>field choice支持枚举类型</h3><p> <strong>TextChoices</strong>， <strong>IntegerChoices</strong>, 和 <strong>Choices</strong>等枚举类型可以用来定义<strong>Field.choise</strong>。下面是具体使用方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TextChoices</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">YearInSchool</span><span class="params">(models.TextChoices)</span>:</span></span><br><span class="line">        FRESHMAN = <span class="string">'FR'</span>, _(<span class="string">'Freshman'</span>)</span><br><span class="line">        SOPHOMORE = <span class="string">'SO'</span>, _(<span class="string">'Sophomore'</span>)</span><br><span class="line">        JUNIOR = <span class="string">'JR'</span>, _(<span class="string">'Junior'</span>)</span><br><span class="line">        SENIOR = <span class="string">'SR'</span>, _(<span class="string">'Senior'</span>)</span><br><span class="line">        GRADUATE = <span class="string">'GR'</span>, _(<span class="string">'Graduate'</span>)</span><br><span class="line"></span><br><span class="line">    year_in_school = models.CharField(</span><br><span class="line">        max_length=<span class="number">2</span>,</span><br><span class="line">        choices=YearInSchool.choices,</span><br><span class="line">        default=YearInSchool.FRESHMAN,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># IntegerChoices</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Suit</span><span class="params">(models.IntegerChoices)</span>:</span></span><br><span class="line">        DIAMOND = <span class="number">1</span></span><br><span class="line">        SPADE = <span class="number">2</span></span><br><span class="line">        HEART = <span class="number">3</span></span><br><span class="line">        CLUB = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    suit = models.IntegerField(choices=Suit.choices)</span><br></pre></td></tr></table></figure>



<p>Django3.0中主要新增主要特性就是上面这些，主要特性具体信息、新增次要特性及向后不兼容的功能（不再支持pg9.4,和oracle12.1等）可以点击上面的链接查看。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6部分语法介绍</title>
    <url>/blog/2020/05/17/ES6%E9%83%A8%E5%88%86%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>ES6是 ECMAScript 6 的简称，它是JavaScript语言的下一代标准，已经在2015年6月正式发布了。今天介绍下ES6中有哪些新语法。</p>
<a id="more"></a>

<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建如下目录结构：</span><br><span class="line">ES6test</span><br><span class="line">	dist</span><br><span class="line">	src</span><br><span class="line">		index.js</span><br><span class="line">	index.html</span><br></pre></td></tr></table></figure>

<p>index.js中的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 1;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>

<p>在终端执行 npm init -y 后，会生成 package.json 文件，文件内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"ES6test"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>, </span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此时，我们还需要把此处的 ES6 语法的代码转换成 ES5 才能执行，所以需要一个转换的插件（例如 webpack）。这里我们使用 Babel 进行转换。全局安装 Babel：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g babel-cli</span><br><span class="line"></span><br><span class="line">此外，还需要安装以下插件</span><br><span class="line">npm install --save-dev babel-preset-es2015 babel-cli</span><br></pre></td></tr></table></figure>

<p>安装完成后，package.json 文件中多了以下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">   "babel-cli": "^6.26.0",</span><br><span class="line">   "babel-preset-es2015": "^6.24.1"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在根目录下创建 .babelrc 文件，并输入一下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        <span class="string">"es2015"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后就可以执行转换命令把  es6 的代码转换成 es5 的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">babel src&#x2F;index.js -o dist&#x2F;index.js</span><br></pre></td></tr></table></figure>

<p>执行完成后，dist/index.js 文件的内容为（转换成了es5的写法）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>



<p>可以配置 npm 命令来简化转换操作，修改 package.json 文件，添加如下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">	"build": "babel src/index.js -o dist/index.js"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>此时，执行 npm run build 命令就可以进行打包。</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">声明方式：</span><br><span class="line">var 全局声明</span><br><span class="line">let 局部声明</span><br><span class="line">const 常量</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"wyzane"</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">"wz"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// wz</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"wyzane"</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"wz"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// wyzane</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"wyzane"</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"wz"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// wyzane</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"wyzane"</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="string">"wz"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// wz</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"wz"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 抛异常 a is not defined</span></span><br></pre></td></tr></table></figure>



<p>使用 var 时，数据容易被污染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner: "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer: "</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出如下</span></span><br><span class="line"><span class="comment">inner: 0</span></span><br><span class="line"><span class="comment">index.js:4 inner: 1</span></span><br><span class="line"><span class="comment">index.js:4 inner: 2</span></span><br><span class="line"><span class="comment">index.js:4 inner: 3</span></span><br><span class="line"><span class="comment">index.js:4 inner: 4</span></span><br><span class="line"><span class="comment">index.js:4 inner: 5</span></span><br><span class="line"><span class="comment">index.js:4 inner: 6</span></span><br><span class="line"><span class="comment">index.js:4 inner: 7</span></span><br><span class="line"><span class="comment">index.js:4 inner: 8</span></span><br><span class="line"><span class="comment">index.js:4 inner: 9</span></span><br><span class="line"><span class="comment">index.js:6 outer: 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此时循环体外的变量容易被污染</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p>使用 let 时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner: "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer: "</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出为：</span></span><br><span class="line"><span class="comment">inner: 0</span></span><br><span class="line"><span class="comment">index.js:4 inner: 1</span></span><br><span class="line"><span class="comment">index.js:4 inner: 2</span></span><br><span class="line"><span class="comment">index.js:4 inner: 3</span></span><br><span class="line"><span class="comment">index.js:4 inner: 4</span></span><br><span class="line"><span class="comment">index.js:4 inner: 5</span></span><br><span class="line"><span class="comment">index.js:4 inner: 6</span></span><br><span class="line"><span class="comment">index.js:4 inner: 7</span></span><br><span class="line"><span class="comment">index.js:4 inner: 8</span></span><br><span class="line"><span class="comment">index.js:4 inner: 9</span></span><br><span class="line"><span class="comment">index.js:6 Uncaught ReferenceError: i is not defined</span></span><br><span class="line"><span class="comment">    at index.js:6</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h2 id="变量解构赋值"><a href="#变量解构赋值" class="headerlink" title="变量解构赋值"></a>变量解构赋值</h2><p>数组解构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">解构的时候定义默认值：</span><br><span class="line"><span class="keyword">let</span> [a, b, c=<span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c);  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">0</span>, b, c] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 与 null 在解构时的区别</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c=<span class="number">6</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">undefined</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b, c=<span class="number">6</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>对象解构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象的解构是根据属性名称进行对应的</span><br><span class="line"><span class="keyword">let</span> &#123;name1, name2&#125; = &#123;<span class="string">'name2'</span>: <span class="string">'wyzane'</span>, <span class="string">'name1'</span>: <span class="string">'wz'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(name1); <span class="comment">// wz</span></span><br><span class="line"><span class="built_in">console</span>.log(name2); <span class="comment">// wyzane</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个小坑：</span><br><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line">&#123;foo&#125; = &#123;<span class="attr">foo</span>: <span class="string">'wyzane'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line">上面的解构方式会报错，应该使用下面的方式：</span><br><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line">(&#123;foo&#125; = &#123;<span class="attr">foo</span>: <span class="string">'wyzane'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br></pre></td></tr></table></figure>

<p>字符串解构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="string">'nihao'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// n</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// h</span></span><br></pre></td></tr></table></figure>



<h2 id="对象扩展运算符"><a href="#对象扩展运算符" class="headerlink" title="对象扩展运算符"></a>对象扩展运算符</h2><p>对象扩展运算符使用 … 表示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象扩展运算符用在函数不确定参数个数的时候，例子如下：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args[<span class="number">0</span>]);  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(args[<span class="number">1</span>]);  <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(args[<span class="number">2</span>]);  <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(args[<span class="number">3</span>]);  <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = a1;</span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// ['1', '2', '3']</span></span><br><span class="line">a2.push(<span class="string">'4'</span>);</span><br><span class="line"><span class="comment">// a1的值已改变</span></span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// ['1', '2', '3', '4']</span></span><br><span class="line"><span class="comment">// 下面使用 ... 解决上面的问题</span></span><br><span class="line"><span class="keyword">let</span> a1 = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = [...a1];</span><br><span class="line"><span class="built_in">console</span>.log(a1);  <span class="comment">// ['1', '2', '3']</span></span><br><span class="line">a2.push(<span class="string">'4'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1);  <span class="comment">// ['1', '2', '3']</span></span><br></pre></td></tr></table></figure>



<h2 id="rest运算符"><a href="#rest运算符" class="headerlink" title="rest运算符"></a>rest运算符</h2><p>与对象扩展运算符类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当函数参数前几个确定，后面的不确定时，可以使用rest运算符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">f, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args.length);  <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">console</span>.log(args[<span class="number">0</span>]);  <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// es6中的 for ... of ... 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> args) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>



<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>创建一个node项目的步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 执行 npm init 初始化项目</span><br><span class="line">2. 执行 cnpm install -g live-server 安装live-server作为前端服务器</span><br></pre></td></tr></table></figure>



<p>字符串模板的使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'wyuzane'</span>;</span><br><span class="line"><span class="comment">// es5字符串拼接写法</span></span><br><span class="line"><span class="keyword">let</span> info = <span class="string">'你们好呀，我是'</span> + name + <span class="string">'，欢迎来到学习园地'</span>;</span><br><span class="line"><span class="comment">// es6语法，字符串中可以含有html标签</span></span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`你们好呀，我是<span class="subst">$&#123;name&#125;</span>，欢迎来到学习园地`</span>;</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`你们好呀，我是<span class="subst">$&#123;name&#125;</span>，&lt;br&gt;欢迎来到学习园地`</span>;</span><br><span class="line"><span class="built_in">document</span>.write(info);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串模板支持简单运算：</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">`<span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">document</span>.write(c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串查找操作：</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'wyzane'</span>;</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">'你们好呀，我是wyzane，欢迎来到学习园地'</span>;</span><br><span class="line"><span class="comment">// es5中查找字符串</span></span><br><span class="line"><span class="built_in">document</span>.write(info.indexOf(name)); <span class="comment">// 7</span></span><br><span class="line"><span class="comment">// es6中判断子字符串是否存在</span></span><br><span class="line"><span class="built_in">document</span>.write(info.includes(name)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 还有 startsWith()、endsWith() 等方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串复制操作：</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'wyzane | '</span>.repeat(<span class="number">3</span>));  <span class="comment">// wyzane | wyzane | wyzane |</span></span><br></pre></td></tr></table></figure>





<h2 id="数字操作"><a href="#数字操作" class="headerlink" title="数字操作"></a>数字操作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二进制声明</span></span><br><span class="line"><span class="keyword">let</span> binary = <span class="number">0B010101</span>;</span><br><span class="line"><span class="built_in">console</span>.log(binary);  <span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制声明</span></span><br><span class="line"><span class="keyword">let</span> octal = <span class="number">0O666</span>;</span><br><span class="line"><span class="built_in">console</span>.log(octal);  <span class="comment">// 438</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字判断，判断变量的值是否是数字</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">11</span>/<span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(a));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="string">'wyzane'</span>));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为 NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="string">'wyzane'</span>));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是整数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(a));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(b));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字转换</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2.531</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.parseInt(a));  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.parseFloat(b));  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6中提供了一个最大安全整数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_SAFE_INTEGER);  <span class="comment">// 9007199254740991  即 2的53次方减1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>);  <span class="comment">// 9007199254740991</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小安全整数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_SAFE_INTEGER);  <span class="comment">// -9007199254740991</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断整数是否超过最大范围</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">123</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="数组1"><a href="#数组1" class="headerlink" title="数组1"></a>数组1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将json数组转换成数组</span></span><br><span class="line"><span class="comment">// json数组</span></span><br><span class="line"><span class="keyword">let</span> json = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'wyzane1'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'wyzane2'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'wyzane3'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// from() 方法将json数组转换成数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(json);</span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// ["wyzane1", "wyzane2", "wyzane3"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// of() 方法</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// [3, 4, 5, 6]</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="string">'qw'</span>, <span class="string">'er'</span>, <span class="string">'rt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// ["qw", "er", "rt"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// es5中将字符串转换为数组</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'[3, 4, 5, 6]'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(a));  <span class="comment">// [3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// find() 实例方法，该方法的参数是一个匿名函数，查找到元素后将不再查找，直接返回</span></span><br><span class="line">find(<span class="function"><span class="keyword">function</span>(<span class="params">val, idx, arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">3</span>;</span><br><span class="line">&#125;));  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'wyzane'</span>, <span class="string">'nihao'</span>, <span class="string">'hello'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val == <span class="string">'hello'</span>;</span><br><span class="line">&#125;));  <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'wyzane'</span>, <span class="string">'nihao'</span>, <span class="string">'hello'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val == <span class="string">'he'</span>;</span><br><span class="line">&#125;));  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<h2 id="数组2"><a href="#数组2" class="headerlink" title="数组2"></a>数组2</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fill() 实例方法，用于数组元素的替换 fill(带替换元素, 起始位置，结束位置)</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>];</span><br><span class="line">arr.fill(<span class="string">'wyzane'</span>, <span class="number">1</span>, <span class="number">4</span>);  <span class="comment">// 替换第2,3,4个元素为wyzane</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">//  ["1", "wyzane", "wyzane", "wyzane", "5"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组循环 for ... of ... 循环</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>];</span><br><span class="line"><span class="comment">// 数组元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出下标和元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同时获取索引和值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, val] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="built_in">console</span>.log(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entries()方法</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.entries()</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.next().value); <span class="comment">// [0, "1"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组遍历 forEach的使用</span></span><br><span class="line"><span class="keyword">let</span> json = [<span class="string">'hello'</span>, <span class="string">'nihao'</span>, <span class="string">'hihi'</span>]</span><br><span class="line">json.forEach(<span class="function">(<span class="params">idx, val</span>) =&gt;</span> <span class="built_in">console</span>.log(idx, val));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组遍历 filter的使用</span></span><br><span class="line"><span class="keyword">let</span> json = [<span class="string">'hello'</span>, <span class="string">'nihao'</span>, <span class="string">'hihi'</span>]</span><br><span class="line">json.filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));  <span class="comment">// 仅仅输出元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组遍历 some的使用</span></span><br><span class="line"><span class="keyword">let</span> json = [<span class="string">'hello'</span>, <span class="string">'nihao'</span>, <span class="string">'hihi'</span>]</span><br><span class="line">json.some(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">// 仅仅输出元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组遍历 map的使用 有替换效果</span></span><br><span class="line"><span class="keyword">let</span> json = [<span class="string">'hello'</span>, <span class="string">'nihao'</span>, <span class="string">'hihi'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(json.map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="string">'web'</span>));  <span class="comment">// ["web", "web", "web"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组转换成字符串</span></span><br><span class="line"><span class="keyword">let</span> json = [<span class="string">'hello'</span>, <span class="string">'nihao'</span>, <span class="string">'hihi'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(json.toString());  <span class="comment">// hello,nihao,hihi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json = [<span class="string">'hello'</span>, <span class="string">'nihao'</span>, <span class="string">'hihi'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(json.join(<span class="string">'|'</span>));  <span class="comment">// hello|nihao|hihi</span></span><br></pre></td></tr></table></figure>



<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5中定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6中给参数添加默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b=<span class="number">4</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b=<span class="number">4</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'a ia error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">index.js:3 Uncaught Error: a ia error</span></span><br><span class="line"><span class="comment">    at add (index.js:3)</span></span><br><span class="line"><span class="comment">    at index.js:8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得函数需要传递的参数个数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b=<span class="number">4</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add.length);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add2.length);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">a, b=<span class="number">1</span></span>) =&gt;</span> a + b;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">a, b=<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wyzane'</span>);  <span class="comment">// wyzane</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的函数解构</span></span><br><span class="line"><span class="keyword">let</span> json = &#123;</span><br><span class="line">    a: <span class="string">'wyzane1'</span>,</span><br><span class="line">    b: <span class="string">'wyzane2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">&#123;a, b=<span class="string">'nihao'</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);  <span class="comment">// wyzane1 wyzane2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(json);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组解构</span></span><br><span class="line"><span class="keyword">let</span> json = [<span class="string">'nihao'</span>, <span class="string">'hi'</span>, <span class="string">'hello'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">[a, b, c]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);  <span class="comment">// nihao hi hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(json);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json = [<span class="string">'nihao'</span>, <span class="string">'hi'</span>, <span class="string">'hello'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);  <span class="comment">// nihao hi hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(...json);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// in的使用</span></span><br><span class="line"><span class="keyword">let</span> json = &#123;</span><br><span class="line">    a: <span class="string">'nihao'</span>,</span><br><span class="line">    b: <span class="string">'hi'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> <span class="keyword">in</span> json);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的赋值</span></span><br><span class="line"><span class="comment">// es5中的赋值</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'wyzane'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> wz = &#123;<span class="attr">name</span>: name, <span class="attr">age</span>: age&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(wz);  <span class="comment">// &#123;name: "wyzane", age: 18&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6中允许直接使用变量赋值</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'wyzane'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> wz = &#123;name, age&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(wz);  <span class="comment">// &#123;name: "wyzane", age: 18&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// key值的构建， 动态的创建key值</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">'name'</span>;</span><br><span class="line"><span class="keyword">let</span> wz = &#123;</span><br><span class="line">    [key]: <span class="string">'wyzane'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(wz);  <span class="comment">// &#123;name: "wyzane"&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义对象方法</span></span><br><span class="line"><span class="keyword">let</span> wz = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(wz.add(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// is() 方法，用于比较两个对象</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">'wyzane'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">name</span>: <span class="string">'wyzane'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name === obj2.name);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(obj1.name, obj2.name));  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===: 表示同值相等</span></span><br><span class="line"><span class="comment">is(): 严格相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// assign() 方法用于合并对象</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>: <span class="string">'wyzane'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">salary</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">Object</span>.assign(a, b, c);</span><br><span class="line"><span class="built_in">console</span>.log(d);  <span class="comment">// &#123;name: "wyzane", age: 18, salary: 1&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="symbol在对象中的作用"><a href="#symbol在对象中的作用" class="headerlink" title="symbol在对象中的作用"></a>symbol在对象中的作用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">String</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">Number</span>;</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Boolean</span>;</span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(f));  <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'wyzane'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// Symbol(wyzane)</span></span><br><span class="line"><span class="built_in">console</span>.log(a.toString());  <span class="comment">// Symbol(wyzane)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// symbol在对象中的使用</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [name]: <span class="string">'wyzane'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);   <span class="comment">// undefined  key为Symbol对象时，不能使用.的方式访问key</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[name]);  <span class="comment">// wyzane</span></span><br><span class="line">obj[name] = <span class="string">'wz'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[name]);  <span class="comment">// wz</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// symbol的应用，起到隐藏是有属性的作用</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">'wyzane'</span>, <span class="attr">skill</span>: <span class="string">'web'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> age = <span class="built_in">Symbol</span>()</span><br><span class="line">person[age] = <span class="number">18</span></span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// index.js:4 &#123;name: "wyzane", skill: "web", Symbol(): 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(person[item]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">wyzane</span></span><br><span class="line"><span class="comment">web</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="Set与WeakSet"><a href="#Set与WeakSet" class="headerlink" title="Set与WeakSet"></a>Set与WeakSet</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set类似于数组，但是不能有重复元素</span></span><br><span class="line"><span class="keyword">let</span> setArr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'wyzane1'</span>, <span class="string">'wyzane2'</span>, <span class="string">'wyzane'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(setArr);  <span class="comment">// &#123;"wyzane1", "wyzane2", "wyzane"&#125;</span></span><br><span class="line">setArr.add(<span class="string">'nihao'</span>);  <span class="comment">// 添加元素，数组中使用push添加元素</span></span><br><span class="line"><span class="built_in">console</span>.log(setArr);  <span class="comment">//  &#123;"wyzane1", "wyzane2", "wyzane", "nihao"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(setArr.has(<span class="string">'wyzane'</span>));  <span class="comment">// 查找元素</span></span><br><span class="line"></span><br><span class="line">setArr.delete(<span class="string">'wyzane'</span>);  <span class="comment">// 删除元素</span></span><br><span class="line"></span><br><span class="line">setArr.clear();  <span class="comment">// 清空元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for-of 输遍历出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> setArr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foreach 遍历输出</span></span><br><span class="line">setArr.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取set中元素的个数</span></span><br><span class="line"><span class="built_in">console</span>.log(setArr.size);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于set只能存放元素，不能存放对象，所以就出现了WeakSet。WeakSet可以存放对象</span></span><br><span class="line"><span class="comment">// WeakSet的使用</span></span><br><span class="line"><span class="keyword">let</span> setArr = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'wyzane1'</span>, <span class="attr">age</span>: <span class="number">13</span>&#125;;</span><br><span class="line">setArr.add(obj);</span><br><span class="line"><span class="built_in">console</span>.log(setArr);</span><br></pre></td></tr></table></figure>



<h2 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map中的key可以是任意类型</span></span><br><span class="line"><span class="keyword">let</span> json = &#123;</span><br><span class="line">    name: <span class="string">'wyzane'</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(json, <span class="string">'im'</span>);  <span class="comment">// set(key, val): 向map中添加元素</span></span><br><span class="line">map.set(<span class="string">'salary'</span>, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map);  <span class="comment">// Map(2) &#123;&#123;…&#125; =&gt; "im", "salary" =&gt; 13&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'salary'</span>));  <span class="comment">// 取值</span></span><br><span class="line"></span><br><span class="line">map.delete(json);  <span class="comment">// delete(key): 删除指定key的元素</span></span><br><span class="line"></span><br><span class="line">map.clear();  <span class="comment">// 删除全部元素</span></span><br><span class="line"></span><br><span class="line">map.size;  <span class="comment">// 获取元素个数</span></span><br><span class="line"></span><br><span class="line">map.has(json);  <span class="comment">// has(key)：根据key查找元素</span></span><br></pre></td></tr></table></figure>



<h2 id="proxy的使用"><a href="#proxy的使用" class="headerlink" title="proxy的使用"></a>proxy的使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proxy 用于增强对象和函数，执行预处理操作</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val + <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="string">'wyzane'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.add(<span class="number">100</span>));  <span class="comment">// 200</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);  <span class="comment">// wyzane</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy-get方法，获取对象属性时使用</span></span><br><span class="line"><span class="comment">// 当需要在调用obj之前处理其他事情时，可以使用 proxy</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val + <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="string">'wyzane'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, key, property)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"预处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 在访问属性name前，会先执行get方法，但是此时obj.name为 undefined，get方法修改为：</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val + <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="string">'wyzane'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, key, property)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"预处理"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(target);  <span class="comment">// &#123;add: ƒ, name: "wyzane"&#125;  target就是原对象</span></span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);  <span class="comment">// wyzane</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy-set方法，修改对象属性时使用</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val + <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="string">'wyzane'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, key, property)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"预处理"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(target, key, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;value&#125;</span>`</span>);  <span class="comment">// setting name = nihao</span></span><br><span class="line">        target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line">obj.name = <span class="string">'nihao'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);  <span class="comment">// nihao set中不加target[key] = value时，属性值不会被修改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy-apply方法，用于对方法的预处理  apply的使用方式与上面的get和set不同</span></span><br><span class="line"><span class="keyword">let</span> target = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'nihao'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    apply(target, ctx, args) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'apply func'</span>);  <span class="comment">// apply func</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj());  <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 上面的写法会有问题，apply方法中没有return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'nihao'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    apply(target, ctx, args) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'apply func'</span>);  <span class="comment">// apply func</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj());  <span class="comment">// nihao</span></span><br></pre></td></tr></table></figure>

<h2 id="async与await的使用"><a href="#async与await的使用" class="headerlink" title="async与await的使用"></a>async与await的使用</h2><p>async与await应该算是 ES7 中的语法，下面介绍下它的使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async 可以使一个方法变为异步方法</span><br><span class="line">await 用于获取一个异步方法中的返回值，可以等待异步方法的执行完成并返回（await需要在异步方法中使用）</span><br></pre></td></tr></table></figure>

<p>简单例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'你好'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getData());  <span class="comment">// Promise &#123; '你好' &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，async方法返回的是一个 Promise 对象，想要获取函数的返回值，可以使用下面的方式：</p>
<p>方式一：使用 then 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'你好'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = getData();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>方式二：使用 await ,await只能在异步方法中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'你好'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">await</span> getData();</span><br><span class="line">    <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>





<h2 id="Promise的使用"><a href="#Promise的使用" class="headerlink" title="Promise的使用"></a>Promise的使用</h2><p>Promise 是异步编程的一种解决方案，我们可以把将来发生的事件定义到 Promise 中。</p>
<p>下面是 Promise 使用的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise可以优雅的执行多重回调函数。es5中使用嵌套执行多重回调，不优雅</span></span><br><span class="line"><span class="keyword">let</span> state = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> step1 = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1-开始洗菜做饭'</span>);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">1</span>)&#123;</span><br><span class="line">        resolve(<span class="string">'洗菜做饭-完成'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">'洗菜做饭-出错'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> step2 = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2.吃饭'</span>);</span><br><span class="line">    <span class="keyword">if</span> (state==<span class="number">1</span>)&#123;</span><br><span class="line">        resolve(<span class="string">'吃饭-完成'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">'吃饭-出错'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> step3 = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3.洗碗'</span>);</span><br><span class="line">    <span class="keyword">if</span> (state==<span class="number">1</span>) &#123;</span><br><span class="line">        resolve(<span class="string">'洗碗-完成'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">'洗碗-出错'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(step1).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(step2);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(step3);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1-开始洗菜做饭</span></span><br><span class="line"><span class="comment">洗菜做饭-完成</span></span><br><span class="line"><span class="comment">2.吃饭</span></span><br><span class="line"><span class="comment">吃饭-完成</span></span><br><span class="line"><span class="comment">3.洗碗</span></span><br><span class="line"><span class="comment">洗碗-完成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错时，程序会停止</span></span><br><span class="line"><span class="keyword">let</span> state = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> step1 = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1-开始洗菜做饭'</span>);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">1</span>)&#123;</span><br><span class="line">        resolve(<span class="string">'洗菜做饭-完成'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">'洗菜做饭-出错'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> step2 = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    state = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2.吃饭'</span>);</span><br><span class="line">    <span class="keyword">if</span> (state==<span class="number">1</span>)&#123;</span><br><span class="line">        resolve(<span class="string">'吃饭-完成'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">'吃饭-出错'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> step3 = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3.洗碗'</span>);</span><br><span class="line">    <span class="keyword">if</span> (state==<span class="number">1</span>) &#123;</span><br><span class="line">        resolve(<span class="string">'洗碗-完成'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">'洗碗-出错'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(step1).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(step2);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(step3);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>还可以在 async 方法中调用含有 Promise 的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> username = <span class="string">'zhangsan'</span>;</span><br><span class="line">            resolve(username);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">await</span> getData();</span><br><span class="line">    <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>



<h2 id="es6中类的使用"><a href="#es6中类的使用" class="headerlink" title="es6中类的使用"></a>es6中类的使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line">    name (val) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">    skill (val) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wyzane = <span class="keyword">new</span> Coder; </span><br><span class="line">wyzane.name(<span class="string">'nihao'</span>);   <span class="comment">// nihao</span></span><br><span class="line">wyzane.skill(<span class="string">'nihaoya'</span>);  <span class="comment">// nihaoya</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类里面的成员之间互相访问使用this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line">    name (val) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name method is called'</span>);  <span class="comment">// name method is called</span></span><br><span class="line">        <span class="built_in">console</span>.log(val);  <span class="comment">// nihao</span></span><br><span class="line">    &#125;</span><br><span class="line">    skill (val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wyzane = <span class="keyword">new</span> Coder;</span><br><span class="line">wyzane.name(<span class="string">'nihao'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的构造方法和静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    run () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>._name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> work () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'静态方法'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'zhangsan'</span>, <span class="number">20</span>);</span><br><span class="line">person.run();  <span class="comment">// 调用实例方法</span></span><br><span class="line">Person.work(); <span class="comment">// 调用静态方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xiaoming</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name, age, gender) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);  <span class="comment">// 通过super给父类传参</span></span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eat () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'小明喜欢吃糖'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xm = <span class="keyword">new</span> Xiaoming(<span class="string">'xiaoming'</span>, <span class="number">20</span>, <span class="string">'男'</span>);</span><br><span class="line">xm.run()</span><br><span class="line">xm.eat();</span><br><span class="line">Xiaoming.work()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行构造方法'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> getInstance () &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Client.instance) &#123;</span><br><span class="line">            Client.instance = <span class="keyword">new</span> Client();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Client.instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多次获取对象时，只会执行一次构造方法</span></span><br><span class="line"><span class="keyword">let</span> client1 = Client.getInstance();</span><br><span class="line"><span class="keyword">let</span> client2 = Client.getInstance();</span><br></pre></td></tr></table></figure>

<p>作为对比，es5中类的定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5中定义类和静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个是构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链上的属性和方法（也属于实例方法）</span></span><br><span class="line"><span class="comment">/*原型链上的属性和方法与构造函数中的属性和方法的区别：</span></span><br><span class="line"><span class="comment">    1. 原型链上的属性和方法可以被多个实例共享</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Person.prototype.gender = <span class="string">'男'</span>;</span><br><span class="line">Person.prototype.work = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">Person.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'静态方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'zhansan'</span>, <span class="number">20</span>); <span class="comment">//实例方法通过实例化来调用</span></span><br><span class="line"><span class="comment">// 调用实例方法</span></span><br><span class="line">p.run();</span><br><span class="line">p.work();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">Person.setName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// es5中的继承：原型链继承和对象冒充继承</span></span><br><span class="line"><span class="comment">// 对象冒充继承(该继承方式不能继承原型链上的属性和方法，所以要结合原型链继承方式)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承(该继承方式实例化子类的时候不能给父类传参，即不能将属性传递给父类，所以要结合对象冒充继承)</span></span><br><span class="line">Web.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> web = Web(<span class="string">'lisi'</span>, <span class="number">20</span>);</span><br><span class="line">web.run();</span><br></pre></td></tr></table></figure>





<h2 id="模块化操作"><a href="#模块化操作" class="headerlink" title="模块化操作"></a>模块化操作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// export-输出   import-输入</span></span><br><span class="line"></span><br><span class="line">temp.js:</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">'wyzane'</span>;</span><br><span class="line"></span><br><span class="line">index.js:</span><br><span class="line"><span class="keyword">import</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">'./temp'</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出多个变量</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a, b, c&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的模块化输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出时语义化处理，相当于引用的时候可以使用别名</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">	name <span class="keyword">as</span> a,</span><br><span class="line">    cname <span class="keyword">as</span> b,</span><br><span class="line">    skill <span class="keyword">as</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// export default 与 export 的区别：一个文件中可以有很多export，但是只能有一个export default</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">export导出的对象只能使用&#123;&#125;import</span></span><br><span class="line"><span class="comment">export default 导出的对象可以不使用&#123;&#125;import，并且可以自定义名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">temp.js:</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="string">'nihao'</span>;</span><br><span class="line"></span><br><span class="line">index.js</span><br><span class="line"><span class="keyword">import</span> 自定义名称 <span class="keyword">from</span> <span class="string">'./temp'</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>Django处理请求流程</title>
    <url>/blog/2019/11/28/Django%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>Django是Python的一个web框架，Django应用通过wsgi服务器与客户端进行http通信。今天介绍下从Django接收客户端http请求到生成响应过程中的流程。</p>
<a id="more"></a>

<h2 id="1-请求响应流程"><a href="#1-请求响应流程" class="headerlink" title="1. 请求响应流程"></a>1. 请求响应流程</h2><p>整体流程如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">get_wsgi_application() --&gt; WSGIHandler() --&gt; self.load_middleware() --&gt; __call__() --&gt; self.get_response() --&gt; self._get_response()</span><br></pre></td></tr></table></figure>

<p>request 经过 self._get_response()后，就生成了 response。</p>
<h2 id="2-请求响应具体流程"><a href="#2-请求响应具体流程" class="headerlink" title="2. 请求响应具体流程"></a>2. 请求响应具体流程</h2><h3 id="2-1-WSGIHandler-初始化"><a href="#2-1-WSGIHandler-初始化" class="headerlink" title="2.1 WSGIHandler 初始化"></a>2.1 WSGIHandler 初始化</h3><p>WSGIHandler类如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIHandler</span><span class="params">(base.BaseHandler)</span>:</span></span><br><span class="line">    request_class = WSGIRequest</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        self.load_middleware()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        set_script_prefix(get_script_name(environ))</span><br><span class="line">        signals.request_started.send(sender=self.__class__, environ=environ)</span><br><span class="line">        request = self.request_class(environ)</span><br><span class="line">        response = self.get_response(request)</span><br><span class="line"></span><br><span class="line">        response._handler_class = self.__class__</span><br><span class="line"></span><br><span class="line">        status = <span class="string">'%d %s'</span> % (response.status_code, response.reason_phrase)</span><br><span class="line">        response_headers = [</span><br><span class="line">            *response.items(),</span><br><span class="line">            *((<span class="string">'Set-Cookie'</span>, c.output(header=<span class="string">''</span>)) <span class="keyword">for</span> c <span class="keyword">in</span> response.cookies.values()),</span><br><span class="line">        ]</span><br><span class="line">        start_response(status, response_headers)</span><br><span class="line">        <span class="keyword">if</span> getattr(response, <span class="string">'file_to_stream'</span>, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> environ.get(<span class="string">'wsgi.file_wrapper'</span>):</span><br><span class="line">            response = environ[<span class="string">'wsgi.file_wrapper'</span>](response.file_to_stream)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>wsgi服务器接收到请求后，会初始化 WSGIHandler类，并调用__call__()方法。初始化时，会调用BaseHandler中的 load_middleware()方法。</p>
<p>self.load_middleware()方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_middleware</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Populate middleware lists from settings.MIDDLEWARE.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Must be called after the environment is fixed (see __call__ in subclasses).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._view_middleware = []</span><br><span class="line">    self._template_response_middleware = []</span><br><span class="line">    self._exception_middleware = []</span><br><span class="line"></span><br><span class="line">    handler = convert_exception_to_response(self._get_response)</span><br><span class="line">    <span class="keyword">for</span> middleware_path <span class="keyword">in</span> reversed(settings.MIDDLEWARE):</span><br><span class="line">        middleware = import_string(middleware_path)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            mw_instance = middleware(handler)</span><br><span class="line">        <span class="keyword">except</span> MiddlewareNotUsed <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> settings.DEBUG:</span><br><span class="line">                <span class="keyword">if</span> str(exc):</span><br><span class="line">                    logger.debug(<span class="string">'MiddlewareNotUsed(%r): %s'</span>, middleware_path, exc)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    logger.debug(<span class="string">'MiddlewareNotUsed: %r'</span>, middleware_path)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mw_instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ImproperlyConfigured(</span><br><span class="line">                <span class="string">'Middleware factory %s returned None.'</span> % middleware_path</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hasattr(mw_instance, <span class="string">'process_view'</span>):</span><br><span class="line">            self._view_middleware.insert(<span class="number">0</span>, mw_instance.process_view)</span><br><span class="line">        <span class="keyword">if</span> hasattr(mw_instance, <span class="string">'process_template_response'</span>):</span><br><span class="line">            self._template_response_middleware.append(mw_instance.process_template_response)</span><br><span class="line">        <span class="keyword">if</span> hasattr(mw_instance, <span class="string">'process_exception'</span>):</span><br><span class="line">            self._exception_middleware.append(mw_instance.process_exception)</span><br><span class="line"></span><br><span class="line">        handler = convert_exception_to_response(mw_instance)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We only assign to this when initialization is complete as it is used</span></span><br><span class="line">    <span class="comment"># as a flag for initialization being complete.</span></span><br><span class="line">    self._middleware_chain = handler</span><br></pre></td></tr></table></figure>

<p>load_middleware()方法中主要做了一下几步操作：</p>
<ol>
<li><p>调用 convert_exception_to_response() 方法，返回一个可调用对象，该方法接收另一个方法（这个方法负责处理request）作为参数</p>
<p>convert_exception_to_response() 方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_exception_to_response</span><span class="params">(get_response)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Wrap the given get_response callable in exception-to-response conversion.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    All exceptions will be converted. All known 4xx exceptions (Http404,</span></span><br><span class="line"><span class="string">    PermissionDenied, MultiPartParserError, SuspiciousOperation) will be</span></span><br><span class="line"><span class="string">    converted to the appropriate response, and all other exceptions will be</span></span><br><span class="line"><span class="string">    converted to 500 responses.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This decorator is automatically applied to all middleware to ensure that</span></span><br><span class="line"><span class="string">    no middleware leaks an exception and that the next middleware in the stack</span></span><br><span class="line"><span class="string">    can rely on getting a response instead of an exception.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @wraps(get_response)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(request)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = get_response(request)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            response = response_for_exception(request, exc)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<p>该方法中用到了装饰器。</p>
</li>
<li><p>mw_instance = middleware(handler)， 这一行代码会创建中间件的实例对象，后面的几个if语句再逐个判断中间件对象中是否定义了 process_view()、process_exception()等方法。</p>
</li>
<li><p>handler = convert_exception_to_response(mw_instance)，这一行代码将中间件实例作为参数传入方法中，返回一个可调用对象。这里将中间件对象作为参数，后面会调用中间件中的__call__()方法来处理request。Django中，中间件类MiddlewareMixin的实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddlewareMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, get_response=None)</span>:</span></span><br><span class="line">        self.get_response = get_response</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        response = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'process_request'</span>):</span><br><span class="line">            response = self.process_request(request)</span><br><span class="line">        response = response <span class="keyword">or</span> self.get_response(request)</span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'process_response'</span>):</span><br><span class="line">            response = self.process_response(request, response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后一行代码 self._middleware_chain = handler 是将handler赋值给 _middleware_chain 属性。</p>
</li>
</ol>
<h3 id="2-2-WSGIHandler-call-方法"><a href="#2-2-WSGIHandler-call-方法" class="headerlink" title="2.2 WSGIHandler call()方法"></a>2.2 WSGIHandler call()方法</h3><p>WSGIHandler初始化完成后，会调用__call__()方法，该方法用来处理 request，返回response，实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">    set_script_prefix(get_script_name(environ))</span><br><span class="line">    signals.request_started.send(sender=self.__class__, environ=environ)</span><br><span class="line">    request = self.request_class(environ)</span><br><span class="line">    response = self.get_response(request)</span><br><span class="line"></span><br><span class="line">    response._handler_class = self.__class__</span><br><span class="line"></span><br><span class="line">    status = <span class="string">'%d %s'</span> % (response.status_code, response.reason_phrase)</span><br><span class="line">    response_headers = [</span><br><span class="line">        *response.items(),</span><br><span class="line">        *((<span class="string">'Set-Cookie'</span>, c.output(header=<span class="string">''</span>)) <span class="keyword">for</span> c <span class="keyword">in</span> response.cookies.values()),</span><br><span class="line">    ]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">if</span> getattr(response, <span class="string">'file_to_stream'</span>, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> environ.get(<span class="string">'wsgi.file_wrapper'</span>):</span><br><span class="line">        response = environ[<span class="string">'wsgi.file_wrapper'</span>](response.file_to_stream)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>__call__()方法主要做了下面一些操作: </p>
<ol>
<li>self.request_class(environ) 这一行将 http request对象 转换为 wsgi request对象</li>
<li>self.get_response(request) 这一行代码会调用BaseHandler的get_response()方法，生成 http response对象。</li>
</ol>
<p>下面具体介绍下self.get_response() 这个方法。</p>
<h3 id="2-3-get-response-方法"><a href="#2-3-get-response-方法" class="headerlink" title="2.3 get_response() 方法"></a>2.3 get_response() 方法</h3><p>BaseHandler的get_response()方法用来处理request，并生成response。get_response()的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    <span class="string">"""Return an HttpResponse object for the given HttpRequest."""</span></span><br><span class="line">    <span class="comment"># Setup default url resolver for this thread</span></span><br><span class="line">    set_urlconf(settings.ROOT_URLCONF)</span><br><span class="line">    response = self._middleware_chain(request)</span><br><span class="line">    response._closable_objects.append(request)</span><br><span class="line">    <span class="keyword">if</span> response.status_code &gt;= <span class="number">400</span>:</span><br><span class="line">        log_response(</span><br><span class="line">            <span class="string">'%s: %s'</span>, response.reason_phrase, request.path,</span><br><span class="line">            response=response,</span><br><span class="line">            request=request,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>主要是 response = self._middleware_chain(request) 这一行代码，将 request 作为参数传入上文说到的 self._middleware_chain中，输出response。具体执行流程如下：</p>
<ol>
<li><p>上文说到，在 self.load_middleware()中会执行下面的代码：</p>
<p>handler = convert_exception_to_response(self._get_response)</p>
<p>convert_exception_to_response()方法的实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_exception_to_response</span><span class="params">(get_response)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Wrap the given get_response callable in exception-to-response conversion.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    All exceptions will be converted. All known 4xx exceptions (Http404,</span></span><br><span class="line"><span class="string">    PermissionDenied, MultiPartParserError, SuspiciousOperation) will be</span></span><br><span class="line"><span class="string">    converted to the appropriate response, and all other exceptions will be</span></span><br><span class="line"><span class="string">    converted to 500 responses.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This decorator is automatically applied to all middleware to ensure that</span></span><br><span class="line"><span class="string">    no middleware leaks an exception and that the next middleware in the stack</span></span><br><span class="line"><span class="string">    can rely on getting a response instead of an exception.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @wraps(get_response)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(request)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = get_response(request)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            response = response_for_exception(request, exc)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<p>所以，self._middleware_chain(request) 最终是调用了 self._get_response(request) 这个方法。</p>
</li>
<li><p>self._get_response()的实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_response</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Resolve and call the view, then apply view, exception, and</span></span><br><span class="line"><span class="string">    template_response middleware. This method is everything that happens</span></span><br><span class="line"><span class="string">    inside the request/response middleware.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    response = <span class="literal">None</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> hasattr(request, <span class="string">'urlconf'</span>):</span><br><span class="line">        urlconf = request.urlconf</span><br><span class="line">        set_urlconf(urlconf)</span><br><span class="line">        resolver = get_resolver(urlconf)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        resolver = get_resolver()</span><br><span class="line">   </span><br><span class="line">    resolver_match = resolver.resolve(request.path_info)</span><br><span class="line">    callback, callback_args, callback_kwargs = resolver_match</span><br><span class="line">    request.resolver_match = resolver_match</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># Apply view middleware</span></span><br><span class="line">    <span class="keyword">for</span> middleware_method <span class="keyword">in</span> self._view_middleware:</span><br><span class="line">        response = middleware_method(request, callback, callback_args, callback_kwargs)</span><br><span class="line">        <span class="keyword">if</span> response:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        wrapped_callback = self.make_view_atomic(callback)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = wrapped_callback(request, *callback_args, **callback_kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            response = self.process_exception_by_middleware(e, request)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># Complain if the view returned None (a common error).</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> isinstance(callback, types.FunctionType):    <span class="comment"># FBV</span></span><br><span class="line">            view_name = callback.__name__</span><br><span class="line">        <span class="keyword">else</span>:                                           <span class="comment"># CBV</span></span><br><span class="line">            view_name = callback.__class__.__name__ + <span class="string">'.__call__'</span></span><br><span class="line">   </span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">"The view %s.%s didn't return an HttpResponse object. It "</span></span><br><span class="line">            <span class="string">"returned None instead."</span> % (callback.__module__, view_name)</span><br><span class="line">        )</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># If the response supports deferred rendering, apply template</span></span><br><span class="line">    <span class="comment"># response middleware and then render the response</span></span><br><span class="line">    <span class="keyword">elif</span> hasattr(response, <span class="string">'render'</span>) <span class="keyword">and</span> callable(response.render):</span><br><span class="line">        <span class="keyword">for</span> middleware_method <span class="keyword">in</span> self._template_response_middleware:</span><br><span class="line">            response = middleware_method(request, response)</span><br><span class="line">            <span class="comment"># Complain if the template response middleware returned None (a common error).</span></span><br><span class="line">            <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">"%s.process_template_response didn't return an "</span></span><br><span class="line">                    <span class="string">"HttpResponse object. It returned None instead."</span></span><br><span class="line">                    % (middleware_method.__self__.__class__.__name__)</span><br><span class="line">                )</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = response.render()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            response = self.process_exception_by_middleware(e, request)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>该方法中，主要进行了以下几步操作：路由解析 –&gt; 中间件校验 –&gt; 调用视图函数获取response</p>
</li>
<li><p>下面介绍下 “路由解析” 的流程：</p>
<p>1）读取 settings 配置文件中的 ROOT_URLCONF 信息获取路由配置，获取 URLResolver 对象，即执行了下面的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@functools.lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_resolver</span><span class="params">(urlconf=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> urlconf <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        urlconf = settings.ROOT_URLCONF</span><br><span class="line">    <span class="keyword">return</span> URLResolver(RegexPattern(<span class="string">r'^/'</span>), urlconf)</span><br></pre></td></tr></table></figure>

<p>2）然后再执行 resolver_match = resolver.resolve(request.path_info) 这行代码，resolve()方法的实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resolve</span><span class="params">(self, path)</span>:</span></span><br><span class="line">    path = str(path)  <span class="comment"># path may be a reverse_lazy object</span></span><br><span class="line">    tried = []</span><br><span class="line">    match = self.pattern.match(path)</span><br><span class="line">    <span class="keyword">if</span> match:</span><br><span class="line">        new_path, args, kwargs = match</span><br><span class="line">        <span class="keyword">for</span> pattern <span class="keyword">in</span> self.url_patterns:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                sub_match = pattern.resolve(new_path)</span><br><span class="line">            <span class="keyword">except</span> Resolver404 <span class="keyword">as</span> e:</span><br><span class="line">                sub_tried = e.args[<span class="number">0</span>].get(<span class="string">'tried'</span>)</span><br><span class="line">                <span class="keyword">if</span> sub_tried <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tried.extend([pattern] + t <span class="keyword">for</span> t <span class="keyword">in</span> sub_tried)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tried.append([pattern])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> sub_match:</span><br><span class="line">                    <span class="comment"># Merge captured arguments in match with submatch</span></span><br><span class="line">                    sub_match_dict = &#123;**kwargs, **self.default_kwargs&#125;</span><br><span class="line">                    <span class="comment"># Update the sub_match_dict with the kwargs from the sub_match.</span></span><br><span class="line">                    sub_match_dict.update(sub_match.kwargs)</span><br><span class="line">                    <span class="comment"># If there are *any* named groups, ignore all non-named groups.</span></span><br><span class="line">                    <span class="comment"># Otherwise, pass all non-named arguments as positional arguments.</span></span><br><span class="line">                    sub_match_args = sub_match.args</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> sub_match_dict:</span><br><span class="line">                        sub_match_args = args + sub_match.args</span><br><span class="line">                    current_route = <span class="string">''</span> <span class="keyword">if</span> isinstance(pattern, URLPattern) <span class="keyword">else</span> str(pattern.pattern)</span><br><span class="line">                    <span class="keyword">return</span> ResolverMatch(</span><br><span class="line">                        sub_match.func,</span><br><span class="line">                        sub_match_args,</span><br><span class="line">                        sub_match_dict,</span><br><span class="line">                        sub_match.url_name,</span><br><span class="line">                        [self.app_name] + sub_match.app_names,</span><br><span class="line">                        [self.namespace] + sub_match.namespaces,</span><br><span class="line">                        self._join_route(current_route, sub_match.route),</span><br><span class="line">                    )</span><br><span class="line">                tried.append([pattern])</span><br><span class="line">        <span class="keyword">raise</span> Resolver404(&#123;<span class="string">'tried'</span>: tried, <span class="string">'path'</span>: new_path&#125;)</span><br><span class="line">    <span class="keyword">raise</span> Resolver404(&#123;<span class="string">'path'</span>: path&#125;)</span><br></pre></td></tr></table></figure>

<p>函数返回了一个 ResolverMatch类的实例，后面通过这个实例，在获取处理请求的试图方法、请求参数等信息。该函数中，有下面一行代码 sub_match = pattern.resolve(new_path)，这行代码会返回一个 ResolverMatch() 对象，就是通过这个对象，来决定执行哪个视图的哪个方法。</p>
<p>3）我们先来看看配置 url 时的三个方法：path, include, as_view。在下面的配置中会使用这三个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'test01/'</span>, include(<span class="string">'cron.urls'</span>)),</span><br><span class="line">    path(<span class="string">"test02/"</span>, include(<span class="string">'cron02.urls'</span>)),</span><br><span class="line">    path(<span class="string">"middleware/"</span>, include(<span class="string">'test_middleware.urls'</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> TestView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">"cron/"</span>, TestView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>其中，path方法实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_path</span><span class="params">(route, view, kwargs=None, name=None, Pattern=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(view, (list, tuple)):</span><br><span class="line">        <span class="comment"># For include(...) processing.</span></span><br><span class="line">        pattern = Pattern(route, is_endpoint=<span class="literal">False</span>)</span><br><span class="line">        urlconf_module, app_name, namespace = view</span><br><span class="line">        <span class="keyword">return</span> URLResolver(</span><br><span class="line">            pattern,</span><br><span class="line">            urlconf_module,</span><br><span class="line">            kwargs,</span><br><span class="line">            app_name=app_name,</span><br><span class="line">            namespace=namespace,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> callable(view):</span><br><span class="line">        pattern = Pattern(route, name=name, is_endpoint=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> URLPattern(pattern, view, kwargs, name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'view must be a callable or a list/tuple in the case of include().'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path = partial(_path, Pattern=RoutePattern)</span><br></pre></td></tr></table></figure>

<p>根据view参数的类型不同，会执行不同的代码块。当path的第二个参数是TestView.as_view()时，会满足callable(view)这个条件，返回一个URLPattern类的对象，注意此时 view是可调用的。as_view()的实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classonlymethod</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">as_view</span><span class="params">(cls, **initkwargs)</span>:</span></span><br><span class="line">       <span class="string">"""Main entry point for a request-response process."""</span></span><br><span class="line">       <span class="keyword">for</span> key <span class="keyword">in</span> initkwargs:</span><br><span class="line">           <span class="keyword">if</span> key <span class="keyword">in</span> cls.http_method_names:</span><br><span class="line">               <span class="keyword">raise</span> TypeError(<span class="string">"You tried to pass in the %s method name as a "</span></span><br><span class="line">                               <span class="string">"keyword argument to %s(). Don't do that."</span></span><br><span class="line">                               % (key, cls.__name__))</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, key):</span><br><span class="line">               <span class="keyword">raise</span> TypeError(<span class="string">"%s() received an invalid keyword %r. as_view "</span></span><br><span class="line">                               <span class="string">"only accepts arguments that are already "</span></span><br><span class="line">                               <span class="string">"attributes of the class."</span> % (cls.__name__, key))</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">           self = cls(**initkwargs)</span><br><span class="line">           <span class="keyword">if</span> hasattr(self, <span class="string">'get'</span>) <span class="keyword">and</span> <span class="keyword">not</span> hasattr(self, <span class="string">'head'</span>):</span><br><span class="line">               self.head = self.get</span><br><span class="line">           self.setup(request, *args, **kwargs)</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'request'</span>):</span><br><span class="line">               <span class="keyword">raise</span> AttributeError(</span><br><span class="line">                   <span class="string">"%s instance has no 'request' attribute. Did you override "</span></span><br><span class="line">                   <span class="string">"setup() and forget to call super()?"</span> % cls.__name__</span><br><span class="line">               )</span><br><span class="line">           <span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line">       view.view_class = cls</span><br><span class="line">       view.view_initkwargs = initkwargs</span><br><span class="line">   </span><br><span class="line">       <span class="comment"># take name and docstring from class</span></span><br><span class="line">       update_wrapper(view, cls, updated=())</span><br><span class="line">   </span><br><span class="line">       <span class="comment"># and possible attributes set by decorators</span></span><br><span class="line">       <span class="comment"># like csrf_exempt from dispatch</span></span><br><span class="line">       update_wrapper(view, cls.dispatch, assigned=())</span><br><span class="line">       <span class="keyword">return</span> view</span><br></pre></td></tr></table></figure>

<p>as_view() 方法的主要功能就是根据 request 参数，确定要执行 view 中的哪个方法(post, get, put等)，当有代码调用 view 时，就会执行相应的 http 方法并返回 response。</p>
<p>4）然后我们在回到 2）步结束的地方，当执行 sub_match = pattern.resolve(new_path) 这行代码时，会执行 URLPattern 中的 resolve()方法，返回 ResolverMatch对象，ResolverMatch对象初始化时的参数 func 的值就是 3）中 path()方法中的 view，后面会调用 view 这个函数获取response。</p>
<p>5）最后，在 _get_response() 中会调用上面的 view函数，这部分代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    wrapped_callback = self.make_view_atomic(callback)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = wrapped_callback(request, *callback_args, **callback_kwargs)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        response = self.process_exception_by_middleware(e, request)</span><br></pre></td></tr></table></figure>

<p>首先判断是否需要添加事务，然后再执行 callback 函数，最后返回 response。</p>
</li>
</ol>
<p>   以上就是 Django 处理 http 请求的大致流程，从源码中我们要能学习到写 python 代码的一些技巧。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下搭建开发环境</title>
    <url>/blog/2019/12/29/Linux%E4%B8%8B%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>开发中，我们经常需要用到虚拟机，在虚拟机中创建 Linux 操作系统，配置开发环境。对于不经常配置 Linux 虚拟机的同学来说，配置一遍可能需要花费很长时间。</p>
<a id="more"></a>

<p>下面会以 Ubuntu18.04 和 Python 开发为主，介绍下虚拟机创建完成后，需要安装的额外软件及安装步骤。这些软件有的是必须的，有的能提高开发效率。主要介绍下面一些软件的安装步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssh-server</span><br><span class="line">vmware tools</span><br><span class="line">sogou pinyin</span><br><span class="line">zsh</span><br><span class="line">pip</span><br><span class="line">virtualenv</span><br></pre></td></tr></table></figure>



<h4 id="openssh-server"><a href="#openssh-server" class="headerlink" title="openssh-server"></a>openssh-server</h4><p>安装openssh-server是为了允许远程登陆到ubuntu18.04虚拟机上，步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装openssh-server软件包：sudo apt-get install openssh-server</span><br><span class="line">2. 开启防火墙：sudo ufw enable</span><br><span class="line">3. 开放22端口：ufw allow 22&#x2F;tcp</span><br></pre></td></tr></table></figure>



<h4 id="vmware-tools"><a href="#vmware-tools" class="headerlink" title="vmware tools"></a>vmware tools</h4><p>vmware tools是 vmware 虚拟机中自带的一种增强工具，可以提供一些额外的功能，如可以使虚拟机窗口全屏显式等。如果直接登陆虚拟机操作，全屏显示这个功能还是很有必要的，如果使用远程连接工具（xshell，secureCRT等）连接虚拟机，全屏显示功能也没有影响。</p>
<p>vmware tools的安装步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 点击 VMWare Workstation 软件中的 虚拟机 --&gt; 安装VMWare Tools选项，会在虚拟机的Linux操作系统</span><br><span class="line">	上生成VMWare Tools的tar包</span><br><span class="line">2. 解压VMWare Tools的tar包： tar -zxvf tar包，进入生成的 vmware-tools-distrib 目录中；</span><br><span class="line">3. 执行 vmware-install.pl 文件，安装过程中，需要选择一些选项；执行完成后，vmware tools 即安装完</span><br><span class="line">	成。</span><br></pre></td></tr></table></figure>



<h4 id="sogoupinyin"><a href="#sogoupinyin" class="headerlink" title="sogoupinyin"></a>sogoupinyin</h4><p><a href="https://blog.csdn.net/qq_40563761/article/details/82664851" target="_blank" rel="noopener">https://blog.csdn.net/qq_40563761/article/details/82664851</a></p>
<p>sogoupinyin的安装步骤如下：</p>
<ol>
<li><p>去官网下载 Linux 版本相应的deb安装包：sogoupinyin_2.3.1.0112_amd64.deb</p>
<p>下载地址：<a href="https://pinyin.sogou.com/linux/?r=pinyin；" target="_blank" rel="noopener">https://pinyin.sogou.com/linux/?r=pinyin；</a></p>
</li>
<li><p>执行 sudo apt-get install -f，安装fcitx相关软件包；</p>
</li>
<li><p>安装第1步中下载的 deb 包：sudo dpkg -i sogoupinyin_2.3.1.0112_amd64.deb；</p>
</li>
<li><p>找到系统设置中的 Language Support 选项，如下图：</p>
<p>![](Language Support.png)</p>
</li>
<li><p>点击进入后，如下图：</p>
</li>
</ol>
<p>​        ![](Language Support2.png)</p>
<p>​        刚进入时，可能需要安装其他软件包，此时点击安装即可，安装完成后将箭头指定的配置选择为 fcitx；</p>
<ol start="6">
<li><p>然后重启系统；</p>
</li>
<li><p>重启成功后，找到系统中的 Fcitx Configuration 配置项，进入后如下图：</p>
<p><img src="fcitx.png" alt=""></p>
</li>
</ol>
<p>​        点击 + 号，选择 Sogou Pinyin即可。这时就可以使用搜狗输入法了。</p>
<h4 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h4><p>zsh的介绍就不多说了，安装 zsh 的步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. sudo apt-get install zsh</span><br><span class="line">2. 修改默认shell为zsh：chsh -s &#x2F;bin&#x2F;zsh</span><br><span class="line">3. 配置密码文件, 用来解决改变shell时出现的PAM认证问题</span><br><span class="line">   sudo vim &#x2F;etc&#x2F;passwd</span><br><span class="line">   然后将第一行中的&#x2F;bin&#x2F;bash改成&#x2F;bin&#x2F;zsh即可   </span><br><span class="line">4. 安装oh-my-zsh</span><br><span class="line">   安装git：</span><br><span class="line">   sudo apt install git</span><br><span class="line">   安装oh-my-zsh：</span><br><span class="line">   sh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;robbyrussell&#x2F;oh-my-</span><br><span class="line">   zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;  </span><br><span class="line">5. 修改 zsh 的主题</span><br><span class="line">   sudo vim .zshrc</span><br><span class="line">   修改ZSH_THEME&#x3D;&quot;robbyrussell&quot;为ZSH_THEME&#x3D;&quot;cloud&quot;</span><br></pre></td></tr></table></figure>



<h4 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h4><p>安装python3版本的pip：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装pip：sudo apt install python3-pip</span><br><span class="line">2. 安装相关开发工具：sudo apt install build-essential python3-dev  python3-setuptools</span><br><span class="line">3. 安装完成后，输入 pip3 即可安装 python 包；但是我们还可以创建软连接，使得输入 pip 时就可以安装 </span><br><span class="line">	python包了。创建软连接步骤如下：</span><br><span class="line">   1）进入 &#x2F;usr&#x2F;bin 目录</span><br><span class="line">   2）执行 ln -s pip3 pip，表示在当前目录创建一个软连接 pip，指向当前目录的 pip3</span><br></pre></td></tr></table></figure>



<h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><p>安装 virtualenv 和 virtualenvwrapper 的步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualenv的安装与使用：</span><br><span class="line">1. pip install virtualenv</span><br><span class="line">   安装完成后，可以执行以下命令来创建和使用虚拟环境：</span><br><span class="line">   1）创建虚拟环境 virtualenv --python&#x3D;python3  env_test</span><br><span class="line">   2）进入虚拟环境 source env_test&#x2F;bin&#x2F;activate</span><br><span class="line">   3）使用pip安装软件包 pip install requests</span><br><span class="line">   4）退出虚拟环境 deactivate env_test</span><br><span class="line"></span><br><span class="line">virtualenvwrapper可以更方便的管理虚拟环境，其安装步骤如下：</span><br><span class="line">1. pip install virtualenvwrapper</span><br><span class="line">2. 设置环境变量，修改 .zshrc 文件，添加如下信息：</span><br><span class="line">    export WORKON_HOME&#x3D;&#x2F;home&#x2F;wyzane&#x2F;virtualenvs</span><br><span class="line">    export VIRTUALENVWRAPPER_VIRTUALENV_ARGS&#x3D;&#39;--no-site-packages&#39;</span><br><span class="line">    export VIRTUALENVWRAPPER_PYTHON&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3</span><br><span class="line">	plugins&#x3D;(virtualenvwrapper)  # 指定 virtualenvwrapper 插件，由于是在zsh的配置文</span><br><span class="line">		件.zshrc中添加的配置，所以需要这一配置。不同的shell配置文件可能不同。</span><br><span class="line"></span><br><span class="line">3. 使用</span><br><span class="line">	1）创建虚拟环境 mkvirtualenv env_python</span><br><span class="line">	2）进入虚拟环境 workon env_python</span><br><span class="line">	3）退出虚拟环境 deactivate env_python</span><br></pre></td></tr></table></figure>



<p>对于 python 开发的同学而言，以上就是 Linux 环境需要安装的基本软件。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa2的简单使用</title>
    <url>/blog/2020/05/17/Koa2%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Koa2 是一个基于 Nodejs 的web 服务端框架，它是一个插件式框架，很多功能都可以i通过安装插件的方式扩展。下面介绍下它的简单使用。</p>
<a id="more"></a>

<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>首先要安装 node 和 npm 环境，然后再执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 初始化项目（生成package.json文件）</span><br><span class="line">	npm init -y</span><br><span class="line">2. 安装koa</span><br><span class="line">	npm install --save koa （--save表示安装到生产环境 --save-dev表示安装到开发环境）</span><br><span class="line">3. 运行koa服务</span><br><span class="line">	node index.js</span><br></pre></td></tr></table></figure>



<p>环境搭建完成后，可以写一个简单的demo：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="comment">// 引入Koa</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化 koa</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctx: request和response对象都保存在ctx里面</span></span><br><span class="line"><span class="comment">// =&gt; 箭头函数</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">'hello koa'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听端口</span></span><br><span class="line">app.listen(<span class="number">8090</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'koa server starting ...'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">或者可以这样写：</span></span><br><span class="line"><span class="comment">app.listen(8090, ()=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log('koa server starting ...');</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>写完后，执行 node demo.js，然后再浏览器上输入 localhost:8090，可以看到，返回了 “hello koa”。</p>
<h2 id="定义get请求"><a href="#定义get请求" class="headerlink" title="定义get请求"></a>定义get请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// query：返回的是格式化好的参数对象</span></span><br><span class="line"><span class="comment">// querystring:  返回的是请求字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 请求url</span></span><br><span class="line">    <span class="keyword">let</span> url = ctx.url;</span><br><span class="line">    <span class="comment">// 获取request对象，并通过request对象接收请求信息</span></span><br><span class="line">    <span class="keyword">let</span> request = ctx.request;</span><br><span class="line">    <span class="keyword">let</span> query = request.query;</span><br><span class="line">    <span class="keyword">let</span> queryString = request.querystring;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从上下文ctx中直接获取请求信息</span></span><br><span class="line">    <span class="comment">// let ctx_query = ctx.query;</span></span><br><span class="line">    <span class="comment">// let ctx_querystring = ctx.querystring;</span></span><br><span class="line"></span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        url,</span><br><span class="line">        query,</span><br><span class="line">        queryString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8090</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'koa server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的服务启动后，使用 postman 访问，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postman 访问的url为：localhost:8090&#x2F;?name&#x3D;wyzane&amp;age&#x3D;18</span><br><span class="line">postman 接收到的结果为：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;url&quot;: &quot;&#x2F;?name&#x3D;wyzane&amp;age&#x3D;18&quot;,</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;wyzane&quot;,</span><br><span class="line">        &quot;age&quot;: &quot;18&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;queryString&quot;: &quot;name&#x3D;wyzane&amp;age&#x3D;18&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="定义post请求"><a href="#定义post请求" class="headerlink" title="定义post请求"></a>定义post请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.url===<span class="string">'/'</span> &amp;&amp; ctx.method===<span class="string">'GET'</span>)&#123;</span><br><span class="line">        <span class="comment">// 显示表单页面</span></span><br><span class="line">        <span class="keyword">let</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;h1&gt;Koa2 Class&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;form method="POST" action="/"&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;username:&lt;/p&gt; &lt;input name="userName" /&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;age:&lt;/p&gt; &lt;input name="userAge" /&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;website:&lt;/p&gt; &lt;input name="website" /&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">                &lt;button type="submit"&gt;sibmit&lt;/submit&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;</span></span><br><span class="line"><span class="string">        `</span>;</span><br><span class="line">        ctx.body = html;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ctx.url===<span class="string">'/'</span> &amp;&amp; ctx.method===<span class="string">'POST'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> postParams = <span class="keyword">await</span> parse(ctx);</span><br><span class="line">        ctx.body = postParams;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ctx.body = <span class="string">'&lt;h1&gt;404!&lt;/h1&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> postParams = <span class="string">''</span>;</span><br><span class="line">            ctx.req.addListener(<span class="string">'data'</span>, (data)=&gt;&#123;</span><br><span class="line">                postParams += data;</span><br><span class="line">            &#125;)</span><br><span class="line">            ctx.req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> postData = parseQuery(postParams);</span><br><span class="line">                resolve(postData);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseQuery</span>(<span class="params">queryStr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 解析 post 请求参数 */</span></span><br><span class="line">    <span class="keyword">let</span> queryData = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> queryStrList = queryStr.split(<span class="string">'&amp;'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(queryStrList);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> itemStr <span class="keyword">of</span> queryStrList)&#123;</span><br><span class="line">        <span class="keyword">let</span> item = itemStr.split(<span class="string">'='</span>);</span><br><span class="line">        queryData[item[<span class="number">0</span>]] = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queryData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8091</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.request与ctx.req的区别</span><br><span class="line">ctx.request: 是koa2中的context经过封装的请求对象，它用起来更直观和简单</span><br><span class="line">ctx.req: 是context提供的nodejs原生http请求对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解析Post请求的步骤</span><br><span class="line">1. 解析上下文ctx中的原生nodejs对象req</span><br><span class="line">2. 将post表单数据解析成query string字符串（例如user&#x3D;wyzane&amp;age&#x3D;18）</span><br><span class="line">3. 将字符串转换成json格式</span><br></pre></td></tr></table></figure>

<p>上面的代码中，解析 post 请求参数时，是通过直接解析字符串的方式，对于处理 post 请求，下面还会介绍一些中间件用来处理 post 请求的参数。</p>
<h2 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h2><p>路由是服务端开发很重要的一个方面，Koa2 中我们可以使用 koa-router 插件来实现路由。</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save koa-router</span><br></pre></td></tr></table></figure>

<p>下面看一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收get请求</span></span><br><span class="line">router.get(<span class="string">'/'</span>, (ctx, next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello wyzane'</span></span><br><span class="line">&#125;);</span><br><span class="line">router.get(<span class="string">'/get'</span>, (ctx, next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello get'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes()表示装载路由，allowedMethods()表示只接收某种方法，不接收其他方法</span></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8093</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>启动上面的服务后，在浏览器上请求 <a href="http://localhost:8093/" target="_blank" rel="noopener">http://localhost:8093/</a> 或者 <a href="http://localhost:8093/get，回得到不同的响应信息。" target="_blank" rel="noopener">http://localhost:8093/get，回得到不同的响应信息。</a></p>
<p>我们还可以给路由加上前缀：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化路由时指定前缀</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    prefix: <span class="string">'/wyzane'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收gei请求</span></span><br><span class="line">router.get(<span class="string">'/'</span>, (ctx, next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello wyzane'</span></span><br><span class="line">&#125;);</span><br><span class="line">router.get(<span class="string">'/get'</span>, (ctx, next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello get'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes()表示装载路由，allowedMethods()表示只接收某种方法，不接收其他方法</span></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8093</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>启动上面的服务后，在浏览器上请求 <a href="http://localhost:8093/wyzane" target="_blank" rel="noopener">http://localhost:8093/wyzane</a> 或者 <a href="http://localhost:8093/wyzane/get，回得到不同的响应信息。" target="_blank" rel="noopener">http://localhost:8093/wyzane/get，回得到不同的响应信息。</a></p>
<p>除了上面给路由添加前缀，还可以定义父子路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子路由</span></span><br><span class="line"><span class="keyword">const</span> home = <span class="keyword">new</span> Router();</span><br><span class="line">home.get(<span class="string">'/info'</span>, <span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello info'</span>;</span><br><span class="line">&#125;).get(<span class="string">'/todo'</span>, <span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello todo'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> interest = <span class="keyword">new</span> Router();</span><br><span class="line">interest.get(<span class="string">'/basket'</span>, <span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello basket'</span>;</span><br><span class="line">&#125;).get(<span class="string">'/soccer'</span>, <span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello soccer'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父级路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载子路由到父路由</span></span><br><span class="line">router.use(<span class="string">'/home'</span>, home.routes(), home.allowedMethods());</span><br><span class="line">router.use(<span class="string">'/interest'</span>, interest.routes(), interest.allowedMethods());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// routes()表示装载路由，allowedMethods()表示只接收某种方法，不接收其他方法</span></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8093</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码中，有以下路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8093&#x2F;home&#x2F;info</span><br><span class="line">http:&#x2F;&#x2F;localhost:8093&#x2F;home&#x2F;todo</span><br><span class="line">http:&#x2F;&#x2F;localhost:8093&#x2F;interest&#x2F;basket</span><br><span class="line">http:&#x2F;&#x2F;localhost:8093&#x2F;interest&#x2F;soccer</span><br></pre></td></tr></table></figure>



<h2 id="请求体解析"><a href="#请求体解析" class="headerlink" title="请求体解析"></a>请求体解析</h2><p>解析请求体有很多插件，下面介绍几种。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">koa-body：可以解析 x-www-form-urlencoded和json类型的请求体</span><br><span class="line">	安装：npm install --save koa-body</span><br><span class="line"></span><br><span class="line">koa-bodyparse：可以解析 x-www-form-urlencoded和json类型的请求体</span><br><span class="line">	安装：npm install --save koa-bodyparse</span><br><span class="line"></span><br><span class="line">multy: 上面的中间件都不能解析form-data类型的请求体，该中间件则可以解析form-data类型的请求体(只能解析该类型)</span><br><span class="line">	安装：npm install --save multy</span><br></pre></td></tr></table></figure>



<p>下面分别看以下它们使用的例子。</p>
<p>koa-body 的使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.body);</span><br><span class="line">    ctx.body = ctx.request.body;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8099</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>koa-bodyparser 的使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.body);</span><br><span class="line">    ctx.body = ctx.request.body;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8099</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>multy 的使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Multy = <span class="built_in">require</span>(<span class="string">'multy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(Multy());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.body);</span><br><span class="line">    ctx.body = ctx.request.body;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8099</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>查看请求体信息时，都可以在 ctx.request.body 中查看。</p>
<p>Koa2 是一个小巧、灵活、强大的 web 服务端框架，对于经常写 python 或者 java 的小伙伴来说，它的代码风格、开发方式都会吸引我们去探讨一番。</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>Python3中如何使用Fabric</title>
    <url>/blog/2019/12/22/Python3%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Fabric/</url>
    <content><![CDATA[<p>Fabric是基于Python实现的SSH命令行工具，简化了SSH的应用程序部署及系统管理任务，它提供了系统基础的操作组件，可以实现本地或远程shell命令，包括：命令执行、文件上传、下载及完整执行日志输出等功能。Fabric在Paramiko的基础上做了更高一层的封装，操作起来会更加简单。</p>
<a id="more"></a>

<h2 id="Fabric的使用"><a href="#Fabric的使用" class="headerlink" title="Fabric的使用"></a>Fabric的使用</h2><p>Fabric中，fabric和fabric2是官方版本，fabric3是从fabric中fork出来的非官方版本。</p>
<p>今天介绍下 python3 中 Fabric 的使用，即 fabric3 的使用。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install fabric3</span><br></pre></td></tr></table></figure>



<h3 id="初次使用"><a href="#初次使用" class="headerlink" title="初次使用"></a>初次使用</h3><p>使用 fabric3 时，先创建一个 fabric 文件（文件名为 fabfile.py 或者其他名称）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fabfile.py:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello fabric"</span>)</span><br></pre></td></tr></table></figure>

<p>然后再执行 fab hello，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello fabric</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<p>执行fab命令时，若文件名是 fabfile.py，则可以不用指定。文件名不是 fabfile.py 时，需要使用 -f 指定文件名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hi fabric"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello2</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"hello:"</span>, name)</span><br></pre></td></tr></table></figure>

<p>执行 fab -f test hello，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hi fabric</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<p>执行函数时添加参数：fab -f test hello2:name=wyzane，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello: wyzane</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>



<h3 id="再次使用"><a href="#再次使用" class="headerlink" title="再次使用"></a>再次使用</h3><p>在 fabric 中，在本地执行命令可以使用 fabric.api 中的 local 方法。</p>
<h4 id="启动Django项目"><a href="#启动Django项目" class="headerlink" title="启动Django项目"></a>启动Django项目</h4><p>使用 fabric 启动 Django 项目。新建 Django 项目，目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DjangoFabric</span><br><span class="line">	- DjangoFabric</span><br><span class="line">	- templates</span><br><span class="line">	- manage.py</span><br><span class="line">	- fabfile.py</span><br></pre></td></tr></table></figure>

<p>fabfile.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startup</span><span class="params">()</span>:</span></span><br><span class="line">    local(<span class="string">"python manage.py runserver"</span>)</span><br></pre></td></tr></table></figure>

<p>执行 fab startup，会启动 Django 项目。</p>
<h4 id="执行Git命令"><a href="#执行Git命令" class="headerlink" title="执行Git命令"></a>执行Git命令</h4><p>在 git 仓库下，创建 fabfile.py 文件，文件内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">git_pull</span><span class="params">()</span>:</span></span><br><span class="line">    local(<span class="string">"git pull origin master"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">git_push</span><span class="params">()</span>:</span></span><br><span class="line">    local(<span class="string">"git add . &amp;&amp; git commit -m 'test' &amp;&amp; git push"</span>)</span><br></pre></td></tr></table></figure>

<p>执行 fab git_pull 和 fab git_push 后，会进行代码的拉取和推送操作，这样看起来确实很方便。</p>
<h4 id="执行Linux命令"><a href="#执行Linux命令" class="headerlink" title="执行Linux命令"></a>执行Linux命令</h4><p>远程登陆到服务器，然后执行 Linux 命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">env.hosts = [<span class="string">'192.168.172.128'</span>]</span><br><span class="line">env.user = <span class="string">'wyzane'</span></span><br><span class="line">env.password = <span class="string">'wyzane'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># run：执行 Linux 命令</span></span><br><span class="line">    run(<span class="string">'touch /home/wyzane/tmp.txt'</span>)</span><br></pre></td></tr></table></figure>

<p>执行 fab cmd，就会在服务器上创建 tmp.txt 文件。</p>
<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric.operations.put((local_path&#x3D;None, remote_path&#x3D;None, use_sudo&#x3D;False, mirror_local_mode&#x3D;False, mode&#x3D;None, use_glob&#x3D;True, temp_dir&#x3D;&#39;&#39;))</span><br></pre></td></tr></table></figure>

<p>使用上面的函数进行文件上传，或者使用 fabric.api 中的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.operations <span class="keyword">import</span> put</span><br><span class="line"><span class="keyword">from</span> fabric.operations <span class="keyword">import</span> env</span><br><span class="line"><span class="comment"># 或者使用 from fabric.api import put, env</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">env.hosts = [<span class="string">'192.168.172.128'</span>]</span><br><span class="line">env.user = <span class="string">'wyzane'</span></span><br><span class="line">env.password = <span class="string">'wyzane'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># put：上传文件到远程服务器</span></span><br><span class="line">    put(<span class="string">'mem.py'</span>, <span class="string">'/home/wyzane/'</span>)</span><br></pre></td></tr></table></figure>

<p>执行 fab upload，就会将文件上传到服务器。</p>
<h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric.operations.get(remote_path, local_path&#x3D;None, use_sudo&#x3D;False, temp_dir&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>使用上面的函数进行文件下载，可以下载单个文件，也可以下载一个文件夹。返回值是一个列表，列表中的元素是下载文件在本地的路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.operations <span class="keyword">import</span> get</span><br><span class="line"><span class="keyword">from</span> fabric.operations <span class="keyword">import</span> env</span><br><span class="line"><span class="comment"># 或者使用 from fabric.api import get, env</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">env.hosts = [<span class="string">'192.168.172.128'</span>]</span><br><span class="line">env.user = <span class="string">'wyzane'</span></span><br><span class="line">env.password = <span class="string">'wyzane'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">    results = get(<span class="string">"/home/wyzane/test"</span>)</span><br><span class="line">    print(results)</span><br><span class="line">    </span><br><span class="line"><span class="string">"""返回结果如下：</span></span><br><span class="line"><span class="string">['D:\\pyprojects\\DjangoFabric\\192.168.172.128\\test\\tmp2.txt', 'D:\\pyprojects\\DjangoFabric\\192.168.172.128\\test\\tmp1.txt']</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>下面介绍下 fabric 中的常用 API，下面的 API 可以从 fabric.operations 引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. get(remote_path, local_path&#x3D;None, use_sudo&#x3D;False, temp_dir&#x3D;&#39;&#39;)：从远程服务器上下载一个或者多个文件</span><br><span class="line">2. local(command, capture&#x3D;False, shell&#x3D;None)：在本地运行命令，像上面的 git 命令</span><br><span class="line">3. put(local_path&#x3D;None, remote_path&#x3D;None, use_sudo&#x3D;False, mirror_local_mode&#x3D;False, mode&#x3D;None, use_glob&#x3D;True, temp_dir&#x3D;&#39;&#39;)：上传一个或者多个文件到远程服务器</span><br><span class="line">4. reboot(wait&#x3D;120, command&#x3D;&#39;reboot&#39;, use_sudo&#x3D;True)：重启远程服务器</span><br><span class="line">5. run(command, shell&#x3D;True, pty&#x3D;True, combine_stderr&#x3D;None, quiet&#x3D;False, warn_only&#x3D;False, stdout&#x3D;None, stderr&#x3D;None, timeout&#x3D;None, shell_escape&#x3D;None, capture_buffer_size&#x3D;None)：在远程服务器上运行shell命令</span><br><span class="line">6. sudo(command, shell&#x3D;True, pty&#x3D;True, combine_stderr&#x3D;None, user&#x3D;None, quiet&#x3D;False, warn_only&#x3D;False, stdout&#x3D;None, stderr&#x3D;None, group&#x3D;None, timeout&#x3D;None, shell_escape&#x3D;None, capture_buffer_size&#x3D;None)：以超级用户权限在远程服务器上运行shell命令</span><br></pre></td></tr></table></figure>

<p>fabric 文档地址为：<a href="http://docs.fabfile.org/en/1.14/" target="_blank" rel="noopener">http://docs.fabfile.org/en/1.14/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3中生成器和协程的使用</title>
    <url>/blog/2020/09/13/Python3%E4%B8%AD%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>今天整理下 Python3 中生成器和协程的使用。</p>
<a id="more"></a>

<h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><h2 id="生成器输出数据"><a href="#生成器输出数据" class="headerlink" title="生成器输出数据"></a>生成器输出数据</h2><p>python 中可以使用 yield 关键字实现生成器，简单点说就是：一个函数中，如果包含 yield 关键字，那么这个函数就是一个生成器。下面看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""生成器：yield的使用</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    print(<span class="string">"=======start======="</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"=====flag:"</span>, flag)</span><br><span class="line">        flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">"========end========="</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""调用生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    t = test()</span><br><span class="line">    print(t)</span><br><span class="line">    print(next(t))</span><br><span class="line">    print(next(t))</span><br><span class="line">    print(next(t))</span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>上面代码的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;generator object test at 0x000001726581C2B0&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flag: 0</span><br><span class="line">0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flag: 1</span><br><span class="line">1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flag: 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>从上面的输出结果中可以看出，每次调用next()，都会从上一次结束的地方执行。 相当于遇到 yield 时，会跳出当前代码的执行，再次调用next()时，会从上一次跳出的地方开始执行 (即print(“========end=========”)这行代码试下一次执行的开始)。调用生成器时可以使用 next() 函数，也可以使用生成器的 <code>__next__</code>() 方法来获取值。</p>
<h2 id="生成器接收外部数据"><a href="#生成器接收外部数据" class="headerlink" title="生成器接收外部数据"></a>生成器接收外部数据</h2><p>在生成器中，yield 还可以接收外部传进来的值，例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""生成器：yield接收外部传入的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        x = <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">"=====x:"</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"OK"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t = test()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 第一次调用生成器的send()方法时，传入一个None值，用于启动生成器。</span></span><br><span class="line">        <span class="comment"># 调用 send()，相当于调用 next()，执行到 yield 时，会返回 yield 后面的值</span></span><br><span class="line">        ret = t.send(<span class="literal">None</span>)</span><br><span class="line">        print(<span class="string">"=====ret1:"</span>, ret)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二次调用 send() 时，执行到 x = yield i 部分，相当于 x 接收到了通过 send() 传入的值</span></span><br><span class="line">        ret = t.send(<span class="number">9</span>)</span><br><span class="line">        print(<span class="string">"=====ret2:"</span>, ret)</span><br><span class="line"></span><br><span class="line">        ret = t.send(<span class="number">8</span>)</span><br><span class="line">        print(<span class="string">"=====ret3:"</span>, ret)</span><br><span class="line"></span><br><span class="line">        ret = t.send(<span class="number">7</span>)</span><br><span class="line">        print(<span class="string">"=====ret4:"</span>, ret)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exp:</span><br><span class="line">        print(<span class="string">"=====value:"</span>, exp.value)</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>上面代码的输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ret1: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;x: 9</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ret2: 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;x: 8</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;value: OK</span><br></pre></td></tr></table></figure>

<p>当生成器中 yield 后没有值返回时，再调用 send() 或者 next() 会抛出 StopIteration 异常，所以我们需要捕获该异常。若生成器中有返回值，可以在捕获异常时获取它。</p>
<h2 id="使用for循环遍历生成器"><a href="#使用for循环遍历生成器" class="headerlink" title="使用for循环遍历生成器"></a>使用for循环遍历生成器</h2><p>生成器中的值也可以通过 for 循环获取，类似于调用 next() 方法，例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""使用 for 循环调用生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    t = test()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">        print(i)</span><br><span class="line">          </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<p>协程，更像是一个过程，类似线程和进程，协程是由调用方来控制程序执行和切换的过程。python 中的协程是由生成器转化而来，即通过扩展生成器的功能来实现协程。</p>
<p>python中，生成器和协程一样，都是使用了 yield 关键字的函数，但是通常来说，生成器仅仅是向外部输出数据，并将代码的执行交给调用方，协程不仅可以向外部输出数据，还能通过 send() 方法接收外部传进来的数据，即 yield data 和 x = yield data。yield 类似于一种控制流程的方式。</p>
<h1 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h1><p>一个含有 yield from 的方法也是一个生成器，与 yield 不同的是，yield from 后面如果跟一个生成器，那么可以直接调用这个生成器，而不再需要 next() 函数。yield from 后面也可一跟一个可迭代对象，此时相比于 for 循环加 yield 输出数据要方便。例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test01</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""yield from 后面可以跟一个可迭代对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test02</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""yield from 后面跟一个生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"=====start====="</span>)</span><br><span class="line">    ret = <span class="keyword">yield</span> <span class="keyword">from</span> test01()</span><br><span class="line">    <span class="comment"># 还可以获取子生成器的值</span></span><br><span class="line">    print(<span class="string">"=====ret:"</span>, ret)</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t = test02()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">"=====t1:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t2:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t3:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t4:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t5:"</span>, next(t))</span><br><span class="line">        print(<span class="string">"=====t6:"</span>, next(t))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>上面代码的输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t1: 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t2: 2</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t3: 3</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t4: 4</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;t5: 5</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ret: ok</span><br></pre></td></tr></table></figure>

<p>可以看出，生成器 test02() 里面嵌套了一个生成器 test01()。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中jieba的使用</title>
    <url>/blog/2019/12/29/Python%E4%B8%ADjieba%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>jieba 是一个中文分词词库，对中文分词的处理非常方便，下面介绍下它的使用。</p>
<a id="more"></a>

<h2 id="jieba的使用"><a href="#jieba的使用" class="headerlink" title="jieba的使用"></a>jieba的使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式1：</span><br><span class="line">pip install jieba</span><br><span class="line"></span><br><span class="line">方式2：</span><br><span class="line">先下载 http:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;jieba&#x2F;</span><br><span class="line">然后解压，运行 python setup.py install</span><br></pre></td></tr></table></figure>

<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>下面介绍下jieba的主要功能，具体信息可参考github文档：<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">https://github.com/fxsjy/jieba</a></p>
<h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><p>jieba常用的三种模式：</p>
<ol>
<li>精确模式，试图将句子最精确地切开，适合文本分析；</li>
<li>全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；</li>
<li>搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。</li>
</ol>
<p>可使用 <code>jieba.cut</code> 和 <code>jieba.cut_for_search</code> 方法进行分词，两者所返回的结构都是一个可迭代的 generator，可使用 for 循环来获得分词后得到的每一个词语（unicode），或者直接使用 <code>jieba.lcut</code> 以及 <code>jieba.lcut_for_search</code> 返回 list。</p>
<p><code>jieba.Tokenizer(dictionary=DEFAULT_DICT)</code> ：使用该方法可以自定义分词器，可以同时使用不同的词典。<code>jieba.dt</code> 为默认分词器，所有全局分词相关函数都是该分词器的映射。</p>
<p> <code>jieba.cut</code> 和 <code>jieba.lcut</code> 可接受的参数如下：</p>
<ol>
<li>需要分词的字符串（unicode 或 UTF-8 字符串、GBK 字符串）</li>
<li>cut_all：是否使用全模式，默认值为 <code>False</code></li>
<li>HMM：用来控制是否使用 HMM 模型，默认值为 <code>True</code></li>
</ol>
<p><code>jieba.cut_for_search</code> 和 <code>jieba.lcut_for_search</code> 接受 2 个参数：</p>
<ol>
<li>需要分词的字符串（unicode 或 UTF-8 字符串、GBK 字符串）</li>
<li>HMM：用来控制是否使用 HMM 模型，默认值为 <code>True</code></li>
</ol>
<p>需要注意的是，尽量不要使用 GBK 字符串，可能无法预料地错误解码成 UTF-8。</p>
<p>三种分词模式的比较：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全匹配</span></span><br><span class="line">seg_list = jieba.cut(<span class="string">"今天哪里都没去，在家里睡了一天"</span>, cut_all=<span class="literal">True</span>)</span><br><span class="line">print(list(seg_list))  <span class="comment"># ['今天', '哪里', '都', '没去', '', '', '在家', '家里', '睡', '了', '一天']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精确匹配 默认模式</span></span><br><span class="line">seg_list = jieba.cut(<span class="string">"今天哪里都没去，在家里睡了一天"</span>, cut_all=<span class="literal">False</span>)</span><br><span class="line">print(list(seg_list))  <span class="comment"># ['今天', '哪里', '都', '没', '去', '，', '在', '家里', '睡', '了', '一天']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精确匹配</span></span><br><span class="line">seg_list = jieba.cut_for_search(<span class="string">"今天哪里都没去，在家里睡了一天"</span>)</span><br><span class="line">print(list(seg_list))  <span class="comment"># ['今天', '哪里', '都', '没', '去', '，', '在', '家里', '睡', '了', '一天']</span></span><br></pre></td></tr></table></figure>



<h4 id="自定义词典"><a href="#自定义词典" class="headerlink" title="自定义词典"></a>自定义词典</h4><p>开发者可以指定自己自定义的词典，以便包含 jieba 词库里没有的词。<br>用法： jieba.load_userdict(dict_path)  </p>
<p>dict_path：为自定义词典文件的路径</p>
<p>词典格式如下：</p>
<p>一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。</p>
<p>下面使用一个例子说明一下：</p>
<p>自定义字典 user_dict.txt：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大学课程</span><br><span class="line">深度学习</span><br></pre></td></tr></table></figure>

<p>下面比较下精确匹配、全匹配和使用自定义词典的区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_sent = <span class="string">"""</span></span><br><span class="line"><span class="string">数学是一门基础性的大学课程，深度学习是基于数学的，尤其是线性代数课程</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">words = jieba.cut(test_sent)</span><br><span class="line">print(list(words))</span><br><span class="line"><span class="comment"># ['\n', '数学', '是', '一门', '基础性', '的', '大学', '课程', '，', '深度',</span></span><br><span class="line"><span class="comment"># '学习', '是', '基于', '数学', '的', '，', '尤其', '是', '线性代数', '课程', '\n']</span></span><br><span class="line"></span><br><span class="line">words = jieba.cut(test_sent, cut_all=<span class="literal">True</span>)</span><br><span class="line">print(list(words))</span><br><span class="line"><span class="comment"># ['\n', '数学', '是', '一门', '基础', '基础性', '的', '大学', '课程', '', '', '深度',</span></span><br><span class="line"><span class="comment"># '学习', '是', '基于', '数学', '的', '', '', '尤其', '是', '线性', '线性代数', '代数', '课程', '\n']</span></span><br><span class="line"></span><br><span class="line">jieba.load_userdict(<span class="string">"userdict.txt"</span>)</span><br><span class="line">words = jieba.cut(test_sent)</span><br><span class="line">print(list(words))</span><br><span class="line"><span class="comment"># ['\n', '数学', '是', '一门', '基础性', '的', '大学课程', '，', '深度学习', '是',</span></span><br><span class="line"><span class="comment"># '基于', '数学', '的', '，', '尤其', '是', '线性代数', '课程', '\n']</span></span><br><span class="line"></span><br><span class="line">jieba.add_word(<span class="string">"尤其是"</span>)</span><br><span class="line">jieba.add_word(<span class="string">"线性代数课程"</span>)</span><br><span class="line"></span><br><span class="line">words = jieba.cut(test_sent)</span><br><span class="line">print(list(words))</span><br><span class="line"><span class="comment"># ['\n', '数学', '是', '一门', '基础性', '的', '大学课程', '，', '深度学习', '是',</span></span><br><span class="line"><span class="comment"># '基于', '数学', '的', '，', '尤其是', '线性代数课程', '\n']</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子中可以看出，使用自定义词典与使用默认词典的区别。</p>
<p>jieba.add_word()：向自定义字典中添加词语</p>
<h4 id="关键词提取"><a href="#关键词提取" class="headerlink" title="关键词提取"></a>关键词提取</h4><p>可以基于 TF-IDF  算法进行关键词提取，也可以基于extRank 算法。 TF-IDF  算法与 elasticsearch 中使用的算法是一样的。</p>
<p>使用 jieba.analyse.extract_tags() 函数进行关键词提取，其参数如下：</p>
<p>jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=())</p>
<ol>
<li>sentence 为待提取的文本</li>
<li>topK 为返回几个 TF/IDF 权重最大的关键词，默认值为 20</li>
<li>withWeight 为是否一并返回关键词权重值，默认值为 False</li>
<li>allowPOS 仅包括指定词性的词，默认值为空，即不筛选</li>
<li>jieba.analyse.TFIDF(idf_path=None) 新建 TFIDF 实例，idf_path 为 IDF 频率文件</li>
</ol>
<p>也可以使用 jieba.analyse.TFIDF(idf_path=None) 新建 TFIDF 实例，idf_path 为 IDF 频率文件。</p>
<p>基于 TF-IDF 算法的关键词抽取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"></span><br><span class="line">file = <span class="string">"sanguo.txt"</span></span><br><span class="line">topK = <span class="number">12</span></span><br><span class="line">content = open(file, <span class="string">'rb'</span>).read()</span><br><span class="line"></span><br><span class="line">tags = jieba.analyse.extract_tags(content, topK=topK)</span><br><span class="line">print(tags)</span><br><span class="line"><span class="comment"># ['玄德', '程远志', '张角', '云长', '张飞', '黄巾', '封谞', '刘焉', '邓茂', '邹靖', '姓名', '招军']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># withWeight=True：将权重值一起返回</span></span><br><span class="line">tags = jieba.analyse.extract_tags(content, topK=topK, withWeight=<span class="literal">True</span>)</span><br><span class="line">print(tags)</span><br><span class="line"><span class="comment"># [('玄德', 0.1038549799467099), ('程远志', 0.07787459004363208), ('张角', 0.0722532891360849),</span></span><br><span class="line"><span class="comment"># ('云长', 0.07048801593691037), ('张飞', 0.060972692853113214), ('黄巾', 0.058227157790330185),</span></span><br><span class="line"><span class="comment"># ('封谞', 0.0563904127495283), ('刘焉', 0.05470798376886792), ('邓茂', 0.04917692565566038),</span></span><br><span class="line"><span class="comment"># ('邹靖', 0.04427258239705188), ('姓名', 0.04219704283997642), ('招军', 0.04182041076757075)]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是读取文件，提取出现频率最高的前12个词。</p>
<p>TF-IDF的原理如下：</p>
<p>词频 (term frequency, TF) 指的是某一个给定的词语在该文件中出现的次数。这个数字通常会被归一化(一般是词频除以文章总词数)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TF &#x3D; 词条W出现的次数&#x2F;所有词条的数量</span><br></pre></td></tr></table></figure>



<p>逆向文件频率 (inverse document frequency, IDF) IDF的主要思想是：如果包含词条t的文档越少, IDF越大，则说明词条具有很好的类别区分能力。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IDF &#x3D; log(语料库文档总数&#x2F;(包含词条W的文档总数 + 1))</span><br></pre></td></tr></table></figure>

<p>关键词提取所使用逆向文件频率（IDF）文本语料库，当提取的结果不是我们想要的结果时，我们可以自定义IDF文本语料库。</p>
<h4 id="词性标注"><a href="#词性标注" class="headerlink" title="词性标注"></a>词性标注</h4><p>词性标注主要是标记文本分词后每个词的词性，使用例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认模式</span></span><br><span class="line">seg_list = pseg.cut(<span class="string">"今天哪里都没去，在家里睡了一天"</span>)</span><br><span class="line"><span class="keyword">for</span> word, flag <span class="keyword">in</span> seg_list:</span><br><span class="line">    print(word + <span class="string">" "</span> + flag)</span><br><span class="line">   </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用 jieba 默认模式的输出结果是：</span></span><br><span class="line"><span class="string">我 r</span></span><br><span class="line"><span class="string">Prefix dict has been built successfully.</span></span><br><span class="line"><span class="string">今天 t</span></span><br><span class="line"><span class="string">吃 v</span></span><br><span class="line"><span class="string">早饭 n</span></span><br><span class="line"><span class="string">了 ul</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># paddle 模式</span></span><br><span class="line">words = pseg.cut(<span class="string">"我今天吃早饭了"</span>,use_paddle=<span class="literal">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用 paddle 模式的输出结果是：</span></span><br><span class="line"><span class="string">我 r</span></span><br><span class="line"><span class="string">今天 TIME</span></span><br><span class="line"><span class="string">吃 v</span></span><br><span class="line"><span class="string">早饭 n</span></span><br><span class="line"><span class="string">了 xc</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>paddle模式的词性对照表如下：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>含义</th>
<th>标签</th>
<th>含义</th>
<th>标签</th>
<th>含义</th>
<th>标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>普通名词</td>
<td>f</td>
<td>方位名词</td>
<td>s</td>
<td>处所名词</td>
<td>t</td>
<td>时间</td>
</tr>
<tr>
<td>nr</td>
<td>人名</td>
<td>ns</td>
<td>地名</td>
<td>nt</td>
<td>机构名</td>
<td>nw</td>
<td>作品名</td>
</tr>
<tr>
<td>nz</td>
<td>其他专名</td>
<td>v</td>
<td>普通动词</td>
<td>vd</td>
<td>动副词</td>
<td>vn</td>
<td>名动词</td>
</tr>
<tr>
<td>a</td>
<td>形容词</td>
<td>ad</td>
<td>副形词</td>
<td>an</td>
<td>名形词</td>
<td>d</td>
<td>副词</td>
</tr>
<tr>
<td>m</td>
<td>数量词</td>
<td>q</td>
<td>量词</td>
<td>r</td>
<td>代词</td>
<td>p</td>
<td>介词</td>
</tr>
<tr>
<td>c</td>
<td>连词</td>
<td>u</td>
<td>助词</td>
<td>xc</td>
<td>其他虚词</td>
<td>w</td>
<td>标点符号</td>
</tr>
<tr>
<td>PER</td>
<td>人名</td>
<td>LOC</td>
<td>地名</td>
<td>ORG</td>
<td>机构名</td>
<td>TIME</td>
<td>时间</td>
</tr>
</tbody></table>
<h4 id="获取词语位置"><a href="#获取词语位置" class="headerlink" title="获取词语位置"></a>获取词语位置</h4><p>将分本分词后，返回每个词和该词在原文中的起始位置，例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">result = jieba.tokenize(<span class="string">'今天哪里都没去，在家里睡了一天'</span>)</span><br><span class="line"><span class="keyword">for</span> tk <span class="keyword">in</span> result:</span><br><span class="line">    print(<span class="string">"word:"</span> + tk[<span class="number">0</span>] +</span><br><span class="line">          <span class="string">" start:"</span> + str(tk[<span class="number">1</span>]) +</span><br><span class="line">          <span class="string">" end:"</span> + str(tk[<span class="number">2</span>]))</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">word:华为技术有限公司 start:0 end:8</span></span><br><span class="line"><span class="string">word:的 start:8 end:9</span></span><br><span class="line"><span class="string">word:手机 start:9 end:11</span></span><br><span class="line"><span class="string">word:品牌 start:11 end:13</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 search 模式</span></span><br><span class="line">result = jieba.tokenize(<span class="string">'华为技术有限公司的手机品牌'</span>, mode=<span class="string">"search"</span>)</span><br><span class="line"><span class="keyword">for</span> tk <span class="keyword">in</span> result:</span><br><span class="line">    print(<span class="string">"word:"</span> + tk[<span class="number">0</span>] +</span><br><span class="line">          <span class="string">" start:"</span> + str(tk[<span class="number">1</span>]) +</span><br><span class="line">          <span class="string">" end:"</span> + str(tk[<span class="number">2</span>]))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">word:华为 start:0 end:2</span></span><br><span class="line"><span class="string">word:技术 start:2 end:4</span></span><br><span class="line"><span class="string">word:有限 start:4 end:6</span></span><br><span class="line"><span class="string">word:公司 start:6 end:8</span></span><br><span class="line"><span class="string">word:华为技术有限公司 start:0 end:8</span></span><br><span class="line"><span class="string">word:的 start:8 end:9</span></span><br><span class="line"><span class="string">word:手机 start:9 end:11</span></span><br><span class="line"><span class="string">word:品牌 start:11 end:13</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<h4 id="收索引擎"><a href="#收索引擎" class="headerlink" title="收索引擎"></a>收索引擎</h4><p>使用 jieba 和 whoosh 可以实现搜索引擎功能。</p>
<p>whoosh 是由python实现的一款全文搜索工具包，可以使用 pip 安装它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install whoosh</span><br></pre></td></tr></table></figure>

<p>介绍 jieba + whoosh 实现搜索之前，你可以先看下文 whoosh 的简单介绍。</p>
<p>下面看一个简单的搜索引擎的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> whoosh.fields <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> whoosh.index <span class="keyword">import</span> create_in</span><br><span class="line"><span class="keyword">from</span> whoosh.qparser <span class="keyword">import</span> QueryParser</span><br><span class="line"><span class="keyword">from</span> jieba.analyse <span class="keyword">import</span> ChineseAnalyzer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">analyzer = ChineseAnalyzer()</span><br><span class="line"></span><br><span class="line">schema = Schema(title=TEXT(stored=<span class="literal">True</span>),</span><br><span class="line">                path=ID(stored=<span class="literal">True</span>),</span><br><span class="line">                content=TEXT(stored=<span class="literal">True</span>,</span><br><span class="line">                             analyzer=analyzer))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"test"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 递归删除目录</span></span><br><span class="line">    shutil.rmtree(<span class="string">"test"</span>)</span><br><span class="line">    os.mkdir(<span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line">idx = create_in(<span class="string">"test"</span>, schema)</span><br><span class="line">writer = idx.writer()</span><br><span class="line"></span><br><span class="line">writer.add_document(</span><br><span class="line">    title=<span class="string">u"document1"</span>,</span><br><span class="line">    path=<span class="string">"/tmp1"</span>,</span><br><span class="line">    content=<span class="string">u"Tracy McGrady is a famous basketball player, the elegant basketball style of him attract me"</span>)</span><br><span class="line">writer.add_document(</span><br><span class="line">    title=<span class="string">u"document2"</span>,</span><br><span class="line">    path=<span class="string">"/tmp2"</span>,</span><br><span class="line">    content=<span class="string">u"Kobe Bryant is a famous basketball player too , the tenacious spirit of him also attract me"</span>)</span><br><span class="line">writer.add_document(</span><br><span class="line">    title=<span class="string">u"document3"</span>,</span><br><span class="line">    path=<span class="string">"/tmp3"</span>,</span><br><span class="line">    content=<span class="string">u"LeBron James is the player i do not like"</span>)</span><br><span class="line"></span><br><span class="line">writer.commit()</span><br><span class="line">searcher = idx.searcher()</span><br><span class="line">parser = QueryParser(<span class="string">"content"</span>, schema=idx.schema)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> keyword <span class="keyword">in</span> (<span class="string">"basketball"</span>, <span class="string">"elegant"</span>):</span><br><span class="line">    print(<span class="string">"searched keyword "</span>,keyword)</span><br><span class="line">    query= parser.parse(keyword)</span><br><span class="line">    results = searcher.search(query)</span><br><span class="line">    <span class="keyword">for</span> hit <span class="keyword">in</span> results:</span><br><span class="line">        print(hit.highlights(<span class="string">"content"</span>))</span><br><span class="line">    print(<span class="string">"="</span>*<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，使用 add_document() 把一个文档添加到了 index 中。在这些文档中，搜索含有 “basketball”和 “elegant” 的文档。</p>
<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Building prefix dict from the default dictionary ...</span><br><span class="line">Loading model from cache C:\Users\wyzane\AppData\Local\Temp\jieba.cache</span><br><span class="line">Loading model cost 0.754 seconds.</span><br><span class="line">Prefix dict has been built successfully.</span><br><span class="line">searched keyword  basketball</span><br><span class="line">McGrady is a famous &lt;b class&#x3D;&quot;match term0&quot;&gt;basketball&lt;&#x2F;b&gt; player, the elegant...&lt;b class&#x3D;&quot;match term0&quot;&gt;basketball&lt;&#x2F;b&gt; style of him attract me</span><br><span class="line">Bryant is a famous &lt;b class&#x3D;&quot;match term0&quot;&gt;basketball&lt;&#x2F;b&gt; player too , the tenacious</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">searched keyword  elegant</span><br><span class="line">basketball player, the &lt;b class&#x3D;&quot;match term0&quot;&gt;elegant&lt;&#x2F;b&gt; basketball style</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>



<p>更换搜索词时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> keyword <span class="keyword">in</span> (<span class="string">"LeBron"</span>, <span class="string">"Kobe"</span>):</span><br><span class="line">    print(<span class="string">"searched keyword "</span>,keyword)</span><br><span class="line">    query= parser.parse(keyword)</span><br><span class="line">    results = searcher.search(query)</span><br><span class="line">    <span class="keyword">for</span> hit <span class="keyword">in</span> results:</span><br><span class="line">        print(hit.highlights(<span class="string">"content"</span>))</span><br><span class="line">    print(<span class="string">"="</span>*<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>搜索结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Building prefix dict from the default dictionary ...</span><br><span class="line">Loading model from cache C:\Users\wyzane\AppData\Local\Temp\jieba.cache</span><br><span class="line">Loading model cost 0.801 seconds.</span><br><span class="line">Prefix dict has been built successfully.</span><br><span class="line">searched keyword  LeBron</span><br><span class="line">&lt;b class&#x3D;&quot;match term0&quot;&gt;LeBron&lt;&#x2F;b&gt; James is the player i do not like</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">searched keyword  Kobe</span><br><span class="line">&lt;b class&#x3D;&quot;match term0&quot;&gt;Kobe&lt;&#x2F;b&gt; Bryant is a famous basketball player too , the tenacious</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>



<p>上面是搜索英文，下面展示下搜索中文。</p>
<p>添加下面的文档数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer.add_document(</span><br><span class="line">    title=<span class="string">u"document1"</span>,</span><br><span class="line">    path=<span class="string">"/tmp1"</span>,</span><br><span class="line">    content=<span class="string">u"麦迪是一位著名的篮球运动员，他飘逸的打法深深吸引着我"</span>)</span><br><span class="line">writer.add_document(</span><br><span class="line">    title=<span class="string">u"document2"</span>,</span><br><span class="line">    path=<span class="string">"/tmp2"</span>,</span><br><span class="line">    content=<span class="string">u"科比是一位著名的篮球运动员，他坚韧的精神深深的感染着我"</span>)</span><br><span class="line">writer.add_document(</span><br><span class="line">    title=<span class="string">u"document3"</span>,</span><br><span class="line">    path=<span class="string">"/tmp3"</span>,</span><br><span class="line">    content=<span class="string">u"詹姆斯是我不喜欢的运动员"</span>)</span><br></pre></td></tr></table></figure>

<p>执行搜索：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> keyword <span class="keyword">in</span> (<span class="string">"篮球"</span>, <span class="string">"麦迪"</span>):</span><br><span class="line">    print(<span class="string">"searched keyword "</span>,keyword)</span><br><span class="line">    query= parser.parse(keyword)</span><br><span class="line">    results = searcher.search(query)</span><br><span class="line">    <span class="keyword">for</span> hit <span class="keyword">in</span> results:</span><br><span class="line">        print(hit.highlights(<span class="string">"content"</span>))</span><br><span class="line">    print(<span class="string">"="</span>*<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Building prefix dict from the default dictionary ...</span><br><span class="line">Loading model from cache C:\Users\wyzane\AppData\Local\Temp\jieba.cache</span><br><span class="line">Loading model cost 0.780 seconds.</span><br><span class="line">Prefix dict has been built successfully.</span><br><span class="line">searched keyword  篮球</span><br><span class="line">麦迪是一位著名的&lt;b class&#x3D;&quot;match term0&quot;&gt;篮球&lt;&#x2F;b&gt;运动员，他飘逸的打法深深吸引着我</span><br><span class="line">科比是一位著名的&lt;b class&#x3D;&quot;match term0&quot;&gt;篮球&lt;&#x2F;b&gt;运动员，他坚韧的精神深深的感染着我</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">searched keyword  麦迪</span><br><span class="line">&lt;b class&#x3D;&quot;match term0&quot;&gt;麦迪&lt;&#x2F;b&gt;是一位著名的篮球运动员，他飘逸的打法深深吸引着我</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>



<p>上面就简单介绍了 jieba + whoosh 实现搜索引擎的例子。其实要实现上面的搜索功能，在 elasticsearch 中可以更加简单，有兴趣的同学可以了解一下。</p>
<h3 id="whoosh"><a href="#whoosh" class="headerlink" title="whoosh"></a>whoosh</h3><p>下面介绍下 whoosh 的使用。</p>
<p>whoosh 官方文档为：<a href="https://whoosh.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://whoosh.readthedocs.io/en/latest/</a></p>
<p>使用 whoosh 之前，需要先定义 index 对象，同时创建 schema对象 与 index 对应。schema中包含一列字段，这些字段存放在 index 中。每个字段都是文档中的一部分信息，例如标题和文本内容。字段能被搜索或者存储。</p>
<p>定义一个 schema，由两个字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh.fields <span class="keyword">import</span> Schema, STORED, ID, KEYWORD, TEXT</span><br><span class="line"></span><br><span class="line">schema = Schema(title=TEXT(stored=<span class="literal">True</span>), content=TEXT,</span><br><span class="line">                path=ID(stored=<span class="literal">True</span>), tags=KEYWORD, </span><br><span class="line">                icon=STORED)</span><br></pre></td></tr></table></figure>



<p>我们仅需要创建一次 schema，当创建索引时，schema 会被序列化并与 index 保存在一起。</p>
<p>当创建 schema 对象时，需要指定字段名和其对应的类型，在 whoosh.fields 下，由如下类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ID：该类型索引字段的整个值作为一个单位类索引，而不是拆分成多个词</span><br><span class="line">TEXT：该类型适用于文本数据的正文，它为文本建立索引并存储术语位置以允许短语搜索</span><br><span class="line">NUMERIC：数值类型，可以存储整数或者浮点数</span><br><span class="line">BOOLEAN：Boolean类型</span><br><span class="line">DATETIME：适用于 datetime 对象</span><br><span class="line">KEYWORD：适用于空格或者标点分割的关键字，类型数据能被索引和搜索但是不支持短语搜索（为了节省空间）</span><br><span class="line">STORED：与文档存储在一起而不是与索引，该类型的数据不能被索引和搜索</span><br></pre></td></tr></table></figure>



<p>schema对象创建完成后，可以使用 create_in 函数创建索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> whoosh.index <span class="keyword">import</span> create_in</span><br><span class="line"><span class="keyword">from</span> whoosh.fields <span class="keyword">import</span> Schema, STORED, ID, KEYWORD, TEXT</span><br><span class="line"></span><br><span class="line">schema = Schema(title=TEXT(stored=<span class="literal">True</span>), content=TEXT,</span><br><span class="line">                path=ID(stored=<span class="literal">True</span>), tags=KEYWORD, </span><br><span class="line">                icon=STORED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"index"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"index"</span>)</span><br><span class="line">ix = create_in(<span class="string">"index"</span>, schema)</span><br></pre></td></tr></table></figure>

<p>创建 index 时，会创建一个存储对象来保存 index 信息。</p>
<p>通常，存储对象都会是 FileStorage，一种使用文件来存储索引的存储介质。</p>
<p>创建索引后，也可以通过 open_dir() 来打开索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from whoosh.index import open_dir</span><br><span class="line"></span><br><span class="line">ix &#x3D; open_dir(&quot;index&quot;)</span><br></pre></td></tr></table></figure>



<p>创建好 index 对象后，我们可以往里面添加文档。writer() 方法会返回一个 IndexWriter 对象，使用它可以向 index 中添加文档：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer = ix.writer()</span><br><span class="line">writer.add_document(title=<span class="string">u"My document"</span>, content=<span class="string">u"This is my document!"</span>,</span><br><span class="line">                    path=<span class="string">u"/a"</span>, tags=<span class="string">u"first short"</span>, icon=<span class="string">u"/icons/star.png"</span>)</span><br><span class="line">writer.add_document(title=<span class="string">u"Second try"</span>, content=<span class="string">u"This is the second example."</span>,</span><br><span class="line">                    path=<span class="string">u"/b"</span>, tags=<span class="string">u"second short"</span>, icon=<span class="string">u"/icons/sheep.png"</span>)</span><br><span class="line">writer.add_document(title=<span class="string">u"Third time's the charm"</span>, content=<span class="string">u"Examples are many."</span>,</span><br><span class="line">                    path=<span class="string">u"/c"</span>, tags=<span class="string">u"short"</span>, icon=<span class="string">u"/icons/book.png"</span>)</span><br><span class="line">writer.commit()  <span class="comment"># 保存文档到索引中</span></span><br></pre></td></tr></table></figure>

<p>添加文档时，没有必要对所有字段都添加值；能被索引的 TEXT 字段必须要传入一个 unicode 类型的值，仅仅被存储而不用来索引的字段可以传入任何可被序列化的对象。</p>
<p>文档存储到 index 后，就可以进行索引了，索引之前首先要创建一个 search 对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">searcher = ix.searcher()</span><br></pre></td></tr></table></figure>

<p>可以使用 with 语句，以便使 search 对象自动关闭，也可以使用 try … finally：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> ix.searcher() <span class="keyword">as</span> searcher:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    searcher = ix.searcher()</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    searcher.close()</span><br></pre></td></tr></table></figure>



<p>search 对象的 search() 方法需要传入一个 Query 对象。可以直接钩爪一个 Query 对象，也可以使用QueryParse构造一个 Query 对象。将 Query 对象传入 search() 方法中，可以得到一个 Results 对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh.query <span class="keyword">import</span> *</span><br><span class="line">myquery = And([Term(<span class="string">"content"</span>, <span class="string">u"apple"</span>), Term(<span class="string">"content"</span>, <span class="string">"bear"</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用</span></span><br><span class="line"><span class="keyword">from</span> whoosh.qparser <span class="keyword">import</span> QueryParser</span><br><span class="line">parser = QueryParser(<span class="string">"content"</span>, ix.schema)</span><br><span class="line">myquery = parser.parse(querystring)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">results = searcher.search(myquery)</span><br></pre></td></tr></table></figure>

<p>以上就是 whoosh 做搜索的基本步骤。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中多个装饰器的执行顺序</title>
    <url>/blog/2020/07/13/Python%E4%B8%AD%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>今天总结下 Python 中多个装饰器的执行顺序。</p>
<a id="more"></a>

<p>装饰器代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper_out1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'--out11--'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner1</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"--in11--"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"--in12--"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    print(<span class="string">"--out12--"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper_out2</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'--out21--'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner2</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"--in21--"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"--in22--"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    print(<span class="string">"--out22"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper_out2</span></span><br><span class="line"><span class="meta">@wrapper_out1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"--test--"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<p>执行后，打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">--out11--</span><br><span class="line">--out12--</span><br><span class="line">--out21--</span><br><span class="line">--out22--</span><br><span class="line">--in21--</span><br><span class="line">--in11--</span><br><span class="line">--test--</span><br><span class="line">--in12--</span><br><span class="line">--in22--</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>执行顺序以图片形式展示如下：</p>
<p><img src="python01.png" alt="python01"></p>
<p>先进入离test函数最近的装饰器，由于装饰器中返回的是函数的函数名引用，并非真正调用函数，所以先打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--out11--</span><br><span class="line">--out12--</span><br><span class="line">--out21--</span><br><span class="line">--out22--</span><br></pre></td></tr></table></figure>

<p>到inner2后，func会真正执行函数，会调用 inner1() ,所以再打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--in21--</span><br><span class="line">--in11--</span><br></pre></td></tr></table></figure>

<p>到 inner1 中，func 会调用test函数，所以会打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--test--</span><br></pre></td></tr></table></figure>

<p>再从各个函数出来后，会依次打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--in12--</span><br><span class="line">--in22--</span><br></pre></td></tr></table></figure>

<p>合起来就是上面的执行结果。</p>
<p>以上就是多个装饰器的执行顺序。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中如何查看对象的内存分配</title>
    <url>/blog/2020/04/11/Python%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>对于大多数开发者来说，项目运行时发生内存泄漏的情况可能都经历过，那么当Python项目发生这种情况时，我们如何排查呢？这时候就可以使用python中的 tracemalloc 和 objgraph 这两个库。下面介绍下它们的使用方法。</p>
<a id="more"></a>

<h2 id="tracemalloc的使用"><a href="#tracemalloc的使用" class="headerlink" title="tracemalloc的使用"></a>tracemalloc的使用</h2><p>不多说，先上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tracemalloc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryTrace</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">'frame'</span>, <span class="string">'mem_top'</span>, <span class="string">'key_type'</span>, <span class="string">'mapping_key_type'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, frame=<span class="number">1</span>, mem_top=<span class="number">10</span>, key_type=<span class="string">"lineno"</span>)</span>:</span></span><br><span class="line">        self.frame = frame</span><br><span class="line">        self.mem_top = mem_top</span><br><span class="line">        self.key_type = key_type</span><br><span class="line">        self.mapping_key_type = &#123;</span><br><span class="line">            <span class="string">"lineno"</span>: self.lineno,</span><br><span class="line">            <span class="string">"traceback"</span>: self.traceback,</span><br><span class="line">            <span class="string">"deference"</span>: self.deference,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            result = (self.mapping_key_type</span><br><span class="line">                      .get(self.key_type)</span><br><span class="line">                      (func, *args, **kwargs))</span><br><span class="line"></span><br><span class="line">            self.end()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lineno</span><span class="params">(self, func, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        display the files that most top memory was allocated</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">"========lineno======="</span>)</span><br><span class="line">        tracemalloc.start()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        snapshot = tracemalloc.take_snapshot()</span><br><span class="line">        top_stats = snapshot.statistics(<span class="string">"lineno"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> top <span class="keyword">in</span> top_stats[<span class="number">0</span>:self.mem_top]:</span><br><span class="line">            print(<span class="string">"mem-trace "</span>, top)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traceback</span><span class="params">(self, func, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        display the traceback of the biggest memory block</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">"========traceback======="</span>)</span><br><span class="line">        tracemalloc.start(self.frame)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        snapshot = tracemalloc.take_snapshot()</span><br><span class="line">        top_stats = snapshot.statistics(<span class="string">"traceback"</span>)</span><br><span class="line">        top_one = top_stats[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"blocks count: %s"</span> % top_one.count)</span><br><span class="line">        print(<span class="string">"size: %.1f KiB"</span> % (top_one.size / <span class="number">1024</span>))</span><br><span class="line">        <span class="keyword">for</span> top <span class="keyword">in</span> top_one.traceback.format():</span><br><span class="line">            print(<span class="string">"mem-trace "</span>, top)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deference</span><span class="params">(self, func, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        compute the deference between two snapshot</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tracemalloc.start(self.frame)</span><br><span class="line">        snapshot_start = tracemalloc.take_snapshot()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        snapshot_end = tracemalloc.take_snapshot()</span><br><span class="line">        top_stats = snapshot_end.compare_to(snapshot_start, <span class="string">"lineno"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> top <span class="keyword">in</span> top_stats[:self.mem_top]:</span><br><span class="line">            print(<span class="string">"mem-trace "</span>, top)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end</span><span class="params">(self)</span>:</span></span><br><span class="line">        trace_malloc_module_usage = tracemalloc.get_tracemalloc_memory()</span><br><span class="line">        print(<span class="string">"trace alloc module use memory: %.1f KiB"</span> %</span><br><span class="line">              (trace_malloc_module_usage / <span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">        current_size, peak_size = tracemalloc.get_traced_memory()</span><br><span class="line">        print(<span class="string">"current size: %.1f KiB"</span> % (current_size / <span class="number">1024</span>))</span><br><span class="line">        print(<span class="string">"peak size: %.1f KiB"</span> % (peak_size / <span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, snapshot, filename)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>上面类主要有以下功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.跟踪对象的内存分配</span><br><span class="line">2.统计每个文件中已分配block信息，包括：行号、占用内存总大小、blocks数量、每个blocks平均占用内存大小</span><br><span class="line">3.比较两个snapshot之间的不同，以便定位内存泄露问题</span><br></pre></td></tr></table></figure>

<p>使用 tracemalloc 库，我们可以跟踪代码中对象的内存分配情况和不同时刻的内存变化情况。</p>
<p>调用例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> MemoryTrace.memory_trace <span class="keyword">import</span> MemoryTrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@MemoryTrace(frame=20, key_type="lineno")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    d = [dict(zip(<span class="string">'xy'</span>, (<span class="number">0</span>, <span class="number">1</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>)]</span><br><span class="line">    t = [tuple(zip(<span class="string">'xy'</span>, (<span class="number">0</span>, <span class="number">1</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    func()</span><br></pre></td></tr></table></figure>

<p>上述例子的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;lineno&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">mem-trace  memory_trace.py:104: size&#x3D;126 KiB, count&#x3D;2002, average&#x3D;64 B</span><br><span class="line">mem-trace  memory_trace.py:103: size&#x3D;19.2 KiB, count&#x3D;161, average&#x3D;122 B</span><br><span class="line">mem-trace  memory_trace.py:47: size&#x3D;448 B, count&#x3D;1, average&#x3D;448 B</span><br><span class="line">mem-trace  memory_trace.py:46: size&#x3D;448 B, count&#x3D;1, average&#x3D;448 B</span><br><span class="line">trace alloc module use memory: 216.2 KiB</span><br><span class="line">current size: 155.2 KiB</span><br><span class="line">peak size: 438862.8 KiB</span><br></pre></td></tr></table></figure>





<h2 id="objgraph的使用"><a href="#objgraph的使用" class="headerlink" title="objgraph的使用"></a>objgraph的使用</h2><p>使用 objgraph 需要先安装：pip install objgraph</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectTrace</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">"limit"</span>, <span class="string">"graph_type"</span>, <span class="string">"growth_file"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, limit=<span class="number">8</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 graph_type=<span class="string">"growth"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 growth_file=None)</span>:</span></span><br><span class="line">        self.limit = limit</span><br><span class="line">        self.graph_type = graph_type</span><br><span class="line">        self.growth_file = growth_file</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            result = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.graph_type == <span class="string">"growth"</span>:</span><br><span class="line">                result = self.object_trace(func, *args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">object_trace</span><span class="params">(self, func, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        display the growth information of objects</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.growth_file:</span><br><span class="line">            <span class="keyword">with</span> open(self.growth_file, <span class="string">"w"</span>) <span class="keyword">as</span> file:</span><br><span class="line">                file.write(<span class="string">"start:"</span> + start + <span class="string">"\n"</span>)</span><br><span class="line">                objgraph.show_growth(self.limit, file=file)</span><br><span class="line">                result = func(*args, **kwargs)</span><br><span class="line">                objgraph.show_growth(self.limit, file=file)</span><br><span class="line"></span><br><span class="line">                end = datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">                file.write(<span class="string">"end:"</span> + end + <span class="string">"\n"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"========object trace========"</span>)</span><br><span class="line">            print(<span class="string">"start:"</span>, start)</span><br><span class="line">            objgraph.show_growth(self.limit)</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            objgraph.show_growth(self.limit)</span><br><span class="line">            end = datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">            print(<span class="string">"end:"</span>, end)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">object_backref</span><span class="params">(obj, max_depth=<span class="number">10</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                       backref_file=<span class="string">"object_backref.dot"</span>)</span>:</span></span><br><span class="line">        print(<span class="string">"========object backref========"</span>)</span><br><span class="line">        trace_objects = objgraph.by_type(obj)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            objgraph.show_backrefs(trace_objects[<span class="number">0</span>],</span><br><span class="line">                                   max_depth,</span><br><span class="line">                                   filename=backref_file)</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>使用 objgraph 库，可以展示python中每类对象的内存增长情况。它会生成一个 .dot 文件，展示代码中对象的引用情况，可以用来检查代码中是否存在循环引用。在 ubuntu 中，可以使用如下方式打开 .dot 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. sudo apt-get install xdot</span><br><span class="line">2. 使用XDot方式打开文件</span><br></pre></td></tr></table></figure>



<p>调用例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> MemoryTrace.object_trace <span class="keyword">import</span> ObjectTrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">seq = list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ObjectTrace()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    o = Test()</span><br><span class="line">    seq.append(o)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    seq.remove(o)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    func()</span><br><span class="line">    ObjectTrace.object_backref(<span class="string">"Test"</span>)</span><br></pre></td></tr></table></figure>

<p>上述例子的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;object trace&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">start: 2020-04-11 22:30:51</span><br><span class="line">function                       2155     +2155</span><br><span class="line">dict                           1173     +1173</span><br><span class="line">wrapper_descriptor             1116     +1116</span><br><span class="line">tuple                           924      +924</span><br><span class="line">weakref                         819      +819</span><br><span class="line">method_descriptor               818      +818</span><br><span class="line">builtin_function_or_method      685      +685</span><br><span class="line">getset_descriptor               439      +439</span><br><span class="line">Test        1        +1</span><br><span class="line">end: 2020-04-11 22:30:51</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;object backref&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Graph written to object_backref.dot (24 nodes)</span><br></pre></td></tr></table></figure>



<p>上面介绍了 python 中 tracemalloc 和 objgraph 库的使用，它们在排查内存泄漏时非常有用，感兴趣的同学可以继续深入了解。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中装饰器与partial结合使用</title>
    <url>/blog/2020/01/01/Python%E4%B8%AD%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8Epartial%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>之前看 Django 框架源码的时候，发现装饰器与 partial() 函数能结合使用，今天介绍它们两个如何一起使用。</p>
<p>首先介绍 partial() 函数，然后再介绍装饰器与 partial() 结合使用的例子。</p>
<a id="more"></a>

<h2 id="partial"><a href="#partial" class="headerlink" title="partial()"></a>partial()</h2><p>当调用一个有多个参数的函数时，我们可能想只传入一部分参数，另一部分参数使用默认值。此时可以直接调用这个函数，也可以使用 partial() 函数实现这一功能。例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式一：正常调用</span></span><br><span class="line">    test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"="</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式二：使用 partial 调用</span></span><br><span class="line">    wrapped_func = partial(test, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">    wrapped_func(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"="</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="comment"># 再次给冻结的函数传参</span></span><br><span class="line">    wrapped_func(<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>上面的例子中，先调用 partial() 函数，传入待执行函数和要冻结的参数。partial() 函数返回一个functools.partial对象，然后再调用它，同时传入剩余的参数即可。同时 partial() 函数还可以重新给冻结的参数传值。</p>
<p>下面介绍下 partial() 在装饰器中的使用。</p>
<h2 id="装饰器与partial"><a href="#装饰器与partial" class="headerlink" title="装饰器与partial"></a>装饰器与partial</h2><p>首先下面是 Django 源码中的一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_middleware</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Populate middleware lists from settings.MIDDLEWARE.</span></span><br><span class="line"><span class="string">    Must be called after the environment is fixed (see __call__ in subclasses).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    handler = convert_exception_to_response(self._get_response)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_exception_to_response</span><span class="params">(get_response)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Wrap the given get_response callable in exception-to-response conversion.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    All exceptions will be converted. All known 4xx exceptions (Http404,</span></span><br><span class="line"><span class="string">    PermissionDenied, MultiPartParserError, SuspiciousOperation) will be</span></span><br><span class="line"><span class="string">    converted to the appropriate response, and all other exceptions will be</span></span><br><span class="line"><span class="string">    converted to 500 responses.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This decorator is automatically applied to all middleware to ensure that</span></span><br><span class="line"><span class="string">    no middleware leaks an exception and that the next middleware in the stack</span></span><br><span class="line"><span class="string">    can rely on getting a response instead of an exception.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @wraps(get_response)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(request)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = get_response(request)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            response = response_for_exception(request, exc)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wraps</span><span class="params">(wrapped,</span></span></span><br><span class="line"><span class="function"><span class="params">          assigned = WRAPPER_ASSIGNMENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">          updated = WRAPPER_UPDATES)</span>:</span></span><br><span class="line">    <span class="string">"""Decorator factory to apply update_wrapper() to a wrapper function</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Returns a decorator that invokes update_wrapper() with the decorated</span></span><br><span class="line"><span class="string">       function as the wrapper argument and the arguments to wraps() as the</span></span><br><span class="line"><span class="string">       remaining arguments. Default arguments are as for update_wrapper().</span></span><br><span class="line"><span class="string">       This is a convenience function to simplify applying partial() to</span></span><br><span class="line"><span class="string">       update_wrapper().</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> partial(update_wrapper, wrapped=wrapped,</span><br><span class="line">                   assigned=assigned, updated=updated)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_wrapper</span><span class="params">(wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">                   wrapped,</span></span></span><br><span class="line"><span class="function"><span class="params">                   assigned = WRAPPER_ASSIGNMENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">                   updated = WRAPPER_UPDATES)</span>:</span></span><br><span class="line">    <span class="string">"""Update a wrapper function to look like the wrapped function</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       wrapper is the function to be updated</span></span><br><span class="line"><span class="string">       wrapped is the original function</span></span><br><span class="line"><span class="string">       assigned is a tuple naming the attributes assigned directly</span></span><br><span class="line"><span class="string">       from the wrapped function to the wrapper function (defaults to</span></span><br><span class="line"><span class="string">       functools.WRAPPER_ASSIGNMENTS)</span></span><br><span class="line"><span class="string">       updated is a tuple naming the attributes of the wrapper that</span></span><br><span class="line"><span class="string">       are updated with the corresponding attribute from the wrapped</span></span><br><span class="line"><span class="string">       function (defaults to functools.WRAPPER_UPDATES)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> assigned:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = getattr(wrapped, attr)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            setattr(wrapper, attr, value)</span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> updated:</span><br><span class="line">        getattr(wrapper, attr).update(getattr(wrapped, attr, &#123;&#125;))</span><br><span class="line">    <span class="comment"># Issue #17482: set __wrapped__ last so we don't inadvertently copy it</span></span><br><span class="line">    <span class="comment"># from the wrapped function when updating __dict__</span></span><br><span class="line">    wrapper.__wrapped__ = wrapped</span><br><span class="line">    <span class="comment"># Return the wrapper so this can be used as a decorator via partial()</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>上面发生在 Django 通过 request 返回 response 时候的一段代码调用。主要的功能是给 self._get_response() 函数增加了一些属性。</p>
<p>执行流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 调用 convert_exception_to_response() 时会先执行 wraps(get_response)</span><br><span class="line">2. 执行 wraps(get_response) 时，会返回 partial(update_wrapper, wrapped&#x3D;wrapped,               	</span><br><span class="line">	assigned&#x3D;assigned, updated&#x3D;updated)，即函数 update_wrapper() 对应的一个 functools.partial 对</span><br><span class="line">	象，此时 wrapped 就是 get_response()</span><br><span class="line">3. @wraps装饰器返回一个 functools.partial 对象后，wrapper 参数就是 inner</span><br><span class="line">4. 最后将 inner 赋值给了 handler</span><br></pre></td></tr></table></figure>

<p>上面的整个功能就是将被包装函数(self._get_response())的属性赋值给包装它的函数(inner())，即在执行包装函数 inner() 之前，会做一些额外的操作。</p>
<p>下面看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_wrapper</span><span class="params">(wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">                   wrapped)</span>:</span></span><br><span class="line">    print(<span class="string">"wrapper:"</span>, wrapper)</span><br><span class="line">    print(<span class="string">"wrapped:"</span>, wrapped)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其它操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wraps</span><span class="params">(wrapped)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> partial(update_wrapper, wrapped=wrapped)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">"get response num:"</span>, num)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(get_response)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(get_response)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(num)</span>:</span></span><br><span class="line">        response = get_response(num)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ret = outer(get_response)</span><br><span class="line">    ret(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">打印结果：</span></span><br><span class="line"><span class="string">wrapper: &lt;function outer.&lt;locals&gt;.inner at 0x0000020231A819D8&gt;</span></span><br><span class="line"><span class="string">wrapped: &lt;function get_response at 0x0000020231A818C8&gt;</span></span><br><span class="line"><span class="string">get response num: 5</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>从打印结果可以看出，wrapped 就是 get_response() 函数对象，wrapper 是 inner() 函数对象。</p>
<p>上面比较关键的一个函数是 update_wrapper()，因为在它里面会对最终的执行结果产生影响。</p>
<p>在实际项目开发中，如果有需要，可以通过装饰器 + partial()函数的方式实现一些需求。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python标准库之contextlib</title>
    <url>/blog/2019/12/01/Python%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8Bcontextlib/</url>
    <content><![CDATA[<p>contextlib 库提供了一些接口，使我们能更容易实现 with 语法。下面主要介绍下 contextmanager 和 suppress 的用法。</p>
<a id="more"></a>

<h2 id="with语法的实现"><a href="#with语法的实现" class="headerlink" title="with语法的实现"></a>with语法的实现</h2><p>平时我们实现读取文件的操作时，会使用 with 语法，像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"data.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure>

<p>这样读取完文件后，会自动执行 f.close() 操作，关闭文件对象。</p>
<p>实际上，我们也可以用过实现魔法函数 __enter__() 和 __exit__() 来自定义 with 语法，像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOpen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file, flag)</span>:</span></span><br><span class="line">        self.f = open(file, flag)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""with ... as中as后面的内容</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.f</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="string">"""with语句块执行完成后执行</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.f.close()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">with</span> MyOpen(<span class="string">"test.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">"hello jupyter!"</span>)</span><br></pre></td></tr></table></figure>

<p>其中， __enter__() 函数的返回值是 with … as 后面的对象，__exit__()函数中定义with语句块执行完成后的操作。</p>
<h2 id="contextmanager"><a href="#contextmanager" class="headerlink" title="contextmanager"></a>contextmanager</h2><p>contextmanager 函数是一个装饰器，可以使用它来实现 with 语法，而不用实现 __enter__() 和 __exit__() 。上文中实现 with 语法的例子可以写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MyOpen</span><span class="params">(name, state)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = open(name, state)</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">with</span> MyOpen(<span class="string">"test.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">"hello jupyter notebook!"</span>)</span><br></pre></td></tr></table></figure>

<p>使用 contextmanager 实现 with 语法时，被修饰的方法必须是一个生成器，生成器返回的值就作为 as 后面的值。</p>
<p>下面再看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"> </span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">    print(<span class="string">'start'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># raise Exception('test')</span></span><br><span class="line">        <span class="keyword">yield</span> l</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> example() <span class="keyword">as</span> msg:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> msg:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>

<p>如果在 contextmanager 修饰的函数中发生异常时，我们可以在函数中捕获该异常，像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    print(<span class="string">'start'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> l</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'test'</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"exception"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>

<p>也可以在 with 语句块之外捕获该异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    print(<span class="string">'start'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> l</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'test'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> example() <span class="keyword">as</span> msg:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> msg:</span><br><span class="line">            print(i)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<p>如果异常发生在 yeild 之前，则 yield 不会返回到 with 语句中，with语句块会抛出RuntimeError异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    print(<span class="string">'start'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'test'</span>)</span><br><span class="line">        <span class="keyword">yield</span> l</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"exception"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> example() <span class="keyword">as</span> msg:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> msg:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>

<p>上面的代码会抛出如下异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raceback (most recent call last):</span><br><span class="line">  File <span class="string">"tmp.py"</span>, line <span class="number">17</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">with</span> example() <span class="keyword">as</span> msg:</span><br><span class="line">  File <span class="string">"D:\software\Python36\lib\contextlib.py"</span>, line <span class="number">83</span>, <span class="keyword">in</span> __enter__</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">"generator didn't yield"</span>) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">RuntimeError: generator didn<span class="string">'t yield</span></span><br></pre></td></tr></table></figure>



<p>contextmanager 的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contextmanager</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""@contextmanager decorator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Typical usage:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        @contextmanager</span></span><br><span class="line"><span class="string">        def some_generator(&lt;arguments&gt;):</span></span><br><span class="line"><span class="string">            &lt;setup&gt;</span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                yield &lt;value&gt;</span></span><br><span class="line"><span class="string">            finally:</span></span><br><span class="line"><span class="string">                &lt;cleanup&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This makes this:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        with some_generator(&lt;arguments&gt;) as &lt;variable&gt;:</span></span><br><span class="line"><span class="string">            &lt;body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    equivalent to this:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;setup&gt;</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            &lt;variable&gt; = &lt;value&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;</span></span><br><span class="line"><span class="string">        finally:</span></span><br><span class="line"><span class="string">            &lt;cleanup&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> _GeneratorContextManager(func, args, kwds)</span><br><span class="line">    <span class="keyword">return</span> helper</span><br></pre></td></tr></table></figure>

<p>contextmanager 会返回一个<em>GeneratorContextManager 对象。 _GeneratorContextManager 类中实现了 __enter_\</em>() 和 __exit__() 方法，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, kwds)</span>:</span></span><br><span class="line">    self.gen = func(*args, **kwds)</span><br><span class="line">    self.func, self.args, self.kwds = func, args, kwds</span><br><span class="line">    <span class="comment"># Issue 19330: ensure context manager instances have good docstrings</span></span><br><span class="line">    doc = getattr(func, <span class="string">"__doc__"</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> doc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        doc = type(self).__doc__</span><br><span class="line">    self.__doc__ = doc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> next(self.gen)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"generator didn't yield"</span>) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> type <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next(self.gen)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"generator didn't stop"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Need to force instantiation so we can reliably</span></span><br><span class="line">            <span class="comment"># tell if we get the same exception back</span></span><br><span class="line">            value = type()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.gen.throw(type, value, traceback)</span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="comment"># Suppress StopIteration *unless* it's the same exception that</span></span><br><span class="line">            <span class="comment"># was passed to throw().  This prevents a StopIteration</span></span><br><span class="line">            <span class="comment"># raised inside the "with" statement from being suppressed.</span></span><br><span class="line">            <span class="keyword">return</span> exc <span class="keyword">is</span> <span class="keyword">not</span> value</span><br><span class="line">        <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="comment"># Don't re-raise the passed in exception. (issue27122)</span></span><br><span class="line">            <span class="keyword">if</span> exc <span class="keyword">is</span> value:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># Likewise, avoid suppressing if a StopIteration exception</span></span><br><span class="line">            <span class="comment"># was passed to throw() and later wrapped into a RuntimeError</span></span><br><span class="line">            <span class="comment"># (see PEP 479).</span></span><br><span class="line">            <span class="keyword">if</span> type <span class="keyword">is</span> StopIteration <span class="keyword">and</span> exc.__cause__ <span class="keyword">is</span> value:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment"># only re-raise if it's *not* the exception that was</span></span><br><span class="line">            <span class="comment"># passed to throw(), because __exit__() must not raise</span></span><br><span class="line">            <span class="comment"># an exception unless __exit__() itself failed.  But throw()</span></span><br><span class="line">            <span class="comment"># has to raise the exception to signal propagation, so this</span></span><br><span class="line">            <span class="comment"># fixes the impedance mismatch between the throw() protocol</span></span><br><span class="line">            <span class="comment"># and the __exit__() protocol.</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="keyword">if</span> sys.exc_info()[<span class="number">1</span>] <span class="keyword">is</span> value:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"generator didn't stop after throw()"</span>)</span><br></pre></td></tr></table></figure>

<p><em>GeneratorContextManager初始化时，会接收一个生成器函数，__enter_\</em>()方法中会返回该生成器函数的值。</p>
<h2 id="suppress的使用"><a href="#suppress的使用" class="headerlink" title="suppress的使用"></a>suppress的使用</h2><p>suppress会返回一个上下文管理器对象，如果with语句块中出现异常时，会忽略 suppress 中指定的异常，并且退出程序。例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 上面的异常捕获可以写成下面这样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> suppress</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonFatalError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_idempotent_operation</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NonFatalError(</span><br><span class="line">        <span class="string">'The operation failed because of existing state'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> contextlib.suppress(NonFatalError):</span><br><span class="line">    print(<span class="string">'trying non-idempotent operation'</span>)</span><br><span class="line">    non_idempotent_operation()</span><br><span class="line">    print(<span class="string">'succeeded!'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'done'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">trying non-idempotent operation</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>supress中需要传入异常名称，不能为空。</p>
<p>以上就是 contextlib中 contextmanager 和 suppress 的用法。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python标准库之argparse</title>
    <url>/blog/2019/12/29/Python%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8Bargparse/</url>
    <content><![CDATA[<p>python中用来解析命令行的工具有两个：sys.argv 和 argparse。对于简单的命令行传参，使用 sys.argv 就可以解析了，如果需要解析复杂的命令行参数，那么就可以使用 argparse。下面介绍下 argparse 的用法。</p>
<a id="more"></a>

<p>第一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化参数解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">"a argument parser"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">'--host'</span>,</span><br><span class="line">                    action=<span class="string">"store"</span>,</span><br><span class="line">                    default=<span class="string">'127.0.0.1'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--port'</span>,</span><br><span class="line">                    action=<span class="string">"store"</span>, type=int,</span><br><span class="line">                    default=<span class="number">8000</span>)</span><br><span class="line"></span><br><span class="line">print(parser.parse_args())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">在命令行执行：</span></span><br><span class="line"><span class="string">python 01_test.py --host 192.168.0.102 --port 8001</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">Namespace(host='192.168.0.102', port=8001)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>上述步骤中，首先使用 parser = argparse.ArgumentParser() 实例化参数解析器，然后使用 parser.add_argument() 添加需要解析的参数信息，最后使用 parser.parse_args() 获取命令行的参数信息。</p>
<h3 id="add-argument"><a href="#add-argument" class="headerlink" title="add_argument()"></a>add_argument()</h3><p>parser.add_argument() 函数用来添加需要解析的参数信息，它的入参有下面一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数1：命令行中参数的名称</span><br><span class="line">action：传参时需要执行的功能，有以下几个：</span><br><span class="line">	store：保存值，并转换为指定类型。默认行为</span><br><span class="line">	store_const：定义参数时就设置默认值，但是参数不能是 Boolean 类型</span><br><span class="line">	store_true&#x2F;store_false：与 store_const 类似，保存 Boolean 类型的值</span><br><span class="line">	append：向list中添加数据</span><br><span class="line">	append_const：向list中添加常量值</span><br><span class="line">type：指定参数值的类型，默认类型str。当传入的参数不能被转换为指定类型时，会抛出异常。</span><br><span class="line">default：参数的默认值</span><br><span class="line">dest：访问参数时，参数的别名</span><br></pre></td></tr></table></figure>

<p>在 add_argument()  中，还可以为命令行参数指定简短的参数名，像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--host'</span>,</span><br><span class="line">                    <span class="string">'-ho'</span>,</span><br><span class="line">                    dest=<span class="string">'h'</span>,</span><br><span class="line">                    action=<span class="string">"store"</span>,</span><br><span class="line">                    default=<span class="string">'127.0.0.1'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--port'</span>,</span><br><span class="line">                    <span class="string">'-po'</span>,</span><br><span class="line">                    dest=<span class="string">'p'</span>,</span><br><span class="line">                    action=<span class="string">"store"</span>, type=int,</span><br><span class="line">                    default=<span class="number">8000</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">命令行上传输参数时，有下面两种方式：</span></span><br><span class="line"><span class="string">1）python 01_test.py --host 192.168.0.102 --port 8002</span></span><br><span class="line"><span class="string">2）python 01_test.py -ho 192.168.0.102 -po 8002</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<h3 id="parse-args"><a href="#parse-args" class="headerlink" title="parse_args()"></a>parse_args()</h3><p>函数 parser.parse_args() 用来获取命令行的参数信息，它的返回值的是一个 <code>Namespace</code>  对象，该对象的属性名就是传入的参数名，属性值是对应传入参数的值。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser_args = parser.parse_args()</span><br><span class="line">print(parser_args)  <span class="comment"># Namespace(host='192.168.0.102', port=8001)</span></span><br><span class="line">print(parser_args.host)  <span class="comment"># 192.168.0.102</span></span><br></pre></td></tr></table></figure>

<p>当在 add_argument() 函数中指定dest参数时，可以用过 dest 指定的参数访问属性值，像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化参数解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">"a argument parser"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">'--host'</span>,</span><br><span class="line">                    dest=<span class="string">'h'</span>,</span><br><span class="line">                    action=<span class="string">"store"</span>,</span><br><span class="line">                    default=<span class="string">'127.0.0.1'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--port'</span>,</span><br><span class="line">                    dest=<span class="string">'p'</span>,</span><br><span class="line">                    action=<span class="string">"store"</span>, type=int,</span><br><span class="line">                    default=<span class="number">8000</span>)</span><br><span class="line"></span><br><span class="line">parser_args = parser.parse_args()</span><br><span class="line">print(parser_args)  <span class="comment"># Namespace(h='192.168.0.102', p=8001)</span></span><br><span class="line">print(parser_args.h)  <span class="comment"># 192.168.0.102</span></span><br><span class="line">print((parser_args.p))  <span class="comment"># 8001</span></span><br></pre></td></tr></table></figure>





<h3 id="action参数"><a href="#action参数" class="headerlink" title="action参数"></a>action参数</h3><p>上面例子中，action 参数的值都是 “store”，下面介绍下其它参数值的使用。</p>
<h4 id="action-const"><a href="#action-const" class="headerlink" title="action_const"></a>action_const</h4><p>action_const表示传入指定参数名时，参数值是常量，不会改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">"-t"</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    dest=<span class="string">'const'</span>,</span><br><span class="line">                    const=<span class="string">"const value"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arg_parser = parser.parse_args()</span><br><span class="line">print(arg_parser.const)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行：python test.py -t</span></span><br><span class="line"><span class="string">则 arg_parser.const 的值为 "const value"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此时如果执行 python test.py -t "const value" </span></span><br><span class="line"><span class="string">试图向常量中传入参数，则会抛出异常</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="action-true"><a href="#action-true" class="headerlink" title="action_true"></a>action_true</h4><p>action_true或者action_false，这两个值与action_const类似，只是常量是 Boolean 类型。</p>
<p>例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># @Author : WZ </span></span><br><span class="line"><span class="comment"># @Time : 2019/12/29 10:37</span></span><br><span class="line"><span class="comment"># @Intro :</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""action='store_const'的使用</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">"-t"</span>, action=<span class="string">'store_true'</span>,</span><br><span class="line">                    default=<span class="literal">False</span>,</span><br><span class="line">                    dest=<span class="string">'bool1'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">"-b"</span>, action=<span class="string">'store_false'</span>,</span><br><span class="line">                    default=<span class="literal">True</span>,</span><br><span class="line">                    dest=<span class="string">'bool2'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arg_parser = parser.parse_args()</span><br><span class="line">print(arg_parser.bool1)</span><br><span class="line">print(arg_parser.bool2)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行 python test.py -t 时，arg_parser.bool1 的值是 True</span></span><br><span class="line"><span class="string">执行 python test.py 时，arg_parser.bool1 的值是False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">执行 python test.py -b 时，arg_parser.bool2 的值是 False</span></span><br><span class="line"><span class="string">执行 python test.py 时，arg_parser.bool2 的值是 True</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p>append功能是向list中追加数据，使用例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">"-a"</span>, action=<span class="string">'append'</span>,</span><br><span class="line">                    default=[],</span><br><span class="line">                    dest=<span class="string">'add'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arg_parser = parser.parse_args()</span><br><span class="line">print(arg_parser.add)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行 python test.py，输出为 []</span></span><br><span class="line"><span class="string">执行 python test.py -a one -a two -a second，输出为 ['one', 'two', 'second']</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="append-const"><a href="#append-const" class="headerlink" title="append_const"></a>append_const</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">"-a"</span>, action=<span class="string">'append_const'</span>,</span><br><span class="line">                    const=<span class="string">"const1"</span>,</span><br><span class="line">                    default=[],</span><br><span class="line">                    dest=<span class="string">'add'</span>)</span><br><span class="line">parser.add_argument(<span class="string">"-b"</span>, action=<span class="string">'append_const'</span>,</span><br><span class="line">                    const=<span class="string">"const2"</span>,</span><br><span class="line">                    default=[],</span><br><span class="line">                    dest=<span class="string">'add'</span>)</span><br><span class="line"></span><br><span class="line">arg_parser = parser.parse_args()</span><br><span class="line">print(arg_parser.add)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行 python test.py，输出为 []</span></span><br><span class="line"><span class="string">执行 python test.py -a，输出为 ['const1']</span></span><br><span class="line"><span class="string">执行 python test.py -b，输出为 ['const2']</span></span><br><span class="line"><span class="string">执行 python test.py -a -b，输出为 ['const1', 'const2']</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<h3 id="修改前缀"><a href="#修改前缀" class="headerlink" title="修改前缀"></a>修改前缀</h3><p>命令行参数默认前缀是 “-“，也可以使用 prefix_chars 指定其他前缀。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化参数解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    description=<span class="string">"a argument parser"</span>,</span><br><span class="line">    prefix_chars=<span class="string">'-+/'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">'+host'</span>,</span><br><span class="line">                    dest=<span class="string">'h'</span>,</span><br><span class="line">                    action=<span class="string">"store"</span>,</span><br><span class="line">                    default=<span class="string">'127.0.0.1'</span>)</span><br><span class="line"></span><br><span class="line">parser_args = parser.parse_args()</span><br><span class="line">print(parser_args.h)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用 prefix_chars 参数可以同时指定多个前缀</span></span><br><span class="line"><span class="string">传参时，可以执行 python test.py +host 192.168.0.102</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>此外，默认可以使用 -h 参数显式脚本支持的命令行参数信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化参数解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    description=<span class="string">"a argument parser"</span>,</span><br><span class="line">    prefix_chars=<span class="string">'-+/'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">'-host'</span>,</span><br><span class="line">                    dest=<span class="string">'h'</span>,</span><br><span class="line">                    action=<span class="string">"store"</span>,</span><br><span class="line">                    default=<span class="string">'127.0.0.1'</span>,</span><br><span class="line">                    help=<span class="string">"server host"</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-port'</span>,</span><br><span class="line">                    dest=<span class="string">'p'</span>,</span><br><span class="line">                    action=<span class="string">"store"</span>,</span><br><span class="line">                    default=<span class="number">8001</span>,</span><br><span class="line">                    help=<span class="string">"server port"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行 python test.py -h</span></span><br><span class="line"><span class="string">会在终端输出以下信息：</span></span><br><span class="line"><span class="string">usage: 01_test.py [-h] [-host H] [-port P]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a argument parser</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">optional arguments:</span></span><br><span class="line"><span class="string">  -h, --help  show this help message and exit</span></span><br><span class="line"><span class="string">  -host H     server host</span></span><br><span class="line"><span class="string">  -port P     server port</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>以上就是 argparse 的简单用法。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>RSSHub的使用</title>
    <url>/blog/2020/04/08/RSSHub%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>RSS简易信息聚合（也叫<a href="https://www.baidu.com/s?wd=聚合内容&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">聚合内容</a>）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议。</p>
<a id="more"></a>

<h1 id="RSS简介"><a href="#RSS简介" class="headerlink" title="RSS简介"></a>RSS简介</h1><p>​        RSS简易信息聚合（也叫<a href="https://www.baidu.com/s?wd=聚合内容&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">聚合内容</a>）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议。RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的<a href="https://www.baidu.com/s?wd=XML应用&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">XML应用</a>。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。发布一个RSS文件后，这个RSS Feed中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的<a href="https://www.baidu.com/s?wd=XML格式&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">XML格式</a>，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。[1] RSS可以是以下三个解释的其中一个： Really Simple Syndication；RDF (Resource Description Framework) Site Summary； Rich Site Summary。但其实这三个解释都是指同一种Syndication的技术。<br>​        RSS目前广泛用于网上<a href="https://www.baidu.com/s?wd=新闻频道&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">新闻频道</a>，blog和wiki，主要的版本有0.91, 1.0, 2.0。使用<a href="https://www.baidu.com/s?wd=RSS订阅&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">RSS订阅</a>能更快地获取信息，网站提供RSS输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持RSS的聚合工具软件，在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。</p>
<p>​        其实，RSS的功能类似于爬虫，只是这个“爬虫”已经实现好了，我们只需要遵循它的规则去调用就可以获取所需的数据。</p>
<h1 id="RSSHub服务搭建"><a href="#RSSHub服务搭建" class="headerlink" title="RSSHub服务搭建"></a>RSSHub服务搭建</h1><h2 id="RSSHub介绍"><a href="#RSSHub介绍" class="headerlink" title="RSSHub介绍"></a>RSSHub介绍</h2><p>​        RSSHub 是一款轻量、易于扩展的 RSS 生成器，基于 node.js 10，可以给「任何」内容生成 RSS 订阅源，目前支持微信公众号、B 站、微博、即刻、网易云音乐、掘金、简书、知乎、自如、快递、贴吧、豆瓣、pixiv 等内容。</p>
<p>​        RSSHub 不是阅读器，它是一个用来生成 RSS 源的工具，并且你需要一台能够运行 node.js 的电脑来长期运行 RSSHub，当然推荐使用 VPS，除了能够实现稳定的源以外，还能抓取 Instagram 等内容源。</p>
<p>​        与 Huginn、Feed43 等工具类似，RSSHub 在大部分网站上也是通过抓取网页的方式获得订阅源，不同的是在 RSSHub 中，已经完成了对抓取规则的编写，只需要用户简单的编辑下地址即可。</p>
<h2 id="搭建RSS准备工作"><a href="#搭建RSS准备工作" class="headerlink" title="搭建RSS准备工作"></a>搭建RSS准备工作</h2><h3 id="安装nodejs和npm"><a href="#安装nodejs和npm" class="headerlink" title="安装nodejs和npm"></a>安装nodejs和npm</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装nodejs和npm就略过了</span><br></pre></td></tr></table></figure>



<h3 id="npm镜像源"><a href="#npm镜像源" class="headerlink" title="npm镜像源"></a>npm镜像源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看镜像源：</span><br><span class="line">npm config get registry（默认结果是：http:&#x2F;&#x2F;registry.npmjs.org）</span><br><span class="line"></span><br><span class="line">更改默认镜像源：</span><br><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm config set registry http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;</span><br><span class="line"></span><br><span class="line">执行npm install时指定镜像源：</span><br><span class="line">npm install --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">国内其他镜像源：</span><br><span class="line">淘宝npm镜像</span><br><span class="line">搜索地址：http:&#x2F;&#x2F;npm.taobao.org&#x2F;</span><br><span class="line">registry地址：http:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class="line">cnpmjs镜像</span><br><span class="line">搜索地址：http:&#x2F;&#x2F;cnpmjs.org&#x2F;</span><br><span class="line">registry地址：http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;</span><br></pre></td></tr></table></figure>



<h3 id="node升级"><a href="#node升级" class="headerlink" title="node升级"></a>node升级</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br></pre></td></tr></table></figure>



<h2 id="搭建RSS服务步骤"><a href="#搭建RSS服务步骤" class="headerlink" title="搭建RSS服务步骤"></a>搭建RSS服务步骤</h2><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. git clone https:&#x2F;&#x2F;github.com&#x2F;DIYgod&#x2F;RSSHub.git</span><br><span class="line">2. cd RSSHub 并执行 npm install（执行速度慢时可以考虑更换npm源）</span><br><span class="line">3. 启动rss服务：npm start</span><br><span class="line">4. 在浏览器中输入 http:&#x2F;&#x2F;ip:port 即可查看</span><br></pre></td></tr></table></figure>



<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.moerats.com&#x2F;archives&#x2F;587&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;e17258dd5b69</span><br><span class="line">https:&#x2F;&#x2F;sspai.com&#x2F;post&#x2F;47100</span><br></pre></td></tr></table></figure>



<h1 id="RSSHub的使用"><a href="#RSSHub的使用" class="headerlink" title="RSSHub的使用"></a>RSSHub的使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文档：https:&#x2F;&#x2F;docs.rsshub.app&#x2F;</span><br></pre></td></tr></table></figure>



<h2 id="微博"><a href="#微博" class="headerlink" title="微博"></a>微博</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据用户id获取用户动态：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;weibo&#x2F;user&#x2F;:uid</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;weibo&#x2F;user&#x2F;2803301701</span><br><span class="line"></span><br><span class="line">根据关键词获取用户动态：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;weibo&#x2F;keyword&#x2F;:keyword</span><br><span class="line"></span><br><span class="line">获取热搜榜：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;weibo&#x2F;search&#x2F;hot</span><br></pre></td></tr></table></figure>



<h2 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取首页数据：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;jianshu&#x2F;home</span><br><span class="line"></span><br><span class="line">根据用户id获取用户文章：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;jianshu&#x2F;user&#x2F;:uid</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;jianshu&#x2F;user&#x2F;c5a2ce84f60b</span><br><span class="line"></span><br><span class="line">根据专题id获取文章：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;jianshu&#x2F;collection&#x2F;:cid</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;jianshu&#x2F;collection&#x2F;7b2be866f564</span><br></pre></td></tr></table></figure>



<h2 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据用户id获取知乎动态：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;people&#x2F;activities&#x2F;:uid</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;people&#x2F;activities&#x2F;yuansu-27-1</span><br><span class="line"></span><br><span class="line">根据用户id获取用户回答的问题：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;people&#x2F;answers&#x2F;:uid</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;people&#x2F;answers&#x2F;yuansu-27-1</span><br><span class="line"></span><br><span class="line">根据用户id获取用户的文章：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;people&#x2F;posts&#x2F;:uid</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;people&#x2F;posts&#x2F;yuansu-27-1</span><br><span class="line"></span><br><span class="line">获取知乎热榜：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;hotlist</span><br><span class="line"></span><br><span class="line">知乎想法热榜：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;pin&#x2F;hotlist</span><br><span class="line"></span><br><span class="line">根据问题id查找答案：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;question&#x2F;:qid</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;question&#x2F;352335277</span><br><span class="line"></span><br><span class="line">根据专题id获取专题信息：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;topic&#x2F;:tid</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;zhihu&#x2F;topic&#x2F;21276827</span><br></pre></td></tr></table></figure>



<h2 id="今日头条"><a href="#今日头条" class="headerlink" title="今日头条"></a>今日头条</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据关键字查询信息：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;jinritoutiao&#x2F;keyword&#x2F;:keyword</span><br></pre></td></tr></table></figure>



<h2 id="腾讯NBA"><a href="#腾讯NBA" class="headerlink" title="腾讯NBA"></a>腾讯NBA</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;nba&#x2F;app_news</span><br></pre></td></tr></table></figure>



<h2 id="雪球"><a href="#雪球" class="headerlink" title="雪球"></a>雪球</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据用户id和类型获取用户动态：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;xueqiu&#x2F;user&#x2F;:uid&#x2F;:type</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;xueqiu&#x2F;user&#x2F;8152922548&#x2F;2</span><br><span class="line">0-原发布</span><br><span class="line">2-长文</span><br><span class="line">4-问答</span><br><span class="line">9-热门</span><br><span class="line">11-交易</span><br><span class="line"></span><br><span class="line">获取用户的收藏：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;xueqiu&#x2F;favorite&#x2F;:uid</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;xueqiu&#x2F;favorite&#x2F;8152922548</span><br><span class="line"></span><br><span class="line">查询股票信息：</span><br><span class="line">http:&#x2F;&#x2F;localhost:1200&#x2F;xueqiu&#x2F;stock_info&#x2F;:id&#x2F;:type</span><br><span class="line">id：股票代码</span><br><span class="line">type：动态类型</span><br><span class="line">	announcement-公告</span><br><span class="line">	news-新闻</span><br><span class="line">	research-研报</span><br><span class="line">例子：http:&#x2F;&#x2F;localhost:1200&#x2F;xueqiu&#x2F;stock_info&#x2F;SZ399001</span><br></pre></td></tr></table></figure>



<p>rsshub支持的其他网站可以查看下面的文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.rsshub.app&#x2F;</span><br></pre></td></tr></table></figure>



<h1 id="其他可用RSS推荐"><a href="#其他可用RSS推荐" class="headerlink" title="其他可用RSS推荐"></a>其他可用RSS推荐</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;buwuliao&#x2F;p&#x2F;8379549.html（https:&#x2F;&#x2F;rssfeed.today&#x2F;weibo&#x2F;rss&#x2F;:userid）</span><br><span class="line">https:&#x2F;&#x2F;rssfeed.today&#x2F;weibo&#x2F;rss&#x2F;:userid</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>Redis主从复制的搭建</title>
    <url>/blog/2020/07/04/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Redis 的主从复制是一个很有用的功能，在大型系统中，为了分担 Redis 的读写压力，可以使用主从复制功能。下面介绍下 Redis 主从复制的搭建。</p>
<a id="more"></a>

<h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><h2 id="Redis-持久化方式"><a href="#Redis-持久化方式" class="headerlink" title="Redis 持久化方式"></a>Redis 持久化方式</h2><p>先介绍下 Redis 的持久化方式。Redis 的持久化方式有两种 rdb和 aof，默认是 rdb 的方式。</p>
<h3 id="rdb-备份方式"><a href="#rdb-备份方式" class="headerlink" title="rdb 备份方式"></a>rdb 备份方式</h3><p>rdb 是半持久化的存储方式，它会定期将内存中数据保存到磁盘上，从而保证数据的持久化，永久保存Redis数据。它是通过快照（snapshotting）的方式完成的，当满足在 Redis.conf 配置文件中设置的条件时 Redis 会自动将内存中的所有数据进行快照并存储在硬盘上，完成数据备份。</p>
<p>Redis进行 rdb 快照的条件由用户在配置文件中自定义，由两个参数构成：时间和改动键的个数。当在指定时间内被更改键的个数大于指定的数值时就会进行快照。配置文件中默认预值了3个条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1       #900秒内有至少1个键被更改则进行快照；</span><br><span class="line">save 300 10      #300秒内有至少10个键被更改则进行快照；</span><br><span class="line">save 60  10000   #60秒内有至少10000个键被更改则进行快照</span><br></pre></td></tr></table></figure>

<p>默认可以存在多个条件，条件之间是“或”的关系，只要满足其中任意一个，就会进行快照备份数据。若想要禁用自动快照，只需删除所有save参数即可。</p>
<p>Redis 默认会将快照文件存储在 Redis 数据目录中，默认文件名是：dump.rdb，可通过配置dir和dbfilename两个参数来指定快照文件的存储路径和文件名。</p>
<p>Redis快照过程：Redis使用fork函数复制一份当前进程（父进程）的副本（子进程），父进程负责接收和处理客户端发来的命令，而子进程负责将内存中的数据写入硬盘中的临时文件，当子进程写完所有数据后会用该临时文件替换旧的 rdb 文件，至此一次快照操作完成。<br>rdb 文件是经过压缩的二进制格式，所以占用的空间会小于内存中的数据大小。除了自动快照，还可以手动发送SAVE和BGSAVE 命令让Redis执行快照。两个命令区别是：SAVE是由主进程进行快照操作，会阻塞其他请求，BGSAVE会通过fork 子进程进行快照操作。</p>
<p>手动执行备份：redis-cli bgsave</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save  &#x2F;&#x2F; 手动备份</span><br><span class="line">bgsave  &#x2F;&#x2F; 手动备份</span><br><span class="line">config get dir  &#x2F;&#x2F; 获取redis的dir</span><br></pre></td></tr></table></figure>

<h3 id="aof-备份方式"><a href="#aof-备份方式" class="headerlink" title="aof 备份方式"></a>aof 备份方式</h3><p>aof 是全持久化的备份方式，使用这种方式，Redis 会实时将内存中数据刷到磁盘上，从而保证数据的持久化，永久保存Redi s数据。如果数据非常重要无法承受任何损失，可以使用 aof 方式进行持久化，默认 Redis 没有开启 aof（append only file）方式的全持久化模式。</p>
<p>在启动时 Redis 会逐个执行 apf 文件中的命令来将硬盘中的数据载入到内存中，载入的速度相对于 rdb 方式慢些，开启 aof 持久化后每执行一条都会更改Redis中的数据的命令，Redis就会将命令写入硬盘中的 aof 文件。</p>
<p>Redis允许同时开启 aof 和 rdb ，既保证了数据安全又使得进行备份等操作十分容易。</p>
<p>Redis aof持久化参数配置详解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly  yes                   #开启AOF持久化功能；</span><br><span class="line">appendfilenameappendonly.aof      #AOF持久化保存文件名；</span><br><span class="line">appendfsyncalways                 #每次执行写入都会执行同步，最安全也最慢；</span><br><span class="line">#appendfsynceverysec              #每秒执行一次同步操作；</span><br><span class="line">#appendfsyncno                    #不主动进行同步操作，而是完全交由操作系统来做，每30秒一次，最快也最不安全；</span><br><span class="line">auto-aof-rewrite-percentage  100  #当AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据；</span><br><span class="line">auto-aof-rewrite-min-size    64mb #允许重写的最小AOF文件大小配置写入AOF文件后，要求系统刷新硬盘缓存的机制。</span><br></pre></td></tr></table></figure>

<p>在配置文件中进行以下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<p>aof 刷新日志到disk的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync always   #always 表示每次有写操作都进行同步，非常慢，非常安全。</span><br><span class="line">appendfsync everysec #everysec表示对写操作进行累积，每秒同步一次</span><br></pre></td></tr></table></figure>

<p>官方的建议的everysec，安全，就是速度不够快，如果是机器出现问题可能会丢失1秒的数据。</p>
<p>手动执行备份：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli bgrewriteaof</span><br></pre></td></tr></table></figure>



<h2 id="主从数据同步"><a href="#主从数据同步" class="headerlink" title="主从数据同步"></a>主从数据同步</h2><p>当 slave 初始化的时候，会将 master 上的数据复制一份到自己服务器上。此后，每当 master 新增数据后，都会将写命令发送一份到 slave 上，slave 接收到写命令后将数据写入。我们可以通过 monitor 命令来看 slave 的写入过程。</p>
<p>例如：当 master 执行 set name wyzane 后，使用 monitor 查看到 slave 的执行如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1593857563.031330 [0 192.168.0.105:6379] &quot;PING&quot;</span><br><span class="line">1593857553.918113 [0 192.168.0.105:6379] &quot;set&quot; &quot;name&quot; &quot;wyzane&quot;</span><br><span class="line">1593857563.031330 [0 192.168.0.105:6379] &quot;PING&quot;</span><br></pre></td></tr></table></figure>



<h1 id="主从复制搭建"><a href="#主从复制搭建" class="headerlink" title="主从复制搭建"></a>主从复制搭建</h1><p>下面在一个服务器上开启三个 Redis 进程为例，来介绍下主从复制的搭建过程。</p>
<h2 id="不需要权限校验的主从复制"><a href="#不需要权限校验的主从复制" class="headerlink" title="不需要权限校验的主从复制"></a>不需要权限校验的主从复制</h2><p>配置的时候，需要修改 Redis .conf 配置文件，master 和 slave 的配置分别如下。其中，protected-mode no 表示 slave 连接 master 时不需要密码校验。</p>
<p>master配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 192.168.0.105</span><br><span class="line">protected-mode no</span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure>

<p>slqve1 的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 192.168.0.105</span><br><span class="line">slaveof 192.168.0.105 6379</span><br><span class="line">protected-mode no</span><br><span class="line">port 6380</span><br></pre></td></tr></table></figure>

<p>slave2 的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 192.168.0.105</span><br><span class="line">slaveof 192.168.0.105 6379</span><br><span class="line">protected-mode no</span><br><span class="line">port 6381</span><br></pre></td></tr></table></figure>

<p>配置完成后，执行以下命令启动这三个服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server redis.conf （master）</span><br><span class="line">redis-server redis2.conf （slave1）</span><br><span class="line">redis-server redis3.conf （slave2）</span><br></pre></td></tr></table></figure>

<p>服务启动后，需要连接这三个服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.0.105 -p 6379</span><br><span class="line">redis-cli -h 192.168.0.105 -p 6380</span><br><span class="line">redis-cli -h 192.168.0.105 -p 6381</span><br></pre></td></tr></table></figure>

<p>连接上客户端，在 master 上 set 数据后，可以分别在 slave1、slave2 上看到这些数据。</p>
<h2 id="权限校验的主从配置"><a href="#权限校验的主从配置" class="headerlink" title="权限校验的主从配置"></a>权限校验的主从配置</h2><p>在生产环境上，为了保证安全性，权限校验是非常重要的。所以，我们配置主从复制时，一定要把权限校验的功能加上去。权限校验首先需要把 master redis.conf 中的 protected-mode 值设置为 yes（默认），然后再设置密码。设置密码的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected-mode yes</span><br><span class="line">requirepass wyzane  # wyzane 就是密码</span><br></pre></td></tr></table></figure>

<p>设置完成后，使用 redis-cli 时，需要执行 auth wyzane， 即输入密码。</p>
<p>slave1 设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterauth wyzane</span><br></pre></td></tr></table></figure>

<p>slave2 设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterauth wyzane</span><br></pre></td></tr></table></figure>

<p>设置完成后，重启 Redis 服务就可以了。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵模式的配置与使用</title>
    <url>/blog/2021/05/19/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>今天介绍下 Redis 哨兵模式的配置与使用方法。</p>
<p>在 Redis 中，哨兵是一个独立的进程，它用来监控 Redis 集群中中主从服务器的运行状态，当发现 Redis 主服务器宕机后，哨兵会从集群剩下服务器中重新选择一个主服务器，从而保证集群的正常运行，即保证 Redis 集群的高可用性。</p>
<a id="more"></a>

<p>以下例子中使用的 Redis 版本均为 6.0。</p>
<h1 id="哨兵模式的配置"><a href="#哨兵模式的配置" class="headerlink" title="哨兵模式的配置"></a>哨兵模式的配置</h1><p>以搭建三个哨兵为例，Redis 哨兵模式的配置步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 首先，进入 Redis 所在目录，复制三份 sentinel.conf 文件，分别命名为 sentinel01.conf、sentinel02.conf、sentinel03.conf</span><br><span class="line"></span><br><span class="line">2. 配置 sentinel01.conf 文件的如下内容：</span><br><span class="line">sentinel monitor mymaster 192.168.172.130 6379 2</span><br><span class="line"># 监控名为 mymaster 的主服务器，主服务器ip和端口为192.168.172.130，6379，当至少有两个sentinel同意时，该主服务器才会被判定为失效</span><br><span class="line"></span><br><span class="line">sentinel auth-pass mymaster &quot;wyzane&quot;</span><br><span class="line"># 设置连接主服务器的密码</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds mymaster 10000</span><br><span class="line"># 如果服务器在给定的毫秒数之内，没有返回 Sentinel 发送的 PING 命令的回复，或者返回一个错误，那么 Sentinel 将这个服务器标记为主观下线（subjectively down，简称 SDOWN ）。</span><br><span class="line"></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"># 指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步，这个数字越小，完成故障转移所需的时间就越长。</span><br><span class="line"></span><br><span class="line">3. 对 sentinel02.conf 和 sentinel03.conf 进行同样的配置</span><br></pre></td></tr></table></figure>

<p>配置完成后，使用以下方式启动哨兵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一，分别执行以下命令：</span><br><span class="line">	redis-sentinel sentinel01.conf</span><br><span class="line">	redis-sentinel sentinel02.conf</span><br><span class="line">	redis-sentinel sentinel03.conf</span><br><span class="line">方式二，分别执行以下命令：</span><br><span class="line">	redis-server sentinel01.conf --sentinel</span><br><span class="line">	redis-server sentinel02.conf --sentinel</span><br><span class="line">	redis-server sentinel03.conf --sentinel</span><br></pre></td></tr></table></figure>

<p>以上就是 Redis 哨兵的配置和启动，下面介绍下 Redis 哨兵模式的工作原理。</p>
<h1 id="哨兵模式的原理"><a href="#哨兵模式的原理" class="headerlink" title="哨兵模式的原理"></a>哨兵模式的原理</h1><p>哨兵模式运行的大致流程如下：</p>
<p>当 Redis 集群和 Redis 哨兵启动后，哨兵通过向主服务器和从服务器发送命令，来获取主、从服务器的运行状态，参数 sentinel down-after-milliseconds 用来控制，主、从服务器收到命令后返回响应的时间。如果在给定时间内，哨兵没有收到服务器发回的响应信息，那么该哨兵就将对应的服务器标记为主观下线状态(subjectively down，简称 SDOWN ），当有多个（一般是半数以上）哨兵都把该服务器标记为主观下线状态时，那么该服务器就被标记为客观下线（objectively down， 简称 ODOWN），此时才会发生故障迁移操作。</p>
<p>Redis 的 Sentinel 中关于下线（down）有两个不同的概念：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</span><br><span class="line">2. 客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</span><br></pre></td></tr></table></figure>



<p>下面，我们来搭建一个含有一主两从的 Redis 集群，并配置三个哨兵，看一下哨兵是怎么运行的。</p>
<p>Redis 主从的配置就不多做介绍了，下面直接看启动后的日志信息。</p>
<p>Redis 主从信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主：192.168.172.131 6380</span><br><span class="line">从：192.168.172.131 6381</span><br><span class="line">从：192.168.172.131 6382</span><br></pre></td></tr></table></figure>

<p>启动 192.168.172.131 6380 和 192.168.172.131 6381 后，主服务器的日志为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16243:M 22 May 2021 00:56:23.056 * Replica 192.168.172.131:6381 asks for synchronization</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Full resync requested by replica 192.168.172.131:6381</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Replication backlog created, my new replication IDs are &#39;b643fa0d90a895b29c82b71446167e6b60d52283&#39; and &#39;0000000000000000000000000000000000000000&#39;</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">16243:M 22 May 2021 00:56:23.056 * Background saving started by pid 16254</span><br><span class="line">16254:C 22 May 2021 00:56:23.058 * DB saved on disk</span><br><span class="line">16254:C 22 May 2021 00:56:23.059 * RDB: 0 MB of memory used by copy-on-write</span><br><span class="line">16243:M 22 May 2021 00:56:23.095 * Background saving terminated with success</span><br><span class="line">16243:M 22 May 2021 00:56:23.097 * Synchronization with replica 192.168.172.131:6381 succeeded</span><br></pre></td></tr></table></figure>

<p>192.168.172.131 6381 服务器的日志为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16249:S 22 May 2021 00:56:23.054 * Master replied to PING, replication can continue...</span><br><span class="line">16249:S 22 May 2021 00:56:23.055 * Partial resynchronization not possible (no cached master)</span><br><span class="line">16249:S 22 May 2021 00:56:23.057 * Full resync from master: b643fa0d90a895b29c82b71446167e6b60d52283:0</span><br><span class="line">16249:S 22 May 2021 00:56:23.096 * MASTER &lt;-&gt; REPLICA sync: receiving 680 bytes from master to disk</span><br><span class="line">16249:S 22 May 2021 00:56:23.096 * MASTER &lt;-&gt; REPLICA sync: Flushing old data</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * Loading RDB produced by version 6.0.6</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * RDB age 0 seconds</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * RDB memory usage when created 1.83 Mb</span><br><span class="line">16249:S 22 May 2021 00:56:23.097 * MASTER &lt;-&gt; REPLICA sync: Finished with success</span><br></pre></td></tr></table></figure>

<p>上面的过程表示，从服务器连接上主服务器后，进行了数据的全量同步。同样的，启动 192.168.172.131 6382 后，数据也会进行全量同步。</p>
<p>下面再启动 Redis 哨兵。</p>
<p>执行 redis-sentinel sentinel.conf 后，哨兵服务器的日志为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16392:X 22 May 2021 01:13:36.020 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.</span><br><span class="line">16392:X 22 May 2021 01:13:36.020 # Sentinel ID is 8fd93d8d9547434177903ba11cb5ae0bf603f358</span><br><span class="line">16392:X 22 May 2021 01:13:36.020 # +monitor master mymaster 192.168.172.131 6380 quorum 2</span><br><span class="line">16392:X 22 May 2021 01:13:36.022 * +slave slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380</span><br><span class="line">16392:X 22 May 2021 01:13:36.024 * +slave slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380</span><br></pre></td></tr></table></figure>

<p>若将主服务器的进程关掉，则哨兵的日志为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16481:X 22 May 2021 01:24:02.032 # +sdown master mymaster 192.168.172.131 6380（当前哨兵认为主服务器宕机，主观下线）</span><br><span class="line">16481:X 22 May 2021 01:24:02.093 # +odown master mymaster 192.168.172.131 6380 （有三个哨兵认为主服务器宕机，超过了两个，客观下线）#quorum 3&#x2F;2</span><br><span class="line">16481:X 22 May 2021 01:24:02.093 # +new-epoch 9（递增的集群版本号）</span><br><span class="line">16481:X 22 May 2021 01:24:02.093 # +try-failover master mymaster 192.168.172.131 6380（开始尝试对集群进行故障迁移）</span><br><span class="line">16481:X 22 May 2021 01:24:02.097 # +vote-for-leader 12e1af953d931b8ac097876d7bdf803ba39c52f6 9（选出一个哨兵，作为故障迁移的leader，当前哨兵，投票给 Sentinel ID 为 12e1af953d931b8ac097876d7bdf803ba39c52f6 的哨兵）</span><br><span class="line">16481:X 22 May 2021 01:24:02.103 # 2c2c810af7936fba2facbeb159b0f7fa1e87d325 voted for 2c2c810af7936fba2facbeb159b0f7fa1e87d325 9（其它哨兵投票）</span><br><span class="line">16481:X 22 May 2021 01:24:02.106 # 8fd93d8d9547434177903ba11cb5ae0bf603f358 voted for 12e1af953d931b8ac097876d7bdf803ba39c52f6 9（其它哨兵投票）</span><br><span class="line">16481:X 22 May 2021 01:24:02.187 # +elected-leader master mymaster 192.168.172.131 6380（当前的主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.188 # +failover-state-select-slave master mymaster 192.168.172.131 6380（分析从节点的状态）</span><br><span class="line">16481:X 22 May 2021 01:24:02.265 # +selected-slave slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（选出一个从节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.265 * +failover-state-send-slaveof-noone slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（将上面选出的从节点与现在的主节点进行主从切换）</span><br><span class="line">16481:X 22 May 2021 01:24:02.355 * +failover-state-wait-promotion slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（等待从节点升级成主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.531 # +promoted-slave slave 192.168.172.131:6382 192.168.172.131 6382 @ mymaster 192.168.172.131 6380（从节点已经升级为主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:02.532 # +failover-state-reconf-slaves master mymaster 192.168.172.131 6380（修改原来主节点的配置文件）</span><br><span class="line">16481:X 22 May 2021 01:24:02.586 * +slave-reconf-sent slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380（重写从节点的配置文件，即为从节点配置新的主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:03.229 # -odown master mymaster 192.168.172.131 6380</span><br><span class="line">16481:X 22 May 2021 01:24:03.565 * +slave-reconf-inprog slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380（从节点正在重新指向为新的主节点）</span><br><span class="line">16481:X 22 May 2021 01:24:03.565 * +slave-reconf-done slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6380（从节点配置完毕）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 # +failover-end master mymaster 192.168.172.131 6380（故障迁移结束）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 # +switch-master mymaster 192.168.172.131 6380 192.168.172.131 6382（故障迁移成功，哨兵开始监控新的主服务器）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 * +slave slave 192.168.172.131:6381 192.168.172.131 6381 @ mymaster 192.168.172.131 6382（确认新主节点的从节点）</span><br><span class="line">16481:X 22 May 2021 01:24:03.648 * +slave slave 192.168.172.131:6380 192.168.172.131 6380 @ mymaster 192.168.172.131 6382（确认新主节点的从节点）</span><br><span class="line">16481:X 22 May 2021 01:24:08.662 # +sdown slave 192.168.172.131:6380 192.168.172.131 6380 @ mymaster 192.168.172.131 6382（原主节点变为slave节点并且主观下线）</span><br></pre></td></tr></table></figure>

<p>上面的日志是哨兵发现主服务器宕机后，故障恢复的的一个过程。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中子组件与父组件</title>
    <url>/blog/2020/05/24/Vue%E4%B8%AD%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%88%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>今天介绍下 Vue 中子组件与父组件之间如何传递数据。</p>
<a id="more"></a>

<h1 id="父组件向子组件传递数据"><a href="#父组件向子组件传递数据" class="headerlink" title="父组件向子组件传递数据"></a>父组件向子组件传递数据</h1><h2 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h2><p>在子组件中，使用props用来接收父组件中传递的数据。使用如下：</p>
<p>Parent.vue：通过:userInfo=”userInfo”绑定需要传递的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:userInfo</span>=<span class="string">"userInfo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      userInfo: &#123;</span><br><span class="line"><span class="actionscript">        name: <span class="string">'小明'</span>,</span></span><br><span class="line">        age: 16</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Child.vue：在子组件中，通过props接收传递进来的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    &#123;&#123; userInfo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  props: [<span class="string">'userInfo'</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="传递方法"><a href="#传递方法" class="headerlink" title="传递方法"></a>传递方法</h2><p>在子组件中使用父组件中的方法有三种方式实现。</p>
<h3 id="使用-this-parent"><a href="#使用-this-parent" class="headerlink" title="使用 this.$parent"></a>使用 this.$parent</h3><p>在子组件中使用 this.$parent 调用父组件中的方法。</p>
<p>Child.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getData"</span>&gt;</span>调用父组件中的方法<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    getData () &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> data = <span class="keyword">this</span>.$parent.createData()</span></span><br><span class="line">      alert(data.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="使用-this-emit"><a href="#使用-this-emit" class="headerlink" title="使用 this.$emit"></a>使用 this.$emit</h3><p>Child.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getData"</span>&gt;</span>调用父组件中的方法<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      info: <span class="string">'child com'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getData () &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 调用子组件中的方法</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> data = <span class="keyword">this</span>.$emit(<span class="string">'createData'</span>, <span class="keyword">this</span>.info)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(data)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Parent.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 把父组件中的方法传递给子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Child</span> @<span class="attr">createData</span>=<span class="string">"createData"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      userInfo: &#123;</span><br><span class="line"><span class="actionscript">        name: <span class="string">'小明'</span>,</span></span><br><span class="line">        age: 16</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    createData (info) &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.userInfo.name)</span></span><br><span class="line">      alert(info)</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="keyword">this</span>.userInfo.name</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="将方法传入子组件中"><a href="#将方法传入子组件中" class="headerlink" title="将方法传入子组件中"></a>将方法传入子组件中</h3><p>Child.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getData"</span>&gt;</span>调用父组件中的方法<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 定义待接收的方法</span></span></span><br><span class="line">    createData: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">default</span>: <span class="literal">null</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getData () &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> data = <span class="keyword">this</span>.createData()</span></span><br><span class="line">      alert(data.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Parent.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将方法传递给子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:createData</span>=<span class="string">"createData"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      userInfo: &#123;</span><br><span class="line"><span class="actionscript">        name: <span class="string">'小明'</span>,</span></span><br><span class="line">        age: 16</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    createData () &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="keyword">this</span>.userInfo</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h1><p>子组件中通过使用 this.$emit 向父组件传递数据，传递时指定一个 key，父组件中使用 @key 接收数据。</p>
<p>Parent.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 接收子组件中传递进来的数据，</span></span><br><span class="line"><span class="comment">	@sendMsg要与子组件中this.$emit('sendMsg', this.info)对应 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Child</span> @<span class="attr">sendMsg</span>=<span class="string">"getData"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      userInfo: &#123;</span><br><span class="line"><span class="actionscript">        name: <span class="string">'小明'</span>,</span></span><br><span class="line">        age: 16</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getData (info) &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// info是子组件中传递进来的数据</span></span></span><br><span class="line">      alert(info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Child.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"sendData"</span>&gt;</span>发送数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      info: <span class="string">'i am child'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendData () &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 向父组件中传递数据,sendMsg名称要与父组件中对应的名称一致</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$emit(<span class="string">'sendMsg'</span>, <span class="keyword">this</span>.info)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Frontend</category>
      </categories>
  </entry>
  <entry>
    <title>Vue中插槽的使用</title>
    <url>/blog/2020/05/16/Vue%E4%B8%AD%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>今天介绍下 Vue 中插槽的使用。</p>
<a id="more"></a>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用 slot 标签表示插槽，在vue中插槽是内容分发的出口。</p>
<p>下面看一个简单的例子：</p>
<p>CSlot1.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽测试1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      name1: <span class="string">'hello slot1'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSlot2.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CSlot1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>插槽测试2<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello slot<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; name1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CSlot1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> CSlot1 <span class="keyword">from</span> <span class="string">'./CSlot1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      name2: <span class="string">'hello slot2'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  name: <span class="string">'SClot2'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    CSlot1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，CSlot2是CSlot1的父组件。当不在子组件中使用<slot></slot>时，父组件中<CSlot1>中的内容就不会显示出来，只有使用了<slot></slot>才会显示出来。</p>
<p>所以，插槽是使用在子组件中，为了将父组件中子组件模板的数据正常显示。</p>
<p>在父组件的子组件模板中，是不能使用子组件中的数据的，即CSlot2中不能访问CSlot1中的name1，可以使用CSlot2中的name2。即父组件中的所有内容（不管是插槽还是什么），作用域只能是父组件。</p>
<p>可以为插槽设置默认内容。</p>
<p>CSlot1.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽测试1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      name1: <span class="string">'hello slot1'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSlot2.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CSlot1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CSlot1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> CSlot1 <span class="keyword">from</span> <span class="string">'./CSlot1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      name2: <span class="string">'hello slot2'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  name: <span class="string">'SClot2'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    CSlot1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当父组件中的子组件模板中没有内容时，插槽中的默认内容会被显示，反之则不会被显示。</p>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>具名插槽中含有一个 name 属性，例子如下：</p>
<p>CSlot1.vue：子组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽测试1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"s1"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>====================<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"s2"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      name1: <span class="string">'hello slot1'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSlot2.vue：父组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽测试2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CSlot1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"s1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>武汉加油，湖北加油，全国加油！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"s2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>wuhan courage<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CSlot1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> CSlot1 <span class="keyword">from</span> <span class="string">'./CSlot1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      name2: <span class="string">'hello slot2'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  name: <span class="string">'SClot2'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    CSlot1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父组件中，通过使用slot=”xxx”，给插槽指定名称，在子组件中使用<slot name="xxx"></slot>来接收对应插槽中的数据。</p>
<p>父组件还可以这样写：使用v-slot:xxx 指令</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽测试2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CSlot1</span> <span class="attr">slot</span>=<span class="string">"cslot1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>武汉加油，湖北加油，全国加油！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>wuhan courage<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CSlot1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> CSlot1 <span class="keyword">from</span> <span class="string">'./CSlot1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      name2: <span class="string">'hello slot2'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  name: <span class="string">'SClot2'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    CSlot1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>前面说过，在父组件中不能使用子组件中的数据。在这里，作用域插槽中，父组件可以使用子组件中的数据。</p>
<p>CSlot1.vue：子组件，子组件的插槽中使用 :data 绑定数据，以便在父组件中接收数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽测试1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">"name1"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      name1: <span class="string">'hello slot1'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSlot2.vue：在父组件中使用 slot-scope 接收子组件中的数据，然后就可以使用了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽测试2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CSlot1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>  =<span class="string">"info"</span>&gt;</span></span><br><span class="line">        &#123;&#123; info.data &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CSlot1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> CSlot1 <span class="keyword">from</span> <span class="string">'./CSlot1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      name2: <span class="string">'hello slot2'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  name: <span class="string">'SClot2'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    CSlot1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Frontend</category>
      </categories>
  </entry>
  <entry>
    <title>django开发中channels的使用</title>
    <url>/blog/2020/05/05/django%E5%BC%80%E5%8F%91%E4%B8%ADchannels%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>今天介绍下在django中使用channels实现websocket的步骤。</p>
<a id="more"></a>

<p>首先介绍下channels。<br>channels官方文档连接如下：<br><a href="https://channels.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://channels.readthedocs.io/en/latest/</a></p>
<p>channels这个第三方包可以帮助django在http之上扩展很多功能，可以使django实现websocket，聊天协议等。channels可以使django运行在同步模式下，但是异步的处理connections和socket。</p>
<p>下面介绍在django中，使用channels实现websocket功能。下面DjangoChannel是项目名称，test01是app名称。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>python3.6 channels2.1.7 channels-redis2.3.3 django2.0.5 drf3.9.2</p>
<h1 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h1><p>index.html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>cchannels实现websocket<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-1.11.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="comment">//&lt;![CDATA[</span></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'#sendMsg'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8000/ws/status/1"</span>)</span></span><br><span class="line"><span class="actionscript">            socket.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'WebSocket open'</span>) <span class="comment">//成功连接上Websocket</span></span></span><br><span class="line"><span class="javascript">                socket.send($(<span class="string">'#msg'</span>).val())  <span class="comment">//发送数据到服务端</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            socket.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(ret)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(ret.data)</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> msg = data[<span class="string">"message"</span>]</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'message: '</span> + msg)<span class="comment">//打印服务端返回的数据</span></span></span><br><span class="line"><span class="javascript">                $(<span class="string">'#retMsg'</span>).prepend(<span class="string">'&lt;p&gt;'</span> + msg + <span class="string">'&lt;/p&gt;'</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="actionscript">    <span class="comment">//]]&gt;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"msg"</span> <span class="attr">value</span>=<span class="string">"Hello, World!"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"sendMsg"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Received Messages<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"retMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="routing配置"><a href="#routing配置" class="headerlink" title="routing配置"></a>routing配置</h1><p>test01/routing.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> consumers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">websocket_urlpatterns = [</span><br><span class="line">    path(<span class="string">'ws/status/&amp;lt;client_id&amp;gt;'</span>, consumers.ServiceConsumer),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>DjangoChannel/routing.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> channels.auth <span class="keyword">import</span> AuthMiddlewareStack</span><br><span class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> ProtocolTypeRouter, URLRouter</span><br><span class="line"><span class="keyword">import</span> test01.routing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">application = ProtocolTypeRouter(&#123;</span><br><span class="line">    <span class="string">'websocket'</span>: AuthMiddlewareStack(</span><br><span class="line">        URLRouter(</span><br><span class="line">            test01.routing.websocket_urlpatterns</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="consumer的编写"><a href="#consumer的编写" class="headerlink" title="consumer的编写"></a>consumer的编写</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> channels.generic.websocket <span class="keyword">import</span> AsyncWebsocketConsumer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceConsumer</span><span class="params">(AsyncWebsocketConsumer)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        连接成功后执行该函数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># self.scope中保存了请求头、请求体等信息</span></span><br><span class="line">        self.client_id = self.scope[<span class="string">'url_route'</span>][<span class="string">'kwargs'</span>][<span class="string">'client_id'</span>]</span><br><span class="line">        self.room_group_name = <span class="string">'group_%s'</span> % self.client_id</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"scope:"</span>, self.scope)</span><br><span class="line">        print(<span class="string">"client id:"</span>, self.client_id)  <span class="comment"># client id: 1</span></span><br><span class="line">        print(<span class="string">"channel layer:"</span>, self.channel_layer)  <span class="comment"># channel layer: RedisChannelLayer(hosts=[&#123;'address': ('127.0.0.1', 6379)&#125;])</span></span><br><span class="line">        print(<span class="string">"channel name:"</span>, self.channel_name)  <span class="comment"># channel name: specific.VgcSONTt!RxtpUIegoTzX</span></span><br><span class="line">        print(<span class="string">"room group name:"</span>, self.room_group_name)  <span class="comment"># room group name: group_1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> self.channel_layer.group_add(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line">        print(<span class="string">"channel layer:"</span>, self.channel_layer)  <span class="comment"># channel layer: RedisChannelLayer(hosts=[&#123;'address': ('127.0.0.1', 6379)&#125;])</span></span><br><span class="line">        <span class="keyword">await</span> self.accept()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">disconnect</span><span class="params">(self, close_code)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        与客户端断开连接</span></span><br><span class="line"><span class="string">        :param close_code:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">await</span> self.channel_layer.group_discard(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, text_data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        接受客户端websocket发送过来的信息</span></span><br><span class="line"><span class="string">        :param text_data:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">"test data:"</span>, text_data)  <span class="comment"># test data: Hello, World!</span></span><br><span class="line">        print(<span class="string">"group name:"</span>, self.room_group_name)  <span class="comment"># group name: group_1</span></span><br><span class="line"></span><br><span class="line">        message = text_data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向指定room group中发送一个event信息，chat_message为对应处理函数</span></span><br><span class="line">        <span class="comment"># 会调用下面的chat_message()方法</span></span><br><span class="line">        <span class="keyword">await</span> self.channel_layer.group_send(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'type'</span>: <span class="string">'chat_message'</span>,</span><br><span class="line">                <span class="string">'message'</span>: message,</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">chat_message</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        接收room group中传过来的信息，并把信息发送给websocket，发送给前端</span></span><br><span class="line"><span class="string">        :param event:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        message = event[<span class="string">'message'</span>]</span><br><span class="line">        print(<span class="string">"event:"</span>, event)  <span class="comment"># event: &#123;'type': 'chat_message', 'message': 'Hello, World!'&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向前端发送消息</span></span><br><span class="line">        <span class="keyword">await</span> self.send(text_data=json.dumps(&#123;</span><br><span class="line">            <span class="string">'message'</span>: message</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<h1 id="settings配置"><a href="#settings配置" class="headerlink" title="settings配置"></a>settings配置</h1><p>DjangoChannel/asgi.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> get_default_application</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"DjangoChannels2.settings"</span>)</span><br><span class="line">django.setup()</span><br><span class="line">application = get_default_application()</span><br></pre></td></tr></table></figure>

<p>DjangoChannel/settings.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'channels'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">CHANNEL_LAYERS = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">    <span class="string">'BACKEND'</span>: <span class="string">'channels_redis.core.RedisChannelLayer'</span>,</span><br><span class="line">    <span class="string">'CONFIG'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"hosts"</span>: [(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>)],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASGI_APPLICATION = <span class="string">"DjangoChannel.routing.application"</span></span><br></pre></td></tr></table></figure>

<p>到这里，整个项目就完成了。当访问index.html后，在输入框中输入消息，点击发送按钮后，后端就会接收到消息，并将消息又发回到页面上。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发中drf视图的使用</title>
    <url>/blog/2020/05/05/django%E5%BC%80%E5%8F%91%E4%B8%ADdrf%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>使用django开发前后端分离项目时，django rest framework（以下简称drf）是常用的扩展库，今天主要介绍下drf中几个视图的使用。</p>
<a id="more"></a>

<p>下面例子中涉及的model对象为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksModel</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    author = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    star = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">"books"</span></span><br></pre></td></tr></table></figure>

<p>序列化类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.BooksModel</span><br><span class="line">        fields = <span class="string">'__all__'</span></span><br></pre></td></tr></table></figure>

<h1 id="APIView"><a href="#APIView" class="headerlink" title="APIView"></a>APIView</h1><p>APIView继承自django的View，APIView中对request进行了封装。<br>在继承自APIView的视图中，你可以使用request.data和request.query_params来接收请求数据，类似于标准django视图中的request.POST和request.GET。例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    <span class="comment"># get请求中接收参数</span></span><br><span class="line">    id = request.query_params.get(<span class="string">"id"</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> Response(...)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    <span class="comment"># post方法中接收参数</span></span><br><span class="line">    name = request.data.get(<span class="string">"name"</span>)</span><br><span class="line">    author = request.data.get(<span class="string">"author"</span>)</span><br><span class="line">    star = request.data.get(<span class="string">"star"</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> Response(...)</span><br></pre></td></tr></table></figure>

<p>在继承自APIView的视图中，可以添加authentication_classes、permission_classes 类，分别用于身份认证和权限认证。可以使用自带的认证类，也可以自定义认证类。</p>
<h1 id="GenericAPIView"><a href="#GenericAPIView" class="headerlink" title="GenericAPIView"></a>GenericAPIView</h1><p>继承自APIView，主要是增加了操作序列化器和数据库查询的方法。<br>GenericAPIView的视图中可以指定以下属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queryset 列表视图的查询集</span><br><span class="line">serializer_class 视图使用的序列化器</span><br><span class="line">pagination_class 分页控制类</span><br><span class="line">filter_backends 过滤控制后端</span><br><span class="line">lookup_field：查询单一数据库对象时使用的条件字段，默认为pk</span><br></pre></td></tr></table></figure>

<p>可以使用下面的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get_queryset : 获取视图对应的查询集，是列表视图和详细视图获取数据的基础；默认返回的是queryset 的属性，可重写</span><br><span class="line">get_serializer_class : 获取序列化器类，默认返回的是serializer_class，可重写；</span><br><span class="line">get_serializer(self, args, *kwargs)：获取序列化器对象，这一步相对于APIView来说，就免去了创建序列化对象；</span><br><span class="line">get_serializer_context(self)：这个是给序列化器返回的一个context属性，context属性里面有‘request’，‘format’，‘view’值可以在序列化器类中使用。</span><br><span class="line">get_object(self) : 返回详情视图所需的模型类数据对象，默认使用lookup_field参数来过滤queryset。 在试图中可以调用该方法获取详情信息的模型类对象</span><br></pre></td></tr></table></figure>

<p>例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urls.py:</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'book/&amp;lt;pk&amp;gt;'</span>, views.BookView.as_view())</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">views.py:</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> GenericAPIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span><span class="params">(GenericAPIView)</span>:</span></span><br><span class="line">    <span class="comment"># 查询集</span></span><br><span class="line">    queryset = models.BooksModel.objects.all()</span><br><span class="line">    <span class="comment"># 指定序列化类</span></span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        “”” 查询某个书籍的具体信息 ”””</span><br><span class="line">        book = self.get_object()</span><br><span class="line">        ser = self.get_serializer(book)</span><br><span class="line">        <span class="keyword">return</span> Response(ser.data)</span><br></pre></td></tr></table></figure>

<h1 id="ViewSetMixin"><a href="#ViewSetMixin" class="headerlink" title="ViewSetMixin"></a>ViewSetMixin</h1><p>在定义路由时，这种视图可以实现将http方法名与自定义的方法名称映射，下面可以下例子：</p>
<p>两个get请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urls.py:</span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> BookView</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">"book/"</span>, BookView.as_view(&#123;<span class="string">'get'</span>: <span class="string">'list'</span>&#125;)),</span><br><span class="line">    path(<span class="string">"book/id"</span>, BookView.as_view(&#123;<span class="string">'get'</span>: <span class="string">'retrive'</span>&#125;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">views.py:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span><span class="params">(ViewSetMixin, APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">        ret = &#123;<span class="string">"code"</span>: <span class="number">10000</span>, <span class="string">"data"</span>: <span class="literal">None</span>&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            book_objs = models.BooksModel.objects.all()</span><br><span class="line">            book_ser = BookInfoSerializer(instance=book_objs, many=<span class="literal">True</span>)</span><br><span class="line">            ret[<span class="string">"data"</span>] = book_ser.data</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ret[<span class="string">"code"</span>] = <span class="number">10001</span></span><br><span class="line">            ret[<span class="string">"error"</span>] = <span class="string">"获取数据失败"</span></span><br><span class="line">        <span class="keyword">return</span> Response(ret)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrive</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        ret = &#123;<span class="string">"code"</span>: <span class="number">10000</span>, <span class="string">"data"</span>: <span class="literal">None</span>&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pk = kwargs.get(<span class="string">"id"</span>)</span><br><span class="line">            <span class="comment"># 查询课程详细表</span></span><br><span class="line">            book_objs = models.BooksModel.objects.filter(course_id=pk).first()</span><br><span class="line">            book_ser = CourseInfoSerializer(instance=book_objs, many=<span class="literal">False</span>)</span><br><span class="line">            ret[<span class="string">"data"</span>] = book_ser.data</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">"e:"</span>, e)</span><br><span class="line">            ret[<span class="string">"code"</span>] = <span class="number">10001</span></span><br><span class="line">            ret[<span class="string">"error"</span>] = <span class="string">"获取数据失败"</span></span><br><span class="line">        <span class="keyword">return</span> Response(ret)</span><br></pre></td></tr></table></figure>



<p>get和post请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urls.py:</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'book2/'</span>, views.Book2View.as_view(&#123;<span class="string">"get"</span>: <span class="string">'list'</span>, <span class="string">"post"</span>: <span class="string">'create'</span>&#125;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">views.py:</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ViewSetMixin</span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> GenericAPIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book2View</span><span class="params">(ViewSetMixin, APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        books = models.BooksModel.objects.all()</span><br><span class="line">        ser = BookInfoSerializer(instance=books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(ser.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        name = request.data.get(<span class="string">"name"</span>)</span><br><span class="line">        author = request.data.get(<span class="string">"author"</span>)</span><br><span class="line">        star = request.data.get(<span class="string">"star"</span>)</span><br><span class="line">        book_info = &#123;</span><br><span class="line">            <span class="string">"name"</span>: name,</span><br><span class="line">            <span class="string">"author"</span>: author,</span><br><span class="line">            <span class="string">"star"</span>: star</span><br><span class="line">        &#125;</span><br><span class="line">        models.BooksModel.objects.create(**book_info)</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>))</span><br></pre></td></tr></table></figure>



<h1 id="视图集ViewSet"><a href="#视图集ViewSet" class="headerlink" title="视图集ViewSet"></a>视图集ViewSet</h1><p>继承自APIView与ViewSetMixin，可以实现与APIView类似的功能，如身份认证、权限校验、流量管理等；也可以实现在调用as_view()时传入字典（如{‘get’:’list’}）的映射处理工作。</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urls.py:</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'book5/'</span>, views.Book5View.as_view(&#123;<span class="string">"get"</span>: <span class="string">'list'</span>, <span class="string">"post"</span>: <span class="string">'create'</span>&#125;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">views.py</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book5View</span><span class="params">(ViewSet)</span>:</span></span><br><span class="line">    <span class="string">""" 同ViewSetMixin + APIView """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        books = models.BooksModel.objects.all()</span><br><span class="line">        ser = BookInfoSerializer(instance=books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(ser.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        name = request.data.get(<span class="string">"name"</span>)</span><br><span class="line">        author = request.data.get(<span class="string">"author"</span>)</span><br><span class="line">        star = request.data.get(<span class="string">"star"</span>)</span><br><span class="line">        book_info = &#123;</span><br><span class="line">            <span class="string">"name"</span>: name,</span><br><span class="line">            <span class="string">"author"</span>: author,</span><br><span class="line">            <span class="string">"star"</span>: star</span><br><span class="line">        &#125;</span><br><span class="line">        models.BooksModel.objects.create(**book_info)</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>))</span><br></pre></td></tr></table></figure>



<h1 id="GenericViewSet"><a href="#GenericViewSet" class="headerlink" title="GenericViewSet"></a>GenericViewSet</h1><p>继承自GenericAPIView+ViewSetMixin，比上面讲到的ViewSet更方便，在实现了调用as_view()时传入字典（如{‘get’:’list’}）的映射处理工作的同时，还提供了GenericAPIView提供的基础方法，不用再编写ViewSet中的list()、create()等方法。<br>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urls.py:</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'book6/'</span>, views.Book6View.as_view(&#123;<span class="string">'get'</span>: <span class="string">'list'</span>&#125;)),</span><br><span class="line">    path(<span class="string">'book6/&amp;lt;pk&amp;gt;'</span>, views.Book6View.as_view(&#123;<span class="string">'get'</span>: <span class="string">'retrive'</span>&#125;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">views.py</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book6View</span><span class="params">(GenericViewSet)</span>:</span></span><br><span class="line">    <span class="string">""" 同GenericAPIView + ViewSetMixin """</span></span><br><span class="line">    <span class="comment"># 查询集</span></span><br><span class="line">    queryset = models.BooksModel.objects.all()</span><br><span class="line">    <span class="comment"># 指定序列化类</span></span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        book = self.get_queryset()</span><br><span class="line">        ser = self.get_serializer(instance=book, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(ser.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrive</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        book = self.get_object()</span><br><span class="line">        ser = self.get_serializer(book)</span><br><span class="line">        <span class="keyword">return</span> Response(ser.data)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发中signals信号的使用</title>
    <url>/blog/2020/05/05/django%E5%BC%80%E5%8F%91%E4%B8%ADsignals%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>django 中提供了信号机制，它类似于数据库中的触发器，也类似于编程中的回调函数。</p>
<a id="more"></a>

<p>在 signals 中，我们可以自定义需要执行的函数，当某个动作（如model对象被保存）发生时，可以触发自定义函数的执行。</p>
<p>django中有内置的信号，我们也可以自定义信号。<br>django中有以下常用内置信号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django.db.models.signals.pre_save 在某个Model保存之前调用</span><br><span class="line">django.db.models.signals.post_save 在某个Model保存之后调用</span><br><span class="line">django.db.models.signals.pre_delete 在某个Model删除之前调用</span><br><span class="line">django.db.models.signals.post_delete 在某个Model删除之后调用</span><br><span class="line">django.core.signals.request_started 在建立Http请求时发送</span><br><span class="line">django.core.signals.request_finished 在关闭Http请求时发送</span><br></pre></td></tr></table></figure>

<p>其他内置信号可以查看官方文档：<br><a href="https://docs.djangoproject.com/en/2.1/topics/signals/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.1/topics/signals/</a></p>
<p>下面介绍下内置信号和自定义信号的使用。</p>
<h1 id="内置信号"><a href="#内置信号" class="headerlink" title="内置信号"></a>内置信号</h1><p>下面举一个post_save的例子，test01 是 app 名称。</p>
<p>首先在 test01/signals/handler.py 中定义signal函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> ..models <span class="keyword">import</span> StudentModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(post_save)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_signal</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    所有Model被保存后，都会触发该函数的执行</span></span><br><span class="line"><span class="string">    :param sender:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"save_signal sender:"</span>, sender)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># sender用于指定哪个model被保存后触发该函数的执行</span></span><br><span class="line"><span class="meta">@receiver(post_save, sender=StudentModel)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student_signal</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    StudentModel被保存后，触发该函数的执行</span></span><br><span class="line"><span class="string">    :param sender:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"student_signal sender:"</span>, sender)</span><br></pre></td></tr></table></figure>

<p>在 test01/views.py 中定义视图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> UserModel, StudentModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserView</span><span class="params">(APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">"-- user view --"</span>)</span><br><span class="line">        UserModel.objects.create(username=<span class="string">"wyzane"</span>, password=<span class="string">"123456"</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">"OK"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentView</span><span class="params">(APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">"-- student view --"</span>)</span><br><span class="line">        StudentModel.objects.create(name=<span class="string">"wyzane"</span>, age=<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">"OK"</span>)</span><br></pre></td></tr></table></figure>

<p>配置 test01/apps.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test01AppConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = <span class="string">"test01"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"-- Test01AppConfig --"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> .signals <span class="keyword">import</span> handler</span><br></pre></td></tr></table></figure>

<p>配置 <strong>test01/</strong>init.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default_app_config = <span class="string">'test01.apps.Test01AppConfig'</span></span><br></pre></td></tr></table></figure>

<p>此时在postman中分别请求下面两个url：<br><a href="http://127.0.0.1:8000/test01/user/" target="_blank" rel="noopener">http://127.0.0.1:8000/test01/user/</a><br><a href="http://127.0.0.1:8000/test01/student/" target="_blank" rel="noopener">http://127.0.0.1:8000/test01/student/</a><br>打印的结果分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- user view --</span><br><span class="line">save_signal sender: &lt;class &#39;test01.models.UserModel&#39;;</span><br><span class="line"></span><br><span class="line">-- student view --</span><br><span class="line">save_signal sender: &lt;class &#39;test01.models.StudentModel&#39;;</span><br><span class="line">student_signal sender: &lt;class &#39;test01.models.StudentModel&#39;;</span><br></pre></td></tr></table></figure>

<p>通过上面的结果，我们也可以看出信号中使用和不使用sender参数区别。</p>
<h1 id="自定义信号"><a href="#自定义信号" class="headerlink" title="自定义信号"></a>自定义信号</h1><p>下面介绍下自定义信号的使用。</p>
<p>定义信号 test01/signals/signals.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> django.dispatch</span><br><span class="line"></span><br><span class="line">signal01 = django.dispatch.Signal(providing_args=[<span class="string">"p1"</span>, <span class="string">"p2"</span>])</span><br></pre></td></tr></table></figure>

<p>在视图中触发自定义信号 test01/views.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> .signals.signals <span class="keyword">import</span> signal01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignalView</span><span class="params">(APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment"># 触发自定义信号</span></span><br><span class="line">        signal01.send(sender=<span class="string">"signal_view"</span>, p1=<span class="string">"wyzane"</span>, p2=<span class="number">18</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">"OK"</span>)</span><br></pre></td></tr></table></figure>

<p>编写处理函数，即收到信号后要做哪些操作 test01/signals/handler.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> .signals <span class="keyword">import</span> signal01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(signal01)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_signal</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    信号触发后执行的操作</span></span><br><span class="line"><span class="string">    :param sender: </span></span><br><span class="line"><span class="string">    :param kwargs: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"my signal:"</span>, sender, kwargs)</span><br></pre></td></tr></table></figure>

<p>下一步就是配置，这里的配置与内置信号中的配置相同，就不介绍了。</p>
<p>配置完成后，请求下面的url<br><a href="http://127.0.0.1:8000/test01/signal/" target="_blank" rel="noopener">http://127.0.0.1:8000/test01/signal/</a><br>看到打印的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my signal: signal_view &#123;‘signal’: &lt;django.dispatch.dispatcher.Signal object at 0x000001F57FCA1160&gt;, ‘p1’: ‘wyzane’, ‘p2’: 18&#125;</span><br></pre></td></tr></table></figure>



<p>上面的配置中使用了 AppConfig，AppConfig 是用来设置 django中 每个 app 属性的，上面的配置中定义了一个Test01AppConfig 类来继承 AppConfig，并在 init.py 中使用 default_app_config 来加载这个类。<br>重写在ready方法中的代码会在django运行的时候执行。<br>感兴趣的小伙伴可以看下官方文档的介绍：<br><a href="https://docs.djangoproject.com/en/2.1/ref/applications/。" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.1/ref/applications/。</a></p>
<p>signals信号的知识就介绍到这里。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发之mongodb的配置与使用</title>
    <url>/blog/2020/06/06/django%E5%BC%80%E5%8F%91%E4%B9%8Bmongodb%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>今天整理了一下在django项目中如何使用mongodb, 环境如下：<br>ubuntu18.04, django2.0.5, drf3.9, mongoengine0.16</p>
<a id="more"></a>

<h1 id="配置mongodb"><a href="#配置mongodb" class="headerlink" title="配置mongodb"></a>配置mongodb</h1><p>在settings.py中配置mongodb和mysql,配置如下(可以同时使用mysql和mongodb)：这里使用的第三方库是 mongoengine，需要使用 pip 进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATABASES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,   # 数据库引擎</span><br><span class="line">        &#39;NAME&#39;: &#39;django_test2&#39;,                  # 你要存储数据的库名，事先要创建之</span><br><span class="line">        &#39;USER&#39;: &#39;root&#39;,                         # 数据库用户名</span><br><span class="line">        &#39;PASSWORD&#39;: &#39;wyzane&#39;,                     # 密码</span><br><span class="line">        &#39;HOST&#39;: &#39;localhost&#39;,                    # 主机</span><br><span class="line">        &#39;PORT&#39;: &#39;3306&#39;,                         # 数据库使用的端口</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;mongotest&#39;: &#123;</span><br><span class="line">        &#39;ENGINE&#39;: None,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import mongoengine</span><br><span class="line"># 连接mongodb中数据库名称为mongotest5的数据库</span><br><span class="line">conn &#x3D; mongoengine.connect(&quot;mongotest&quot;)</span><br></pre></td></tr></table></figure>



<h1 id="mongodb使用"><a href="#mongodb使用" class="headerlink" title="mongodb使用"></a>mongodb使用</h1><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><h3 id="插入-json-类型的数据"><a href="#插入-json-类型的数据" class="headerlink" title="插入 json 类型的数据"></a>插入 json 类型的数据</h3><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py:</span></span><br><span class="line"><span class="keyword">import</span> mongoengine</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModel</span><span class="params">(mongoengine.Document)</span>:</span></span><br><span class="line">    name = mongoengine.StringField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = mongoengine.IntField()</span><br><span class="line">    password = mongoengine.StringField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># views.py:</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstMongoView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        name = request.data[<span class="string">"name"</span>]</span><br><span class="line">        age = request.data[<span class="string">"age"</span>]</span><br><span class="line">        password = request.data[<span class="string">"password"</span>]</span><br><span class="line">        StudentModel.objects.create(name=name, age=age, password=password)</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>

<p>请求数据格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;nihao&quot;,</span><br><span class="line">    &quot;age&quot;: 18,</span><br><span class="line">    &quot;password&quot;: &quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入含有list的json数据"><a href="#插入含有list的json数据" class="headerlink" title="插入含有list的json数据"></a>插入含有list的json数据</h3><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py:</span></span><br><span class="line"><span class="keyword">import</span> mongoengine</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2Model</span><span class="params">(mongoengine.Document)</span>:</span></span><br><span class="line">    name = mongoengine.StringField(max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="comment"># 用于存储list类型的数据</span></span><br><span class="line">    score = mongoengine.ListField()</span><br><span class="line"></span><br><span class="line"><span class="comment"># views.py:</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstMongo2View</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        name = request.data[<span class="string">"name"</span>]</span><br><span class="line">        score = request.data[<span class="string">"score"</span>]</span><br><span class="line">        Student2Model.objects.create(name=name, score=score)</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>

<p>请求数据格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;score&quot;: [12, 13]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入含有list和dict的json数据"><a href="#插入含有list和dict的json数据" class="headerlink" title="插入含有list和dict的json数据"></a>插入含有list和dict的json数据</h3><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py:</span></span><br><span class="line"><span class="keyword">import</span> mongoengine</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student3Model</span><span class="params">(mongoengine.Document)</span>:</span></span><br><span class="line">    name = mongoengine.StringField(max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="comment"># DictField用于存储字典类型的数据</span></span><br><span class="line">    score = mongoengine.DictField()</span><br><span class="line"><span class="comment"># views.py:</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstMongo3View</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        name = request.data[<span class="string">"name"</span>]</span><br><span class="line">        score = request.data[<span class="string">"score"</span>]</span><br><span class="line">        Student3Model.objects.create(name=name, score=score)</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>

<p>请求数据格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;score&quot;: &#123;&quot;xiaoming&quot;: 12, &quot;xiaoli&quot;: 13&#125;</span><br><span class="line">&#125;</span><br><span class="line">或者:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;score&quot;: &#123;&quot;xiaoming&quot;: 12, &quot;xiaoli&quot;: &#123;&quot;xiaozhao&quot;: 14&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">或者:</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;test&quot;,</span><br><span class="line">&quot;score&quot;: &#123;&quot;xiaoming&quot;: 12, &quot;xiaoli&quot;: &#123;&quot;xiaozhao&quot;: &#123;&quot;xiaoliu&quot;: 12, &quot;xiaojian&quot;: 18&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">或者:</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;test&quot;,</span><br><span class="line">&quot;score&quot;: &#123;&quot;xiaoming&quot;: 12, &quot;xiaoli&quot;: &#123;&quot;xiaozhao&quot;: &#123;&quot;xiaoliu&quot;: 12, &quot;xiaojian&quot;: [12,13,14]&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="查询并序列化复杂json数据"><a href="#查询并序列化复杂json数据" class="headerlink" title="查询并序列化复杂json数据"></a>查询并序列化复杂json数据</h3><p>代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serializers.py:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    name = serializers.CharField()</span><br><span class="line">    score = serializers.DictField()  <span class="comment"># 序列化复杂的json数据</span></span><br><span class="line">    <span class="comment"># DictField与EmbeddedDocumentField类似，但是比EmbeddedDocumentField更灵活</span></span><br><span class="line"><span class="comment"># views.py:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstMongo4View</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        student_info = Student3Model.objects.all()</span><br><span class="line">        <span class="comment"># 增加过滤条件</span></span><br><span class="line">        <span class="comment"># student_info = Student3Model.objects.filter(name="test1")</span></span><br><span class="line">        ser = StudentSerializer(instance=student_info, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="string">"10000"</span>, data=ser.data))</span><br></pre></td></tr></table></figure>



<h3 id="序列化mongodb中含有嵌套关系的两个document"><a href="#序列化mongodb中含有嵌套关系的两个document" class="headerlink" title="序列化mongodb中含有嵌套关系的两个document"></a>序列化mongodb中含有嵌套关系的两个document</h3><p>代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorModel</span><span class="params">(mongoengine.EmbeddedDocument)</span>:</span></span><br><span class="line">    author_name = mongoengine.StringField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = mongoengine.IntField()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookModel</span><span class="params">(mongoengine.Document)</span>:</span></span><br><span class="line">    book_name = mongoengine.StringField(max_length=<span class="number">64</span>)</span><br><span class="line">    publish = mongoengine.DateTimeField(default=datetime.datetime.utcnow())</span><br><span class="line">    words = mongoengine.IntField()</span><br><span class="line">    author = mongoengine.EmbeddedDocumentField(AuthorModel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># serializers.py: 序列化时注意与rest_framework的序列化中DictField()的区别</span></span><br><span class="line"><span class="keyword">from</span> rest_framework_mongoengine <span class="keyword">import</span> serializers <span class="keyword">as</span> s1</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorSerializer</span><span class="params">(s1.DocumentSerializer)</span>:</span>  </span><br><span class="line">    <span class="comment"># DocumentSerializer继承自drf中的ModelSerializer，用于代替ModelSerializer序列化mongodb中的document.</span></span><br><span class="line">    <span class="comment"># 具体可以到官网上查看</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = AuthorModel</span><br><span class="line">        fields = (<span class="string">'author_name'</span>, <span class="string">'age'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span><span class="params">(s1.DocumentSerializer)</span>:</span></span><br><span class="line">    author = AuthorSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = BookModel</span><br><span class="line">        fields = (<span class="string">'book_name'</span>, <span class="string">'publish'</span>, <span class="string">'words'</span>, <span class="string">'author'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># AuthorSerializer还可以这样写:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorSerializer</span><span class="params">(s1.EmbeddedDocumentSerializer)</span>:</span></span><br><span class="line">    <span class="comment"># EmbeddedDocumentSerializer继承了DocumentSerializer</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = AuthorModel</span><br><span class="line">        fields = (<span class="string">'author_name'</span>, <span class="string">'age'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># views.py:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""查询数据</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        books = BookModel.objects.all()</span><br><span class="line">        ser = BookSerializer(instance=books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="string">"10000"</span>, data=ser.data))</span><br></pre></td></tr></table></figure>

<p>需要注意的是：序列化mongodb中相关联的两个表时，如果序列化器继承自rest_framework中的Serializer和ModelSerializer，会抛出如下异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Django serialization to JSON error: &#39;MetaDict&#39; object has no attribute &#39;concrete_model&#39;</span><br></pre></td></tr></table></figure>

<p>此时，序列化器需要继承自rest_framework_mongoengine的类，具体可以查看官网：<br><a href="http://umutbozkurt.github.io/django-rest-framework-mongoengine/" target="_blank" rel="noopener">http://umutbozkurt.github.io/django-rest-framework-mongoengine/</a></p>
<p>mongodb 在 django 中的使用就介绍到这里。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发之使用celery搭建分布式任务队列</title>
    <url>/blog/2020/05/24/django%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BD%BF%E7%94%A8celery%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>今天介绍一下如何在django项目中使用celery搭建一个有两个节点的任务队列(一个主节点一个子节点；主节点发布任务，子节点收到任务并执行。搭建3个或者以上的节点就类似了)，使用到了celery,rabbitmq。这里不会单独介绍celery和rabbitmq中的知识了。</p>
<a id="more"></a>



<h1 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h1><p>两个ubuntu18.04虚拟机、python3.6.5、django2.0.4、celery3.1.26post2</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proj</span><br><span class="line"> - celery1</span><br><span class="line">	 - admin.py</span><br><span class="line">	 - apps.py</span><br><span class="line">	 - models.py</span><br><span class="line">	 - tasks.py</span><br><span class="line">	 - tests.py</span><br><span class="line">	 - urls.py</span><br><span class="line">	 - views.py</span><br><span class="line"> - proj</span><br><span class="line">	 - celery.py</span><br><span class="line">	 - settings.py</span><br><span class="line">	 - urls.py</span><br><span class="line">	 - wsgi.py</span><br><span class="line"> - manage,py</span><br></pre></td></tr></table></figure>

<h1 id="celery的配置"><a href="#celery的配置" class="headerlink" title="celery的配置"></a>celery的配置</h1><p>settings.py中关于celery的配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> djcelery</span><br><span class="line"><span class="comment"># 此处的Queue和Exchange都涉及到RabbitMQ中的概念，这里不做介绍</span></span><br><span class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Queue, Exchange</span><br><span class="line">djcelery.setup_loader()</span><br><span class="line">BROKER_URL = <span class="string">'amqp://test:test@192.168.43.6:5672/testhost'</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'amqp://test:test@192.168.43.6:5672/testhost'</span></span><br><span class="line"></span><br><span class="line">CELERY_TASK_RESULT_EXPIRES=<span class="number">3600</span></span><br><span class="line">CELERY_TASK_SERIALIZER=<span class="string">'json'</span></span><br><span class="line">CELERY_RESULT_SERIALIZER=<span class="string">'json'</span></span><br><span class="line"><span class="comment"># CELERY_ACCEPT_CONTENT = ['json', 'pickle', 'msgpack', 'yaml']</span></span><br><span class="line"></span><br><span class="line">CELERY_DEFAULT_EXCHANGE = <span class="string">'train'</span></span><br><span class="line">CELERY_DEFAULT_EXCHANGE_TYPE = <span class="string">'direct'</span></span><br><span class="line"></span><br><span class="line">CELERY_IMPORTS = (<span class="string">"proj.celery1.tasks"</span>, )</span><br><span class="line"></span><br><span class="line">CELERY_QUEUES = (</span><br><span class="line">  Queue(<span class="string">'train'</span>, routing_key=<span class="string">'train'</span>),</span><br><span class="line">  Queue(<span class="string">'predict'</span>, routing_key=<span class="string">'predict'</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>celery.py中的配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the default Django settings module for the 'celery' program.</span></span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, <span class="string">'proj.settings'</span>)</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'proj'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using a string here means the worker will not have to</span></span><br><span class="line"><span class="comment"># pickle the object when using Windows.</span></span><br><span class="line">app.config_from_object(<span class="string">'django.conf:settings'</span>)</span><br><span class="line"><span class="comment"># app.autodiscover_tasks(lambda: settings.INSTALLED_APPS)</span></span><br><span class="line">app.autodiscover_tasks(settings.INSTALLED_APPS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(bind=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug_task</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Request: &#123;0!r&#125;'</span>.format(self.request))</span><br></pre></td></tr></table></figure>

<p>proj/<strong>init</strong>.py中的配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br></pre></td></tr></table></figure>

<p>celery1/tasks.py：（主节点中的任务不会执行，只执行子节点中的任务）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_train</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<p>celery1/views.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .tasks <span class="keyword">import</span> do_train</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1View</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 这里的queue和routing_key也涉及到RabiitMQ中的知识</span></span><br><span class="line">            <span class="comment"># 关键，在这里控制向哪个queue中发送任务，子节点通过这个执行对应queue中的任务</span></span><br><span class="line">            ret = do_train.apply_async(args=[<span class="number">4</span>, <span class="number">2</span>], queue=<span class="string">"train"</span>, routing_key=<span class="string">"train"</span>)</span><br><span class="line">            <span class="comment"># 获取结果</span></span><br><span class="line">            data = ret.get()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> Response(dict(msg=str(e), code=<span class="number">10001</span>))</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="number">10000</span>, data=data))</span><br></pre></td></tr></table></figure>



<h1 id="子节点信息"><a href="#子节点信息" class="headerlink" title="子节点信息"></a>子节点信息</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">celery1</span><br><span class="line"> - celery.py</span><br><span class="line"> - config.py</span><br><span class="line"> - tasks.py</span><br></pre></td></tr></table></figure>



<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>子节点中celery1/celery.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">CELERY_IMPORTS = (<span class="string">"celery1.tasks"</span>, )</span><br><span class="line">app = Celery(<span class="string">'myapp'</span>,</span><br><span class="line">             <span class="comment"># 此处涉及到RabbitMQ的知识,RabbitMQ是主节点上的</span></span><br><span class="line">             broker=<span class="string">'amqp://test:test@192.168.43.6:5672/testhost'</span>,</span><br><span class="line">             backend=<span class="string">'amqp://test:test@192.168.43.6:5672/testhost'</span>,</span><br><span class="line">             include=[<span class="string">'celery1.tasks'</span>])</span><br><span class="line"></span><br><span class="line">app.config_from_object(<span class="string">'celery1.config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  app.start()</span><br></pre></td></tr></table></figure>

<p>子节点中celery1/config.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Queue,Exchange</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">CELERY_TASK_RESULT_EXPIRES=<span class="number">3600</span></span><br><span class="line">CELERY_TASK_SERIALIZER=<span class="string">'json'</span></span><br><span class="line">CELERY_RESULT_SERIALIZER=<span class="string">'json'</span></span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">'json'</span>,<span class="string">'pickle'</span>,<span class="string">'msgpack'</span>,<span class="string">'yaml'</span>]</span><br><span class="line"></span><br><span class="line">CELERY_DEFAULT_EXCHANGE = <span class="string">'train'</span></span><br><span class="line"><span class="comment"># exchange type可以看RabbitMQ中的相关内容</span></span><br><span class="line">CELERY_DEFAULT_EXCHANGE_TYPE = <span class="string">'direct'</span></span><br><span class="line"></span><br><span class="line">CELERT_QUEUES =  (</span><br><span class="line">  Queue(<span class="string">'train'</span>,exchange=<span class="string">'train'</span>,routing_key=<span class="string">'train'</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>子节点celery1/tasks.py：(这个是要真正执行的task，每个节点可以不同)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> celery1.celery <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_train</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    训练</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> dict(data=str(x+y),msg=<span class="string">"train"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h1><p>启动子节点：其中celery1是项目，-Q train表示从train这个queue中接收任务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">celery -A celery1 worker -l info -Q train</span><br></pre></td></tr></table></figure>

<p>启动主节点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>



<p>使用Postman请求对应的view：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">请求url：http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/api/v1/celery1/test/</span><br><span class="line">返回的结果是:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">"OK"</span>,</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">10000</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"data"</span>: <span class="string">"6"</span>,</span><br><span class="line">        <span class="string">"msg"</span>: <span class="string">"train"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h1><p>1）celery队列报错: AttributeError: ‘str’ object has no attribute ‘items’<br>解决：将redis库从3.0回退到了2.10，pip install redis==2.10<br>解决方法参考链接：<a href="https://stackoverflow.com/questions/53322425/celery-critical-mainprocess-unrecoverable-error-attributeerrorfloat-object" target="_blank" rel="noopener">https://stackoverflow.com/questions/53322425/celery-critical-mainprocess-unrecoverable-error-attributeerrorfloat-object</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发之重写objects模型管理器</title>
    <url>/blog/2020/05/24/django%E5%BC%80%E5%8F%91%E4%B9%8B%E9%87%8D%E5%86%99objects%E6%A8%A1%E5%9E%8B%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>在django中，与数据库相关的操作都封装在了objects这个对象中。objects是models.Manager的一个实例，重写Manager中的filter、all等方法可以提高开发效率，是代码看起来更加简洁。</p>
<a id="more"></a>

<p>下面是一个重写filter和all方法的例子：<br>models.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    所有模型的共有字段</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    is_delete = models.IntegerField(default=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseManager</span><span class="params">(models.Manager)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        重写all方法</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        students = super(BaseManager, self).all()</span><br><span class="line">        student = students.filter(is_delete=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> student</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        重写filter方法</span></span><br><span class="line"><span class="string">        :param args:</span></span><br><span class="line"><span class="string">        :param kwargs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> kwargs.get(<span class="string">"is_delete"</span>, <span class="number">0</span>):</span><br><span class="line">            kwargs[<span class="string">"is_delete"</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> super(BaseManager, self).filter(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentsModel</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line">    gender = models.IntegerField(default=<span class="number">1</span>)</span><br><span class="line">    objects = BaseManager()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">"test01_students"</span></span><br><span class="line">        verbose_name = <span class="string">"学生表"</span></span><br></pre></td></tr></table></figure>

<p>views.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> StudentsModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取学生信息</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        students = StudentsModel.objects.filter()</span><br><span class="line">        <span class="comment"># students = StudentsModel.objects.all()</span></span><br><span class="line">        print(<span class="string">"students:"</span>, students.query)</span><br><span class="line">        <span class="keyword">for</span> student <span class="keyword">in</span> students:</span><br><span class="line">            print(<span class="string">"student info:"</span>, (student.name, student.age))</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        新增学生信息</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        name = request.data.get(<span class="string">"name"</span>)</span><br><span class="line">        age = request.data.get(<span class="string">"age"</span>)</span><br><span class="line">        gender = request.data.get(<span class="string">"gender"</span>)</span><br><span class="line">        StudentsModel.objects.create(**&#123;<span class="string">"name"</span>: name, <span class="string">"age"</span>: age, <span class="string">"gender"</span>: gender&#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>

<p>当访问视图的get方法时，students.query打印出的结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT `test01_students`.`id`, `test01_students`.`create_time`, `test01_students`.`is_delete`, `test01_students`.`name`, `test01_students`.`age`, `test01_students`.`gender` FROM `test01_students` WHERE `test01_students`.`is_delete` = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们省去了is_delete=1。调用all()方法时也是一样的。</p>
<p>上面的models.py中，模型类StudentModel继承了BaseModel,省去了我们写公共字段的麻烦；类中的属性objects是BaseManager的实例，StudentsModel.objects.filter()就会调用BaseManager中重写filter方法。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作与分支管理</title>
    <url>/blog/2020/06/21/git%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>git 是一个版本控制系统，现在大部分项目都会使用它来管理开发的项目，下面整理了 git 的常用命令及使用方式。</p>
<a id="more"></a>

<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="git最小配置"><a href="#git最小配置" class="headerlink" title="git最小配置"></a>git最小配置</h2><p>配置 username 和 email</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#39;your name&#39;</span><br><span class="line">git config --global user.email &#39;your email&#39;</span><br></pre></td></tr></table></figure>

<p>配置 email 的目的，当版本库中的代码变更时，会记录对应开发人员的 email 等信息，当进行 code review 时，若相应变更的代码有问题，会发送邮件通知到对应的开发者。</p>
<p>config的 三个作用域：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --local  缺省配置，表示只对某个仓库有效</span><br><span class="line">git config --global 对当前用户所有仓库有效</span><br><span class="line">git config --system 对系统所有的登录用户有效</span><br></pre></td></tr></table></figure>

<p>当我们需要显示 config 的配置信息时，使用 –list 就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list --local</span><br><span class="line">git config --list --global</span><br><span class="line">git config --list --system</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git config --list --global</span><br><span class="line">user.email&#x3D;wyzane1207@163.com</span><br><span class="line">user.name&#x3D;wyzane</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git config --list</span><br><span class="line">core.symlinks&#x3D;false</span><br><span class="line">core.autocrlf&#x3D;true</span><br><span class="line">core.fscache&#x3D;true</span><br><span class="line">color.diff&#x3D;auto</span><br><span class="line">color.status&#x3D;auto</span><br><span class="line">color.branch&#x3D;auto</span><br><span class="line">color.interactive&#x3D;true</span><br><span class="line">help.format&#x3D;html</span><br><span class="line">rebase.autosquash&#x3D;true</span><br><span class="line">http.sslbackend&#x3D;openssl</span><br><span class="line">http.sslcainfo&#x3D;D:&#x2F;software&#x2F;Git&#x2F;mingw64&#x2F;ssl&#x2F;certs&#x2F;ca-bundle.crt</span><br><span class="line">credential.helper&#x3D;manager</span><br><span class="line">user.email&#x3D;wyzane1207@163.com</span><br><span class="line">user.name&#x3D;wyzane</span><br></pre></td></tr></table></figure>



<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><h3 id="把已有项目代码纳入版本管理"><a href="#把已有项目代码纳入版本管理" class="headerlink" title="把已有项目代码纳入版本管理"></a>把已有项目代码纳入版本管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 项目代码所在文件夹</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="新建一个git仓库"><a href="#新建一个git仓库" class="headerlink" title="新建一个git仓库"></a>新建一个git仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 某个文件夹</span><br><span class="line">git init 目录名</span><br><span class="line">cd 目录名</span><br></pre></td></tr></table></figure>

<p>新建一个git仓库的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git init demo1</span><br><span class="line">Initialized empty Git repository in F:&#x2F;GitTest&#x2F;demo1&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure>

<p>此时执行 git config –global –list 的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git config --global --list</span><br><span class="line">user.email&#x3D;wyzane1207@163.com</span><br><span class="line">user.name&#x3D;wyzane</span><br></pre></td></tr></table></figure>

<p>在 demo1 仓库中，执行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git config --local user.name &#39;wz&#39;</span><br><span class="line">λ git config --local user.email &#39;wyzane1207@gmail.com&#39;</span><br></pre></td></tr></table></figure>



<h2 id="添加一个文件"><a href="#添加一个文件" class="headerlink" title="添加一个文件"></a>添加一个文件</h2><p>在 dem01 目录下，新建文件 readme.md，此时执行 git status，显示如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        readme.md</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<p>此时显示，readme.md 文件是未被跟踪的文件，执行 git add readme.md，此时再执行 git status，显示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   readme.md</span><br></pre></td></tr></table></figure>

<p>然后执行 git commit -m ‘readme.md’，表示将文件提交到本地仓库中，执行完，显示结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git commit -m &#39;reaeme.md&#39;</span><br><span class="line">[master (root-commit) 28f3903] &#39;reaeme.md&#39;</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 readme.md</span><br></pre></td></tr></table></figure>

<p>此时，可以用 git log 命令查看提交记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git log</span><br><span class="line">commit 28f3903644aea0102c9e7b7a6789b5990a45db50 (HEAD -&gt; master)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Mon Jun 22 22:41:14 2020 +0800</span><br><span class="line"></span><br><span class="line">    &#39;reaeme.md&#39;</span><br></pre></td></tr></table></figure>

<p>从上面的结果中可以看出 local 配置会覆盖 global 配置。</p>
<h2 id="往仓库里添加文件"><a href="#往仓库里添加文件" class="headerlink" title="往仓库里添加文件"></a>往仓库里添加文件</h2><p>上面使用的 git add、git commit 等命令的功能如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status: 查看工作目录和暂存区的状态</span><br><span class="line">git add: 将工作目录的改动添加到暂存区</span><br><span class="line">	git add -u：将工作区中，已经被git管理的文件添加到暂存区（没有被管理的则不会添加到暂存区）</span><br><span class="line">git commit: 将暂存区的高的那个添加到本地仓库</span><br><span class="line">git log: 查看当前分支的本地 commit 的历史记录 （查看所有分支的提交记录使用 git log --all）</span><br></pre></td></tr></table></figure>

<p>git log 显示结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git log</span><br><span class="line">commit 683cbacc9aae84b55bf03a37217f09b23ec71b5a (HEAD -&gt; master)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:50:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line"></span><br><span class="line">commit 9548167eda1557775206f988e129625c8ebc664e</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line"></span><br><span class="line">    add index</span><br><span class="line"></span><br><span class="line">commit 28f3903644aea0102c9e7b7a6789b5990a45db50</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Mon Jun 22 22:41:14 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme</span><br></pre></td></tr></table></figure>



<h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件的重命名可以在工作目录中完成，然后添加到暂存区，再提交到本地仓库。这样的方式有如下问题：</span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ mv index2.html index02.html</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add&#x2F;rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    index2.html</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        index02.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">从上面的显示可以看出，在工作目录中重命名是先删除文件，再创建新文件。然后还需要执行以下命令：</span><br><span class="line">git add index02.html</span><br><span class="line">git rm index2.html  删除暂存区中的文件</span><br><span class="line">执行 git status 打印如下：</span><br><span class="line">λ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        renamed:    index2.html -&gt; index02.html</span><br></pre></td></tr></table></figure>

<p>把暂存区中所有的修改还原：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>

<p>上面的更改文件名的操作，可以使用下面的命令直接修改暂存区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git mv index.html index02.html</span><br><span class="line"></span><br><span class="line">此时再执行 git status，结果如下：</span><br><span class="line">λ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        renamed:    index2.html -&gt; index02.html</span><br><span class="line">        </span><br><span class="line">这个结果，跟上面的结果一致。</span><br></pre></td></tr></table></figure>



<h2 id="查看版本历史"><a href="#查看版本历史" class="headerlink" title="查看版本历史"></a>查看版本历史</h2><p>我们可以使用 git log 命令查看版本历史，git log 命令还有以下几种用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. git log --oneline  查看简洁的 log 信息</span><br><span class="line">febad01 (HEAD -&gt; master) 修改文件名</span><br><span class="line">683cbac update</span><br><span class="line">9548167 add index</span><br><span class="line">28f3903 add readme</span><br><span class="line"></span><br><span class="line">2. git log -n2  使用 -n 加数字的方式查看最近的几次提交 或者 git log -n2 --oneline</span><br><span class="line">commit febad01c1b094e73047b204fd31b827cb2a86ff2 (HEAD -&gt; master)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 23:02:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    修改文件名</span><br><span class="line"></span><br><span class="line">commit 683cbacc9aae84b55bf03a37217f09b23ec71b5a</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:50:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line">    </span><br><span class="line">3. git log --all --graph  使用图形化的形式展示分支的提交父子关系</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面的所有参数都可以组合使用，还可以使用 git help --web log 查看更多 git log 参数。</span><br></pre></td></tr></table></figure>

<p>使用 gitk 命令可以打开图形界面，查看项目的版本历史。</p>
<h2 id="git目录介绍"><a href="#git目录介绍" class="headerlink" title=".git目录介绍"></a>.git目录介绍</h2><p>执行 git init 后，会生成一个 ,git 文件夹，文件夹内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 dell 197121  16 6月  23 23:02 COMMIT_EDITMSG</span><br><span class="line">-rw-r--r-- 1 dell 197121 180 6月  22 22:29 config</span><br><span class="line">-rw-r--r-- 1 dell 197121  73 6月  22 22:24 description</span><br><span class="line">-rw-r--r-- 1 dell 197121 216 6月  25 14:55 gitk.cache</span><br><span class="line">-rw-r--r-- 1 dell 197121  21 6月  24 23:07 HEAD</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  22 22:24 hooks&#x2F;</span><br><span class="line">-rw-r--r-- 1 dell 197121 217 6月  24 23:08 index</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  22 22:24 info&#x2F;</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  22 22:41 logs&#x2F;</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  23 23:02 objects&#x2F;</span><br><span class="line">-rw-r--r-- 1 dell 197121  41 6月  23 22:59 ORIG_HEAD</span><br><span class="line">drwxr-xr-x 1 dell 197121   0 6月  22 22:24 refs&#x2F;</span><br></pre></td></tr></table></figure>

<p>每个文件的含义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD: 文件，保存了当前正在工作的分支，切换分支时内容会改变，内容为：ref: refs&#x2F;heads&#x2F;master</span><br><span class="line">config: 文件，保存了与本地仓库相关的配置信息，内容如下：</span><br><span class="line">	[core]</span><br><span class="line">        repositoryformatversion &#x3D; 0</span><br><span class="line">        filemode &#x3D; false</span><br><span class="line">        bare &#x3D; false</span><br><span class="line">        logallrefupdates &#x3D; true</span><br><span class="line">        symlinks &#x3D; false</span><br><span class="line">        ignorecase &#x3D; true</span><br><span class="line">	[user]</span><br><span class="line">        name &#x3D; &#39;wz&#39;</span><br><span class="line">        email &#x3D; &#39;wyzane1207@163.com&#39;</span><br><span class="line">refs: 目录，包含 heads(保存分支) 和 tags(保存标签)</span><br><span class="line">	refs&#x2F;heads&#x2F;master 中保存的是一个 commit 的 id，指向一个 commit</span><br><span class="line">objects: 目录，保存了 tree、glob 等对象的信息</span><br></pre></td></tr></table></figure>



<h2 id="git对象之间的关系"><a href="#git对象之间的关系" class="headerlink" title="git对象之间的关系"></a>git对象之间的关系</h2><p>commit、tree、blob三者之间的关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个commit对应一个tree，这个tree表示当时commit后，项目的整个目录结构，这个tree下面有可以包含多个子tree(目录)和blob(文件)。</span><br><span class="line">子tree会对应项目中的一个目录，子tree中也包含很多blob和子tree。</span><br><span class="line">一个blob对应一个文件，只要文件内容相同，就是同一个blob对象。</span><br></pre></td></tr></table></figure>

<p>执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git cat-file -p f9c5d761a  查看f9c5d761a的内容</span><br><span class="line">tree b4f5e1498a011eb1267852ff76ccbad35c08aac4</span><br><span class="line">parent febad01c1b094e73047b204fd31b827cb2a86ff2</span><br><span class="line">author wyzane &lt;wyzane1207@163.com&gt; 1593072058 +0800</span><br><span class="line">committer wyzane &lt;wyzane1207@163.com&gt; 1593072058 +0800</span><br><span class="line"></span><br><span class="line">添加用户页面</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git cat-file -t f9c5d761a  查看f9c5d761a的类型</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git cat-file -p b4f5e1498a011   查看f9c5d761a下tree对象b4f5e1498a011的内容</span><br><span class="line">100644 blob fd98613334e79fb5a12f537462627af2b7efdacd    index.html</span><br><span class="line">100644 blob 9b562d265a03e923b86bfc3b9b8418463f4f1c70    index02.html</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    readme.md</span><br><span class="line">040000 tree fa6ab77bfb3a6f0cbecd74ef7e98e8624ee4c099    test</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git cat-file -t b4f5e1498a011  查看b4f5e1498a011的类型</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">F:\GitTest\demo1 (master -&gt; origin)</span><br><span class="line">λ git cat-file -p fa6ab77bfb3</span><br><span class="line">100644 blob 41d4171c5880f9cdab07eadc8564d04e7ee1e055    user.html</span><br><span class="line"></span><br><span class="line">从上面的打印信息中可以看出，一个commit对应一个tree，这个tree下面可以有blob对象和子tree对象，子tree下面还有blob对象。</span><br><span class="line"></span><br><span class="line">执行 git cat-file -p fd98613334e79fb，显示出 blob 对象的内容如下：</span><br><span class="line">&lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br><span class="line">&lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br><span class="line">&lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分离头指针是指，做的变更不是基于一个分支。</span><br><span class="line">HEAD 可以指向一个分支（最终还是指向一个commit），也可以指向一个commit，当使用 git checkout commitID 时，HEAD会切换到一个特定的commit。此时我们做的任何变更不是基于分支的，而是基于这个commit，当切换回其他分支时，在commit上做的变更就会被git丢弃掉。</span><br><span class="line">当我们需要做一些实验性的变更时，可以这样做。</span><br></pre></td></tr></table></figure>

<p>正常情况下，HEAD会指向一个分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git log</span><br><span class="line">commit f9c5d761a8922dd69345da752ab135881418bc51 (HEAD -&gt; master)</span><br><span class="line">Author: wyzane &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Thu Jun 25 16:00:58 2020 +0800</span><br><span class="line"></span><br><span class="line">    添加用户页面</span><br><span class="line"></span><br><span class="line">commit febad01c1b094e73047b204fd31b827cb2a86ff2</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 23:02:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    修改文件名</span><br><span class="line"></span><br><span class="line">commit 683cbacc9aae84b55bf03a37217f09b23ec71b5a</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:50:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line"></span><br><span class="line">commit 9548167eda1557775206f988e129625c8ebc664e (temp)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line"></span><br><span class="line">    add index</span><br></pre></td></tr></table></figure>

<p>我们执行 git checkout 9548 febad01c1b 后，HEAD会指向一个 commit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git checkout febad01c1b</span><br><span class="line">Note: checking out &#39;febad01c1b&#39;.</span><br><span class="line"></span><br><span class="line">You are in &#39;detached HEAD&#39; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at febad01 修改文件名</span><br><span class="line"></span><br><span class="line">λ git log</span><br><span class="line">commit febad01c1b094e73047b204fd31b827cb2a86ff2 (HEAD)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 23:02:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    修改文件名</span><br><span class="line"></span><br><span class="line">commit 683cbacc9aae84b55bf03a37217f09b23ec71b5a</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:50:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line"></span><br><span class="line">commit 9548167eda1557775206f988e129625c8ebc664e (temp)</span><br><span class="line">Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">Date:   Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line"></span><br><span class="line">    add index</span><br></pre></td></tr></table></figure>

<h2 id="修改commit的msg"><a href="#修改commit的msg" class="headerlink" title="修改commit的msg"></a>修改commit的msg</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改最近一次 commit 的 msg 使用如下命令：</span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">如何修改其他 commit 的 msg</span><br></pre></td></tr></table></figure>

<h2 id="修改其他-commit-的-msg"><a href="#修改其他-commit-的-msg" class="headerlink" title="修改其他 commit 的 msg"></a>修改其他 commit 的 msg</h2><p>对其他 commit 的 msg 修改时，需要用到 git rebase 命令。<br>首先我们要确定待修改commit的上一个commitID，以这个commit为基础。然后执行 git rebase -i 上一个commitID，会进入一个编辑页面，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick f5b4cb5 修改文件名</span><br><span class="line">pick a0b86da 添加用户页面2</span><br><span class="line"></span><br><span class="line"># Rebase 683cbac..a0b86da onto 683cbac (2 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; &#x3D; use commit</span><br><span class="line"># r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message</span><br><span class="line"># x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell</span><br><span class="line"># b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;)</span><br><span class="line"># d, drop &lt;commit&gt; &#x3D; remove commit</span><br><span class="line"># l, label &lt;label&gt; &#x3D; label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; &#x3D; reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#39;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure>

<p>上面的文件中，挑选出了两个 commit，然后下面有选择执行的命令。修改 commit 时，我们可以选择 commit message 命令，即把第一行的 pick 改成 reword，然后保存。保存后又会进入一个编辑页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改文件名</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Author:    wz &lt;wyzane1207@163.com&gt;</span><br><span class="line"># Date:      Tue Jun 23 23:02:37 2020 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto 683cbac</span><br><span class="line"># Last command done (1 command done):</span><br><span class="line">#    reword f5b4cb5 修改文件名2</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick a0b86da 添加用户页面2</span><br><span class="line"># You are currently editing a commit while rebasing branch &#39;master&#39; on &#39;683cbac&#39;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       renamed:    index2.html -&gt; index02.html</span><br></pre></td></tr></table></figure>

<p>这时我们修改完 msg 后保存即可。</p>
<h2 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h2><p>对其他 commit 的 msg 修改时，需要用到 git rebase 命令。<br>首先我们要确定待修改commit的上一个commitID，以这个commit为基础。然后执行 git rebase -i 上一个commitID，会进入一个编辑页面，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick 9548167 add index</span><br><span class="line">pick 683cbac update</span><br><span class="line">pick 4a558f9 修改文件名2</span><br><span class="line">pick 8d1455b 添加用户页面2</span><br><span class="line"></span><br><span class="line"># Rebase 28f3903..8d1455b onto 28f3903 (4 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; &#x3D; use commit</span><br><span class="line"># r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message</span><br><span class="line"># x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell</span><br><span class="line"># b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;)</span><br><span class="line"># d, drop &lt;commit&gt; &#x3D; remove commit</span><br><span class="line"># l, label &lt;label&gt; &#x3D; label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; &#x3D; reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#39;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure>

<p>我们可以把 683cbac、4a558f9 这两个 commit 合并到第一个 commit 中。根据文件中的说明，我们可以使用 squash（或者简写成s） 命令。修改文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick 9548167 add index</span><br><span class="line">squash 683cbac update</span><br><span class="line">squash 4a558f9 修改文件名2</span><br><span class="line">pick 8d1455b 添加用户页面2</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后保存，会出现如下文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"># This is the 1st commit message:</span><br><span class="line"></span><br><span class="line">add index</span><br><span class="line"></span><br><span class="line"># This is the commit message #2:</span><br><span class="line"></span><br><span class="line">update</span><br><span class="line"></span><br><span class="line"># This is the commit message #3:</span><br><span class="line"></span><br><span class="line">修改文件名2</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Author:    wz &lt;wyzane1207@163.com&gt;</span><br><span class="line"># Date:      Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto 28f3903</span><br><span class="line"># Last commands done (3 commands done):</span><br><span class="line">#    squash 683cbac update</span><br><span class="line">#    squash 4a558f9 修改文件名2</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick 8d1455b 添加用户页面2</span><br><span class="line"># You are currently rebasing branch &#39;master&#39; on &#39;28f3903&#39;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.html</span><br><span class="line">#       new file:   index02.html</span><br></pre></td></tr></table></figure>

<p>我们可以在第一行下面写合并 commit 的注释，写完保存即可。执行 git log –graph，可以看到下面的 commit 记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">λ git log --graph</span><br><span class="line">* commit 04c862efc7b757b2038144ab24b2dc913151213c (HEAD -&gt; master)</span><br><span class="line">| Author: wyzane &lt;wyzane1207@163.com&gt;</span><br><span class="line">| Date:   Thu Jun 25 16:00:58 2020 +0800</span><br><span class="line">|</span><br><span class="line">|     添加用户页面2</span><br><span class="line">|</span><br><span class="line">* commit 2343bc35bef0f096b3768403fbceeb587e8ddfcf</span><br><span class="line">| Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">| Date:   Tue Jun 23 22:41:51 2020 +0800</span><br><span class="line">|</span><br><span class="line">|     合并commit测试</span><br><span class="line">|</span><br><span class="line">|     add index</span><br><span class="line">|</span><br><span class="line">|     update</span><br><span class="line">|</span><br><span class="line">|     修改文件名2</span><br><span class="line">|</span><br><span class="line">* commit 28f3903644aea0102c9e7b7a6789b5990a45db50</span><br><span class="line">  Author: wz &lt;wyzane1207@163.com&gt;</span><br><span class="line">  Date:   Mon Jun 22 22:41:14 2020 +0800</span><br><span class="line"></span><br><span class="line">      reaeme.md</span><br></pre></td></tr></table></figure>

<p>可以看到， 2343bc35bef0f096b3768403fbceeb587e8ddfcf 这个就是新生成的commit。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="git-check"><a href="#git-check" class="headerlink" title="git check"></a>git check</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 分支名: 切换到分支</span><br><span class="line">git checkout -b 分支名: 创建新分支并切换到新分支</span><br><span class="line">git checkout -b 新分支名 基于分支名或者commitID: 基于某个分支或者commit创建一个分支并切换到该分支</span><br></pre></td></tr></table></figure>

<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch: 查看分支列表</span><br><span class="line">git branch -d 分支名: 删除某个分支 </span><br><span class="line">git branch -D 分支名: 强制删除某个分支</span><br></pre></td></tr></table></figure>

<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff 用户比较两个 commit 的区别</span><br><span class="line">git diff commitID1 commitID2: 比较两个commit</span><br><span class="line">git diff HEAD HEAD~1: 比较当前commit与上一次commit的区别</span><br><span class="line">	git diff HEAD HEAD^^ 与 git diff HEAD HEAD~2 一样</span><br></pre></td></tr></table></figure>

<h2 id="git-cat-file"><a href="#git-cat-file" class="headerlink" title="git cat-file"></a>git cat-file</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cat-file -t 9b562d265a03e923b86bfc3b9b8418463f4f1c70: 查看hash值的类型（这个是blob类型，即文件对象）</span><br><span class="line">git cat-file -p 9b562d265a03e923b86bfc3b9b8418463f4f1c70: 查看hash值的内容</span><br><span class="line">	这个 blog 类型的内容如下：</span><br><span class="line">		&lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br><span class="line">        &lt;h1&gt;git test&lt;h1&#x2F;&gt;</span><br><span class="line">git cat-file -t 239ec593c6a2192e76c005435f748b2ad28be832：查看hash值的类型（这个是tree类型，即目录）</span><br><span class="line">git cat-file -p 239ec593c6a2192e76c005435f748b2ad28be832: 查看输出内容，输出如下（内容是一个blob对象）：</span><br><span class="line">		100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    readme.md</span><br></pre></td></tr></table></figure>



<p>整理中 …..</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>django开发之在docker中部署项目</title>
    <url>/blog/2020/07/26/django%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9C%A8docker%E4%B8%AD%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>今天整理了一下如何在docker中部署django项目。</p>
<a id="more"></a>

<h1 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3.6 django2.0.5 nginx mysql5.7 gunicorn</span><br></pre></td></tr></table></figure>

<h1 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h1><p>项目主目录为 blog 目录，需要编写的文件包括（省去了其他django文件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blog&#x2F;Dockerfile, blog&#x2F;gunicorn.conf, blog&#x2F;start.sh, nginx&#x2F;Doickerfile, nginx&#x2F;nginx.conf, docker-conpose.yml</span><br></pre></td></tr></table></figure>

<h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><h2 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h2><p>blog/Dockerfile 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM python:3.6    # 选择基础镜像,这里的基础镜像也可以选择ubuntu,centos等，但是下面的配置就会发生变化</span><br><span class="line"></span><br><span class="line"># 创建工作目录</span><br><span class="line">RUN mkdir &#x2F;blog  </span><br><span class="line"></span><br><span class="line">#设置工作目录</span><br><span class="line">WORKDIR &#x2F;blog</span><br><span class="line"></span><br><span class="line">#将当前目录加入到工作目录中</span><br><span class="line">ADD . &#x2F;blog</span><br><span class="line">RUN pip3 install -r requirements.txt</span><br><span class="line">#对外暴露端口</span><br><span class="line">EXPOSE 80 8080 8000 5000</span><br><span class="line">#设置环境变量</span><br><span class="line">ENV SPIDER&#x3D;&#x2F;blog</span><br></pre></td></tr></table></figure>

<p>上面基础镜像使用的是python:3.6,而不是ubuntu、centos。如果是ubuntu、cenos，Dockerfile文件中需要配置python环境</p>
<p>nginx/Doickerfile 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx    # nginx镜像，最好是先拉取到本地</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对外暴露端口</span><br><span class="line">EXPOSE 80 8000</span><br><span class="line"></span><br><span class="line">RUN rm &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf  # 删除原有配置文件</span><br><span class="line">ADD nginx.conf  &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;   # 添加配置文件</span><br><span class="line">RUN mkdir -p &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static  # 创建静态资源文件夹</span><br></pre></td></tr></table></figure>

<p>docker-compose.yml 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">    image: mysql:5.7  # mysql镜像，最好先拉取到本地</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_HOST&#x3D;localhost</span><br><span class="line">      - MYSQL_DATABASE&#x3D;docker</span><br><span class="line">      - MYSQL_USER&#x3D;root</span><br><span class="line">      - MYSQL_PASSWORD&#x3D;wyzane</span><br><span class="line">      - MYSQL_ROOT_PASSWORD&#x3D;wyzane</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;home&#x2F;wyzane&#x2F;pyprojects&#x2F;db:&#x2F;var&#x2F;lib&#x2F;mysql  # 将宿主机与容器中的文件映射</span><br><span class="line">    restart: always  # 若容器运行出现问题，会自动重启容器</span><br><span class="line"></span><br><span class="line">  web:</span><br><span class="line">    build: .&#x2F;blog</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;8000:8000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;blog:&#x2F;blog</span><br><span class="line">    - &#x2F;tmp&#x2F;logs:&#x2F;tmp</span><br><span class="line">    command: bash start.sh  # 执行命令，有多种格式</span><br><span class="line">    links:</span><br><span class="line">    - db</span><br><span class="line">    depends_on:</span><br><span class="line">    - db</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">nginx:</span><br><span class="line">    build: .&#x2F;nginx</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;blog&#x2F;static:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static:ro</span><br><span class="line">    links:</span><br><span class="line">    - web</span><br><span class="line">    depends_on:</span><br><span class="line">    - web</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>



<h2 id="gunicorn配置"><a href="#gunicorn配置" class="headerlink" title="gunicorn配置"></a>gunicorn配置</h2><p>blog/gunicorn.conf 的配置内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workers&#x3D;2</span><br><span class="line">bind&#x3D;&#39;0.0.0.0:8000&#39;</span><br><span class="line">proc_name&#x3D;&#39;blog&#39;</span><br></pre></td></tr></table></figure>

<h2 id="start文件配置"><a href="#start文件配置" class="headerlink" title="start文件配置"></a>start文件配置</h2><p>blog/start.sh 文件内容如下，用于启动项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">python manage.py collectstatic --noinput&amp;&amp;</span><br><span class="line">python manage.py makemigrations&amp;&amp;</span><br><span class="line">python manage.py migrate &amp;&amp;</span><br><span class="line">gunicornblog.wsgi:application -c gunicorn.conf</span><br></pre></td></tr></table></figure>

<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>nginx/nginx.conf 文件配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location &#x2F;static &#123;</span><br><span class="line">        alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;web:8000;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h1><p>配置完成后，依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>执行完成后，通过 docker images 命令可以查看新增了2个镜像，docker ps 命令可以查看启动了3个容器。</p>
<p>多执行几次docker ps，当容器的STATUS是以Restarting开头时，表示这个容器运行时发生了错误。执行docker logs CONTAINERID可以查看容器出错的具体原因。</p>
<p>若上述容器都成功运行，则在浏览器中输入<a href="http://127.0.0.1:80/api/v1/articles/info/时（这是django中的一个视图，在这里没有写出来，不同的小伙伴可以替换成不同的接口），视图会返回相应的结果。" target="_blank" rel="noopener">http://127.0.0.1:80/api/v1/articles/info/时（这是django中的一个视图，在这里没有写出来，不同的小伙伴可以替换成不同的接口），视图会返回相应的结果。</a><br>以交互方式进入容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it CONTAINERID &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>后，进入mysql数据库，会看到在数据库中生成了相应的表。</p>
<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>在运行3个容器后，web容器一直报错，通过 docker logs CONTAINERID查看主要错误信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django.db.utils.OperationalError: (2003, &#39;Can\&#39;t connect to MySQL server on \&#39;mariadb55\&#39; (111 &quot;Connection refused&quot;)&#39;)</span><br></pre></td></tr></table></figure>

<p>解决方案在这里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;47979270&#x2F;django-cannot-connect-mysql-in-docker-compose</span><br></pre></td></tr></table></figure>

<p>主要是在settings.py中，将database配置中的HOST值改成db,而不是127.0.0.1，指向docker-compose.yml中的db服务。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django, docker</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2中cookie和session的使用</title>
    <url>/blog/2020/06/07/koa2%E4%B8%ADcookie%E5%92%8Csession%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>cookie 和 session 都是保存用户状态的机制，今天介绍下它们在 koa 中的使用。</p>
<a id="more"></a>

<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="cookie的使用"><a href="#cookie的使用" class="headerlink" title="cookie的使用"></a>cookie的使用</h2><p>cookie可以记录用户的状态信息，在koa2中设置 cookie 的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.cookies.set(key, value, [options])</span><br></pre></td></tr></table></figure>

<p>其中 options 中的常用参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxAge: cookie过期时间</span><br><span class="line">expires：cookie的过期日期</span><br><span class="line">path: cookie路径，默认是 &#x2F;</span><br><span class="line">domain: cookie的域名</span><br><span class="line">secure: 安全 cookie ，默认为 false,设置成true时表示只有https可以访问</span><br><span class="line">httpOnly： true-表示只有服务器端可以访问，默认true(不能在浏览器中使用js访问)</span><br><span class="line">overwrite: 是否覆盖之前设置的同名 cookie，默认false</span><br></pre></td></tr></table></figure>



<p>获取cookie中的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.cookies.get(key)</span><br></pre></td></tr></table></figure>



<p>demo.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    ctx.cookies.set(</span><br><span class="line">        <span class="string">'userinfo'</span>, <span class="string">'hello cookies'</span>, &#123;</span><br><span class="line">            domain: <span class="string">'127.0.0.1'</span>,  <span class="comment">// 设置访问域名</span></span><br><span class="line">            path: <span class="string">'/get'</span>,   <span class="comment">// 设置允许访问cookie的路由，其他路由则不能访问</span></span><br><span class="line">            maxAge: <span class="number">60</span> * <span class="number">60</span>  * <span class="number">100</span>,  <span class="comment">// 设置超时时间</span></span><br><span class="line">            expires: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-07-04'</span>), </span><br><span class="line">            httpOnly: <span class="literal">false</span>,  <span class="comment">// 是否仅仅允许htpp请求</span></span><br><span class="line">            overwrite: <span class="literal">false</span>,  <span class="comment">// 是否允许重写</span></span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    ctx.body = <span class="string">'cookies is ok'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.get(<span class="string">'/get'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> userinfo = ctx.cookies.get(<span class="string">'userinfo'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(userinfo);</span><br><span class="line">    ctx.body = userinfo;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8095</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当使用下面的url访问服务时，会分别设置cookie和获取cookie：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8095&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1:8095&#x2F;get</span><br></pre></td></tr></table></figure>

<p>设置 cookie 后，可以在浏览器的 Application 里面看到信息。</p>
<h2 id="cookie中设置中文"><a href="#cookie中设置中文" class="headerlink" title="cookie中设置中文"></a>cookie中设置中文</h2><p>使用 ctx.cookies.set() 设置中文cookie值时，会抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError: argument value is invalid</span><br></pre></td></tr></table></figure>

<p>此时，可以先将中文转换成 base64 编码，再把编码后的中文设置到 cookie 中即可，取 cookie 数据的时候需要解码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> userinfo = <span class="keyword">new</span> Buffer(<span class="string">'中文cookie来啦'</span>).toString(<span class="string">'base64'</span>);</span><br><span class="line">    ctx.cookies.set(</span><br><span class="line">        <span class="string">'userinfo'</span>, userinfo, &#123;</span><br><span class="line">            domain: <span class="string">'127.0.0.1'</span>,  <span class="comment">// 设置域名</span></span><br><span class="line">            path: <span class="string">'/get'</span>,   <span class="comment">// 设置访问路径</span></span><br><span class="line">            maxAge: <span class="number">60</span> * <span class="number">60</span>  * <span class="number">100</span>,  <span class="comment">// 设置超时时间</span></span><br><span class="line">            expires: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-07-04'</span>), </span><br><span class="line">            httpOnly: <span class="literal">false</span>,  <span class="comment">// 是否仅仅允许htpp请求</span></span><br><span class="line">            overwrite: <span class="literal">false</span>,  <span class="comment">// 是否允许重写</span></span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    ctx.body = <span class="string">'cookies is ok'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.get(<span class="string">'/get'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> userinfo = ctx.cookies.get(<span class="string">'userinfo'</span>);</span><br><span class="line">    <span class="keyword">let</span> info = <span class="keyword">new</span> Buffer(userinfo, <span class="string">'base64'</span>).toString();</span><br><span class="line">    <span class="built_in">console</span>.log(info);</span><br><span class="line">    ctx.body = info;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8095</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>session是保存在服务端的一种记录用户状态信息的机制（cookie保存在客户端）。下面看一下它在 koa 中的使用。</p>
<h2 id="session的使用"><a href="#session的使用" class="headerlink" title="session的使用"></a>session的使用</h2><p>koa 中使用 session 需要安装 koa-session 模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save koa-session</span><br></pre></td></tr></table></figure>

<p>使用例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Session = <span class="built_in">require</span>(<span class="string">'koa-session'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 session 中间件</span></span><br><span class="line">app.keys = [<span class="string">'some secret hurr'</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> CONFIG = &#123;</span><br><span class="line">  key: <span class="string">'koa.sess'</span>, <span class="comment">// 对应的cookie名称</span></span><br><span class="line">  maxAge: <span class="number">86400000</span>,  <span class="comment">// session过期时间(单位:ms)</span></span><br><span class="line">  autoCommit: <span class="literal">true</span>, <span class="comment">// 自动提交headers，默认true</span></span><br><span class="line">  overwrite: <span class="literal">true</span>, <span class="comment">// 覆盖之前key同名的session值，默认true</span></span><br><span class="line">  httpOnly: <span class="literal">true</span>, <span class="comment">// true-表示只有服务器端可以访问，默认true(不能在浏览器中使用js访问)</span></span><br><span class="line">  signed: <span class="literal">true</span>, <span class="comment">// 是否使用签名，默认true</span></span><br><span class="line">  rolling: <span class="literal">false</span>, <span class="comment">// 每次访问都重设过期时间 maxAge，默认false</span></span><br><span class="line">  renew: <span class="literal">true</span> <span class="comment">// 当session快过期时自动更新</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 设置 session</span></span><br><span class="line">    ctx.session.name = <span class="string">'koa session'</span></span><br><span class="line">    ctx.body = <span class="string">'session is ok'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.get(<span class="string">'/get'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 获取 session</span></span><br><span class="line">    <span class="keyword">let</span> name = ctx.session.name;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    ctx.body = name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(Session(CONFIG, app));</span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8095</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>cookie 与 session 的使用就介绍到这里，感兴趣的小伙伴可以深入研究一下。</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>ice配合tornado搭建http服务</title>
    <url>/blog/2020/07/19/ice%E9%85%8D%E5%90%88tornado%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>tornado 是 python 中的一个 http 框架，以异步高性能著称，zeroc-ice 是一个分布式的 rpc 框架，将两者结合使用，可以搭建高性能的 web 应用服务。</p>
<p>下面写了一个小 demo，演示了如何在 tornado 中使用 ice。</p>
<a id="more"></a>

<h2 id="demo结构"><a href="#demo结构" class="headerlink" title="demo结构"></a>demo结构</h2><p>demo 的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.py</span><br><span class="line">├── handlers.py</span><br><span class="line">├── Test</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── Test.ice</span><br><span class="line">├── Test_ice.py</span><br><span class="line">└── user</span><br><span class="line">    ├── client.ini</span><br><span class="line">    ├── client.py</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── server.ini</span><br><span class="line">    └── server.py</span><br></pre></td></tr></table></figure>

<p>其中，Test.ice 是 slice 文件，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module Test</span><br><span class="line">&#123;</span><br><span class="line">    dictionary&lt;string, string&gt; Params;</span><br><span class="line"></span><br><span class="line">    interface User</span><br><span class="line">    &#123;</span><br><span class="line">        void printStr(string s);</span><br><span class="line"></span><br><span class="line">        int addMun(int num1, int num2);</span><br><span class="line"></span><br><span class="line">        string invoke(string fid, string params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行 slice2py 后，生成了 Test 目录和 Test_ics.py 文件。</p>
<p>handlers.py 和 app.py 是 tornado 文件，内容分别如下：</p>
<p>handlers.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 13:48 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">from user.client import IceCommunicator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserHandler(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    def post(self, url):</span><br><span class="line">        print(&quot;url:&quot;, url)</span><br><span class="line">        # print(&quot;params:&quot;, self.request.body.decode(&quot;utf-8&quot;))</span><br><span class="line">        print(&quot;params:&quot;, self.request.arguments)</span><br><span class="line"></span><br><span class="line">        path &#x3D; &quot;user&#x2F;&quot; + url</span><br><span class="line">        params &#x3D; self.request.arguments</span><br><span class="line">        params &#x3D; &#123;k: params.get(k)[0].decode(&quot;utf-8&quot;) for k in params.keys()&#125;</span><br><span class="line"></span><br><span class="line">        resp &#x3D; self.invoke(path, params)</span><br><span class="line">        self.write(resp)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line">    def invoke(self, path, params):</span><br><span class="line">        communicator &#x3D; IceCommunicator()</span><br><span class="line">        user &#x3D; communicator.init()</span><br><span class="line">        params &#x3D; json.dumps(params)</span><br><span class="line">        resp &#x3D; user.invoke(path, params)</span><br><span class="line">        return resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GoodsHandler(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    def post(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<p>app.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 13:46 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import tornado.web</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.options</span><br><span class="line">import tornado.httpserver</span><br><span class="line">from tornado.options import define, options</span><br><span class="line"></span><br><span class="line">from handlers import UserHandler, GoodsHandler</span><br><span class="line"></span><br><span class="line">define(&quot;port&quot;, default&#x3D;8000, help&#x3D;&quot;run on the given port&quot;, type&#x3D;int)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    handlers &#x3D; [</span><br><span class="line">        (r&quot;&#x2F;user&#x2F;(.*)&quot;, UserHandler),</span><br><span class="line">        (r&quot;&#x2F;goods&#x2F;(.*)&quot;, GoodsHandler)</span><br><span class="line">    ]</span><br><span class="line">    app &#x3D; tornado.web.Application(handlers&#x3D;handlers)</span><br><span class="line">    http_server &#x3D; tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>user目录下是 ice 相关的文件和配置，内容分别如下：</p>
<p>server.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 10:00 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import Ice</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">Ice.loadSlice(&quot;..&#x2F;Test.ice&quot;)</span><br><span class="line">import Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_resp(status&#x3D;None, msg&#x3D;None, data&#x3D;None):</span><br><span class="line">    &quot;&quot;&quot;获取响应信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    resp &#x3D; dict()</span><br><span class="line">    resp[&quot;status&quot;] &#x3D; status if status else &#39;10000&#39;</span><br><span class="line">    resp[&quot;msg&quot;] &#x3D; msg if msg else &#39;ok&#39;</span><br><span class="line">    resp[&quot;data&quot;] &#x3D; data if data else &#123;&#125;</span><br><span class="line">    return resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserI(Test.User):</span><br><span class="line"></span><br><span class="line">    def printStr(self, s, current&#x3D;None):</span><br><span class="line">        print(&quot;hello ice&quot;)</span><br><span class="line"></span><br><span class="line">    def addMun(self, n1, n2, current&#x3D;None):</span><br><span class="line">        ret &#x3D; n1 + n2</span><br><span class="line">        print(&quot;addMun result is:&quot;, ret)</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    def invoke(self, path, params, current&#x3D;None):</span><br><span class="line">        &quot;&quot;&quot;调用具体业务逻辑</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        user &#x3D; ViewUser()</span><br><span class="line"></span><br><span class="line">        params &#x3D; json.loads(params)</span><br><span class="line"></span><br><span class="line">        map &#x3D; &#123;</span><br><span class="line">            &quot;user&#x2F;list&quot;: user.list,</span><br><span class="line">            &quot;user&#x2F;detail&quot;: user.detail,</span><br><span class="line">            &quot;user&#x2F;add&quot;: user.add</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resp &#x3D; map.get(path, user.others)(params)</span><br><span class="line">        return resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ViewUser():</span><br><span class="line"></span><br><span class="line">    def list(self, params):</span><br><span class="line">        resp &#x3D; get_resp(data&#x3D;&#123;&quot;url&quot;: &quot;user&#x2F;list&quot;&#125;)</span><br><span class="line">        print(&quot;user list:&quot;, params)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line">    def detail(self, params):</span><br><span class="line">        resp &#x3D; get_resp(data&#x3D;&#123;&quot;url&quot;: &quot;user&#x2F;detail&quot;&#125;)</span><br><span class="line">        print(&quot;user detail:&quot;, params)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line">    def add(self, params):</span><br><span class="line">        resp &#x3D; get_resp(data&#x3D;&#123;&quot;url&quot;: &quot;user&#x2F;add&quot;&#125;)</span><br><span class="line">        print(&quot;user add:&quot;, params)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line">    def others(self, params):</span><br><span class="line">        resp &#x3D; get_resp(&#39;10001&#39;, &#39;not found&#39;)</span><br><span class="line">        return json.dumps(resp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with Ice.initialize(sys.argv, &quot;server.ini&quot;) as communicator:</span><br><span class="line">    adapter &#x3D; communicator.createObjectAdapter(&quot;User&quot;)</span><br><span class="line">    adapter.add(UserI(), Ice.stringToIdentity(&quot;user&quot;))</span><br><span class="line">    adapter.activate()</span><br><span class="line">    communicator.waitForShutdown()</span><br></pre></td></tr></table></figure>

<p>client.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># @Author : WZ </span><br><span class="line"># @Time : 2020&#x2F;7&#x2F;19 10:00 </span><br><span class="line"># @Intro :</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import Ice</span><br><span class="line"></span><br><span class="line">Ice.loadSlice(&quot;Test.ice&quot;)</span><br><span class="line">import Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IceCommunicator:</span><br><span class="line"></span><br><span class="line">    def init(self):</span><br><span class="line">        communicator &#x3D; Ice.initialize(sys.argv, &#39;user&#x2F;client.ini&#39;)</span><br><span class="line">        user &#x3D; Test.UserPrx.checkedCast(communicator.propertyToProxy(&#39;User.Proxy&#39;)</span><br><span class="line">                                        .ice_twoway()</span><br><span class="line">                                        .ice_secure(False))</span><br><span class="line">        if not user:</span><br><span class="line">            print(&quot;invalid proxy&quot;)</span><br><span class="line">            sys.exit(1)</span><br><span class="line"></span><br><span class="line">        return user</span><br></pre></td></tr></table></figure>

<p>server.ini：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User.Endpoints&#x3D;tcp -p 10000</span><br><span class="line">Ice.Default.Host&#x3D;localhost</span><br><span class="line">Ice.Warn.Connections&#x3D;1</span><br></pre></td></tr></table></figure>

<p>client.ini：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User.Proxy&#x3D;user:tcp -p 10000</span><br><span class="line">Ice.Default.Host&#x3D;localhost</span><br><span class="line">Ice.Warn.Connections&#x3D;1</span><br></pre></td></tr></table></figure>



<h2 id="demo执行流程"><a href="#demo执行流程" class="headerlink" title="demo执行流程"></a>demo执行流程</h2><p>执行流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. app.py 中接受 http 请求，并将请求转发到对应的 handler</span><br><span class="line">2. 在 hendler 中调用 ice 客户端向 ice 服务端发送请求，请求 ice 服务端时会传入请求 path 和参数</span><br><span class="line">3. ice 服务端根据不同的请求 path 执行不同的操作，并返回响应结果</span><br></pre></td></tr></table></figure>



<p>上面仅仅是一个小的 demo，后面还会更近一步研究两者的结合使用。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>tornado</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2中模板引擎与静态资源的使用</title>
    <url>/blog/2020/05/31/koa2%E4%B8%AD%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%B8%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>今天介绍下 koa2 中模板引擎与静态资源的使用。</p>
<a id="more"></a>

<h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h1><p>适用于 koa2 的模板引擎有很多，比如ejs，ant-template，jade，今天介绍下前两个模板引擎的使用。</p>
<h2 id="ejs"><a href="#ejs" class="headerlink" title="ejs"></a>ejs</h2><p>官方文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;ejs.bootcss.com&#x2F;</span><br></pre></td></tr></table></figure>



<p>使用esj模板引擎需要安装如下中间件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装模板中间件：npm install --save koa-views</span><br><span class="line">安装ejs模板引擎：cnpm install --save ejs</span><br></pre></td></tr></table></figure>

<h3 id="渲染单个数据"><a href="#渲染单个数据" class="headerlink" title="渲染单个数据"></a>渲染单个数据</h3><p>渲染单个数据的例子如下。</p>
<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node原生模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置模板引擎方式一：模板为ejs后缀</span></span><br><span class="line"><span class="comment">// __dirname表示项目根目录, extension: 'ejs'表示指定模板引擎</span></span><br><span class="line"><span class="comment">// app.use(views(path.join(__dirname, './view/'), &#123;</span></span><br><span class="line"><span class="comment">//     extension: 'ejs'</span></span><br><span class="line"><span class="comment">// &#125;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置模板引擎方式二：模板为html后缀</span></span><br><span class="line">app.use(views(path.join(__dirname, <span class="string">'./view'</span>), &#123;</span><br><span class="line">    map: &#123;</span><br><span class="line">        html: <span class="string">'ejs'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> title = <span class="string">'hello wyzane'</span>;</span><br><span class="line">    <span class="comment">// 渲染 index 模板，对应的是view目录下的index.ejs或者index.html文件</span></span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>, &#123;title&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8090</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>view/index.ejs：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从后端接收title的值并显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>EJS welcome to <span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>view/index.html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从后端接收title的值并显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>EJS welcome to <span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="渲染for循环"><a href="#渲染for循环" class="headerlink" title="渲染for循环"></a>渲染for循环</h3><p>index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node原生模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置模板引擎方式一：模板为ejs后缀</span></span><br><span class="line"><span class="comment">// __dirname表示项目根目录, extension: 'ejs'表示指定模板引擎</span></span><br><span class="line">app.use(views(path.join(__dirname, <span class="string">'./view/'</span>), &#123;</span><br><span class="line">    extension: <span class="string">'ejs'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置模板引擎方式二：模板为html后缀</span></span><br><span class="line"><span class="comment">// app.use(views(path.join(__dirname, './view'), &#123;</span></span><br><span class="line"><span class="comment">//     map: &#123;</span></span><br><span class="line"><span class="comment">//         html: 'ejs'</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;))</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> names = [<span class="string">'喜洋洋'</span>, <span class="string">'吉吉国王'</span>, <span class="string">'光头强'</span>];</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'news'</span>, &#123;names&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8090</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>view/index.ejs：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从后端接收title的值并显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &lt;%for(var i=0;i&lt;names.length;i++)&#123;%&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">names</span>[<span class="attr">i</span>]%&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="渲染if语句"><a href="#渲染if语句" class="headerlink" title="渲染if语句"></a>渲染if语句</h3><p>index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node原生模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(views(path.join(__dirname, <span class="string">'./view/'</span>), &#123;</span><br><span class="line">    extension: <span class="string">'ejs'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'news'</span>, &#123;num&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8090</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>view/index.ejs：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从后端接收title的值并显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%if</span> (<span class="attr">num</span>&gt;</span>10) &#123;%&gt;</span><br><span class="line">        大于10</span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;else&#123;%</span>&gt;</span></span><br><span class="line">        小于10</span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="ant-template"><a href="#ant-template" class="headerlink" title="ant-template"></a>ant-template</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;aui.github.io&#x2F;art-template&#x2F;</span><br></pre></td></tr></table></figure>

<p>下面介绍一些 art-template 的基本语法，感兴趣的同学可以学习官方文档。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save art-template</span><br><span class="line">npm install --save koa-art-template</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> render = <span class="built_in">require</span>(<span class="string">'koa-art-template'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置art-template模板引擎</span></span><br><span class="line">render(app, &#123;</span><br><span class="line">    root: path.join(__dirname, <span class="string">'view'</span>),  <span class="comment">// 模板位置</span></span><br><span class="line">    extends: <span class="string">'.art'</span>,  <span class="comment">// 模板后缀名</span></span><br><span class="line">    debug: process.env.NODE_ENV !== <span class="string">'production'</span>  <span class="comment">// 是否开启调试模式</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/"</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// ctx.body = "首页";</span></span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/news"</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">"新闻"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8099</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"start ..."</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>view/index.art：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>art-template模板引擎使用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>art-template种支持两种语法：原始语法和标准语法。原始语法与ejs的语法类似。下面只介绍标准语法。</p>
<h3 id="渲染单个数据-1"><a href="#渲染单个数据-1" class="headerlink" title="渲染单个数据"></a>渲染单个数据</h3><p>index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> render = <span class="built_in">require</span>(<span class="string">'koa-art-template'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置art-template模板引擎</span></span><br><span class="line">render(app, &#123;</span><br><span class="line">    root: path.join(__dirname, <span class="string">'view'</span>),  <span class="comment">// 模板位置</span></span><br><span class="line">    extends: <span class="string">'.art'</span>,  <span class="comment">// 模板后缀名</span></span><br><span class="line">    debug: process.env.NODE_ENV !== <span class="string">'production'</span>  <span class="comment">// 是否开启调试模式</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/"</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// ctx.body = "首页";</span></span><br><span class="line">    <span class="keyword">let</span> title = <span class="string">'首页'</span>;</span><br><span class="line">    <span class="comment">// 把数据传入模板中</span></span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>, &#123;title&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/news"</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">"新闻"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8099</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"start ..."</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>view/index.art：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>art-template模板引擎使用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 接收传入的数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="渲染for循环-1"><a href="#渲染for循环-1" class="headerlink" title="渲染for循环"></a>渲染for循环</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> render = <span class="built_in">require</span>(<span class="string">'koa-art-template'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置art-template模板引擎</span></span><br><span class="line">render(app, &#123;</span><br><span class="line">    root: path.join(__dirname, <span class="string">'view'</span>),  <span class="comment">// 模板位置</span></span><br><span class="line">    extends: <span class="string">'.art'</span>,  <span class="comment">// 模板后缀名</span></span><br><span class="line">    debug: process.env.NODE_ENV !== <span class="string">'production'</span>  <span class="comment">// 是否开启调试模式</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/"</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// ctx.body = "首页";</span></span><br><span class="line">    <span class="keyword">let</span> names = [<span class="string">'光头强'</span>, <span class="string">'喜洋洋'</span>, <span class="string">'吉吉国王'</span>];</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>, &#123;names&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/news"</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">"新闻"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8099</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"start ..."</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>view/index.art：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>art-template模板引擎使用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 渲染for循环 --&gt;</span></span><br><span class="line">    &#123;&#123;each names&#125;&#125;</span><br><span class="line">    &#123;&#123;$index&#125;&#125; &#123;&#123;$value&#125;&#125;</span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="渲染if"><a href="#渲染if" class="headerlink" title="渲染if"></a>渲染if</h3><p>index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> render = <span class="built_in">require</span>(<span class="string">'koa-art-template'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置art-template模板引擎</span></span><br><span class="line">render(app, &#123;</span><br><span class="line">    root: path.join(__dirname, <span class="string">'view'</span>),  <span class="comment">// 模板位置</span></span><br><span class="line">    extends: <span class="string">'.art'</span>,  <span class="comment">// 模板后缀名</span></span><br><span class="line">    debug: process.env.NODE_ENV !== <span class="string">'production'</span>  <span class="comment">// 是否开启调试模式</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/"</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// ctx.body = "首页";</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">        num: num</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/news"</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">"新闻"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8099</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"start ..."</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>view/index/art：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>art-template模板引擎使用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &#123;&#123; if num &gt; 10&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>大于<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    &#123;&#123; else &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>小于<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>   </span><br><span class="line">    &#123;&#123; /if &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="子模板"><a href="#子模板" class="headerlink" title="子模板"></a>子模板</h3><p>在一个模板中引入另外一个模板</p>
<p>index.art：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>art-template模板引擎使用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &#123;&#123; if num &gt; 10&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>大于<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    &#123;&#123; else &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>小于<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>   </span><br><span class="line">    &#123;&#123; /if &#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入子模板 --&gt;</span></span><br><span class="line">    &#123;&#123; include './footer.art'&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>footer.art：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Footer<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="静态资源的访问"><a href="#静态资源的访问" class="headerlink" title="静态资源的访问"></a>静态资源的访问</h1><p>静态资源在项目中非常重要，在koa2中，需要使用中间件 koa-static 来访问静态资源。</p>
<h2 id="安装中间件"><a href="#安装中间件" class="headerlink" title="安装中间件"></a>安装中间件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install --save koa-static</span><br></pre></td></tr></table></figure>

<h2 id="在模板中使用静态资源"><a href="#在模板中使用静态资源" class="headerlink" title="在模板中使用静态资源"></a>在模板中使用静态资源</h2><p>模板以 ejs 为例</p>
<p>view/index.ejs：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从后端接收title的值并显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入静态文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">'title'</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>EJS welcome to <span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入图片静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"koa.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>static/style.css：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> viewPath = <span class="string">'./view/'</span></span><br><span class="line"><span class="keyword">const</span> staticPath = <span class="string">'./static'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定模板引擎</span></span><br><span class="line">app.use(views(path.join(__dirname, viewPath), &#123;</span><br><span class="line">    extension: <span class="string">'ejs'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定静态资源目录</span></span><br><span class="line"><span class="comment">// app.use(static(path.join(__dirname, staticPath)));  // 方式一</span></span><br><span class="line">app.use(<span class="keyword">static</span>(staticPath));  <span class="comment">// 方式二</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> title = <span class="string">"你好"</span></span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>, &#123;title&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8091</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server starting ...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>以上就是 koa2 中模板引擎的使用和静态资源的访问方式，感兴趣的同学可以深入学习。</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>koa2数据库操作</title>
    <url>/blog/2020/06/13/koa2%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>今天以 postgresql数据库为例，介绍下 koa2 中如何操作数据库。</p>
<a id="more"></a>

<h1 id="所需中间件"><a href="#所需中间件" class="headerlink" title="所需中间件"></a>所需中间件</h1><p>下面使用到了以下中间件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">koa-pg</span><br><span class="line">koa-router</span><br><span class="line">koa-bodyparser</span><br><span class="line"></span><br><span class="line">其中，koa-pg 作为koa连接pg数据库的中间件，koa-router作为路由中间件，koa-bodyparser作为解析post请求中json数据的中间件。</span><br></pre></td></tr></table></figure>

<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="使用客户端连接数据库"><a href="#使用客户端连接数据库" class="headerlink" title="使用客户端连接数据库"></a>使用客户端连接数据库</h2><p>postgre.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pg = <span class="built_in">require</span>(<span class="string">'pg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> conString = <span class="string">"postgres://postgres:wyzane@localhost:5432/test_koa2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> pg.Client(conString);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = client;</span><br></pre></td></tr></table></figure>



<p>app.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client =  <span class="built_in">require</span>(<span class="string">'./dbs/postgres.js'</span>);</span><br><span class="line"></span><br><span class="line">app.use(bodyparser());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> respData = &#123;</span><br><span class="line">    <span class="string">'code'</span>: <span class="string">'0000'</span>,</span><br><span class="line">    <span class="string">'msg'</span>: <span class="string">'成功'</span>,</span><br><span class="line">    <span class="string">'data'</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span> (<span class="params">sql, values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        client.connect(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            client.query(sql, values, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(results);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户列表</span></span><br><span class="line">router.get(<span class="string">'/user/list'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> query(<span class="string">'SELECT * FROM tb_user'</span>, []).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        respData.data = data.rows;</span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        respData.code = <span class="string">'10001'</span>;</span><br><span class="line">        respData.msg = <span class="string">'查询用户列表失败'</span>;</span><br><span class="line"></span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户详情</span></span><br><span class="line">router.post(<span class="string">'/user/detail'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> postParams = ctx.request.body;</span><br><span class="line"></span><br><span class="line">    userId = postParams.userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> query(<span class="string">'SELECT * FROM tb_user WHERE user_id = $1'</span>, [userId]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        respData.data = data.rows;</span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        respData.code = <span class="string">'10002'</span>;</span><br><span class="line">        respData.msg = <span class="string">'查询用户详情失败'</span>;</span><br><span class="line"></span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新用户数据</span></span><br><span class="line">router.post(<span class="string">'/user/update'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> postParams = ctx.request.body;</span><br><span class="line"></span><br><span class="line">    userId = postParams.userId;</span><br><span class="line">    username = postParams.username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> query(<span class="string">'UPDATE tb_user set username = $1 WHERE user_id = $2'</span>, [username, userId]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'更新数据:'</span>, data);</span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        respData.code = <span class="string">'10003'</span>;</span><br><span class="line">        respData.msg = <span class="string">'更新用户信息失败'</span>;</span><br><span class="line"></span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除用户数据</span></span><br><span class="line">router.post(<span class="string">'/user/delete'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> postParams = ctx.request.body;</span><br><span class="line"></span><br><span class="line">    userId = postParams.userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> query(<span class="string">'DELETE FROM tb_user WHERE user_id = $1'</span>, [userId]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'删除数据:'</span>, data);</span><br><span class="line">        </span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'delete data error!'</span>);</span><br><span class="line">        rollback(client);</span><br><span class="line"></span><br><span class="line">        respData.code = <span class="string">'10004'</span>;</span><br><span class="line">        respData.msg = <span class="string">'删除用户信息失败'</span>;</span><br><span class="line"></span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">router.post(<span class="string">'/user/add'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> postParams = ctx.request.body;</span><br><span class="line"></span><br><span class="line">    username = postParams.username;</span><br><span class="line">    password = postParams.password;</span><br><span class="line">    phone = postParams.phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> query(<span class="string">'INSERT INTO tb_user(username, password, phone, add_time) VALUES($1, $2, $3, now())'</span>, </span><br><span class="line">                [username, password, phone]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'添加数据:'</span>, data);</span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'add data error!'</span>);</span><br><span class="line">        rollback(client);</span><br><span class="line"></span><br><span class="line">        respData.code = <span class="string">'10005'</span>;</span><br><span class="line">        respData.msg = <span class="string">'添加用户信息失败'</span>;</span><br><span class="line"></span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义回滚函数</span></span><br><span class="line"><span class="keyword">let</span> rollback = <span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>&#123;</span><br><span class="line">    client.query(<span class="string">'ROLLBACK'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        client.end();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9090</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start ...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的代码中，postgre.js 文件中实例化了一个 postgresql 数据库客户端，并导出。app.js 中分别实现了增、删、改、查方法。</p>
<p>其中，client.query(sql, values, func) 是主要方法，参数1表示需要执行的 sql 语句，参数2表示 sql 语句中对应的值，参数3是一个回调函数，用于 sql 执行完后的回调工作。</p>
<p>上面执行的 sql 中，返回的 data 内容分别如下，它们都是 Result 对象：</p>
<p>查询列表返回的结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Result &#123;</span><br><span class="line">  command: 'SELECT',</span><br><span class="line">  rowCount: 9,</span><br><span class="line">  oid: null,</span><br><span class="line">  rows: [</span><br><span class="line">    &#123;</span><br><span class="line">      user_id: 2,</span><br><span class="line">      username: 'guangtouqiang',</span><br><span class="line">      password: '123456',</span><br><span class="line">      phone: '123456',</span><br><span class="line">      add_time: 2020-05-16T16:00:00.000Z</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      user_id: 3,</span><br><span class="line">      username: 'xiongda',</span><br><span class="line">      password: '123456',</span><br><span class="line">      phone: '123456',</span><br><span class="line">      add_time: 2020-05-16T16:00:00.000Z</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  fields: [</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'user_id',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 1,</span><br><span class="line">      dataTypeID: 23,</span><br><span class="line">      dataTypeSize: 4,</span><br><span class="line">      dataTypeModifier: -1,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;,</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'username',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 2,</span><br><span class="line">      dataTypeID: 1043,</span><br><span class="line">      dataTypeSize: -1,</span><br><span class="line">      dataTypeModifier: 104,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;,</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'password',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 3,</span><br><span class="line">      dataTypeID: 1043,</span><br><span class="line">      dataTypeSize: -1,</span><br><span class="line">      dataTypeModifier: 44,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;,</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'phone',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 4,</span><br><span class="line">      dataTypeID: 1043,</span><br><span class="line">      dataTypeSize: -1,</span><br><span class="line">      dataTypeModifier: 15,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;,</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'add_time',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 5,</span><br><span class="line">      dataTypeID: 1082,</span><br><span class="line">      dataTypeSize: 4,</span><br><span class="line">      dataTypeModifier: -1,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  _parsers: [</span><br><span class="line">    [Function: parseInteger],</span><br><span class="line">    [Function: noParse],</span><br><span class="line">    [Function: noParse],</span><br><span class="line">    [Function: noParse],</span><br><span class="line">    [Function: parseDate]</span><br><span class="line">  ],</span><br><span class="line">  _types: TypeOverrides &#123;</span><br><span class="line">    _types: &#123;</span><br><span class="line">      getTypeParser: [Function: getTypeParser],</span><br><span class="line">      setTypeParser: [Function: setTypeParser],</span><br><span class="line">      arrayParser: [Object],</span><br><span class="line">      builtins: [Object]</span><br><span class="line">    &#125;,</span><br><span class="line">    text: &#123;&#125;,</span><br><span class="line">    binary: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  RowCtor: null,</span><br><span class="line">  rowAsArray: false</span><br></pre></td></tr></table></figure>

<p>查询详情返回的结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Result &#123;</span><br><span class="line">  command: 'SELECT',</span><br><span class="line">  rowCount: 1,</span><br><span class="line">  oid: null,</span><br><span class="line">  rows: [</span><br><span class="line">    &#123;</span><br><span class="line">      user_id: 6,</span><br><span class="line">      username: 'chunzhang',</span><br><span class="line">      password: '12456',</span><br><span class="line">      phone: '123456',</span><br><span class="line">      add_time: 2020-05-16T16:00:00.000Z</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  fields: [</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'user_id',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 1,</span><br><span class="line">      dataTypeID: 23,</span><br><span class="line">      dataTypeSize: 4,</span><br><span class="line">      dataTypeModifier: -1,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;,</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'username',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 2,</span><br><span class="line">      dataTypeID: 1043,</span><br><span class="line">      dataTypeSize: -1,</span><br><span class="line">      dataTypeModifier: 104,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;,</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'password',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 3,</span><br><span class="line">      dataTypeID: 1043,</span><br><span class="line">      dataTypeSize: -1,</span><br><span class="line">      dataTypeModifier: 44,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;,</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'phone',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 4,</span><br><span class="line">      dataTypeID: 1043,</span><br><span class="line">      dataTypeSize: -1,</span><br><span class="line">      dataTypeModifier: 15,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;,</span><br><span class="line">    Field &#123;</span><br><span class="line">      name: 'add_time',</span><br><span class="line">      tableID: 41294,</span><br><span class="line">      columnID: 5,</span><br><span class="line">      dataTypeID: 1082,</span><br><span class="line">      dataTypeSize: 4,</span><br><span class="line">      dataTypeModifier: -1,</span><br><span class="line">      format: 'text'</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  _parsers: [</span><br><span class="line">    [Function: parseInteger],</span><br><span class="line">    [Function: noParse],</span><br><span class="line">    [Function: noParse],</span><br><span class="line">    [Function: noParse],</span><br><span class="line">    [Function: parseDate]</span><br><span class="line">  ],</span><br><span class="line">  _types: TypeOverrides &#123;</span><br><span class="line">    _types: &#123;</span><br><span class="line">      getTypeParser: [Function: getTypeParser],</span><br><span class="line">      setTypeParser: [Function: setTypeParser],</span><br><span class="line">      arrayParser: [Object],</span><br><span class="line">      builtins: [Object]</span><br><span class="line">    &#125;,</span><br><span class="line">    text: &#123;&#125;,</span><br><span class="line">    binary: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  RowCtor: null,</span><br><span class="line">  rowAsArray: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行更新操作返回的结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Result &#123;</span><br><span class="line">  command: 'UPDATE',</span><br><span class="line">  rowCount: 1,</span><br><span class="line">  oid: null,</span><br><span class="line">  rows: [],</span><br><span class="line">  fields: [],</span><br><span class="line">  _parsers: undefined,</span><br><span class="line">  _types: TypeOverrides &#123;</span><br><span class="line">    _types: &#123;</span><br><span class="line">      getTypeParser: [Function: getTypeParser],</span><br><span class="line">      setTypeParser: [Function: setTypeParser],</span><br><span class="line">      arrayParser: [Object],</span><br><span class="line">      builtins: [Object]</span><br><span class="line">    &#125;,</span><br><span class="line">    text: &#123;&#125;,</span><br><span class="line">    binary: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  RowCtor: null,</span><br><span class="line">  rowAsArray: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行删除操作返回的结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Result &#123;</span><br><span class="line">  command: 'DELETE',</span><br><span class="line">  rowCount: 0,</span><br><span class="line">  oid: null,</span><br><span class="line">  rows: [],</span><br><span class="line">  fields: [],</span><br><span class="line">  _parsers: undefined,</span><br><span class="line">  _types: TypeOverrides &#123;</span><br><span class="line">    _types: &#123;</span><br><span class="line">      getTypeParser: [Function: getTypeParser],</span><br><span class="line">      setTypeParser: [Function: setTypeParser],</span><br><span class="line">      arrayParser: [Object],</span><br><span class="line">      builtins: [Object]</span><br><span class="line">    &#125;,</span><br><span class="line">    text: &#123;&#125;,</span><br><span class="line">    binary: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  RowCtor: null,</span><br><span class="line">  rowAsArray: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行添加操作返回的结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Result &#123;</span><br><span class="line">  command: 'INSERT',</span><br><span class="line">  rowCount: 1,</span><br><span class="line">  oid: 0,</span><br><span class="line">  rows: [],</span><br><span class="line">  fields: [],</span><br><span class="line">  _parsers: undefined,</span><br><span class="line">  _types: TypeOverrides &#123;</span><br><span class="line">    _types: &#123;</span><br><span class="line">      getTypeParser: [Function: getTypeParser],</span><br><span class="line">      setTypeParser: [Function: setTypeParser],</span><br><span class="line">      arrayParser: [Object],</span><br><span class="line">      builtins: [Object]</span><br><span class="line">    &#125;,</span><br><span class="line">    text: &#123;&#125;,</span><br><span class="line">    binary: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  RowCtor: null,</span><br><span class="line">  rowAsArray: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用连接池连接数据库"><a href="#使用连接池连接数据库" class="headerlink" title="使用连接池连接数据库"></a>使用连接池连接数据库</h2><p>舒勇连接池连接数据库时，postgre.js 文件的配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pg = <span class="built_in">require</span>(<span class="string">'pg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pgConfig = &#123;</span><br><span class="line">    user: <span class="string">'postgres'</span>,</span><br><span class="line">    database: <span class="string">'test_koa2'</span>,</span><br><span class="line">    password: <span class="string">'wyzane'</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="string">'5432'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pool = <span class="keyword">new</span> pg.Pool(pgConfig);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = pool;</span><br></pre></td></tr></table></figure>

<p>app.js 中查询方法定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span> (<span class="params">sql, values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        pool.connect(<span class="function"><span class="keyword">function</span>(<span class="params">err, client, done</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'连接失败：'</span>, err);</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            client.query(sql, values, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(results);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余的 sql 操作代码都与使用 client 连接数据库一样。</p>
<h2 id="把连接操作封装成对象"><a href="#把连接操作封装成对象" class="headerlink" title="把连接操作封装成对象"></a>把连接操作封装成对象</h2><p>实际开发中，我们可以把数据库连接方法和增、删、改、查等操作数据库的方法封装在一个对象中，像下面这样。</p>
<p>postgres.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pg = <span class="built_in">require</span>(<span class="string">'pg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pgConfig = &#123;</span><br><span class="line">    user: <span class="string">'postgres'</span>,</span><br><span class="line">    database: <span class="string">'test_koa2'</span>,</span><br><span class="line">    password: <span class="string">'wyzane'</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="string">'5432'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pool = <span class="keyword">new</span> pg.Pool(pgConfig);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Postgres</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接数据库方法</span></span><br><span class="line">    connect () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            pool.connect(<span class="function">(<span class="params">err, client, done</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                resolve(client);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询列表</span></span><br><span class="line">    list (sql, values) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">                client.query(sql, values, (err, results) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(results);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> postgres = <span class="keyword">new</span> Postgres();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = postgres;</span><br></pre></td></tr></table></figure>

<p>app.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入数据库实例</span></span><br><span class="line"><span class="keyword">const</span> postgres =  <span class="built_in">require</span>(<span class="string">'./dbs/postgres.js'</span>);</span><br><span class="line"></span><br><span class="line">app.use(bodyparser());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> respData = &#123;</span><br><span class="line">    <span class="string">'code'</span>: <span class="string">'0000'</span>,</span><br><span class="line">    <span class="string">'msg'</span>: <span class="string">'成功'</span>,</span><br><span class="line">    <span class="string">'data'</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户列表</span></span><br><span class="line">router.get(<span class="string">'/user/list'</span>, <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> sql = <span class="string">'SELECT * FROM tb_user'</span>;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> postgres.list(sql, values).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;     </span><br><span class="line">        respData.data = data.rows;</span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        respData.code = <span class="string">'10001'</span>;</span><br><span class="line">        respData.msg = <span class="string">'查询用户列表失败'</span>;</span><br><span class="line"></span><br><span class="line">        ctx.body = respData;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9090</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start ...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="使用单例模式进一步优化"><a href="#使用单例模式进一步优化" class="headerlink" title="使用单例模式进一步优化"></a>使用单例模式进一步优化</h2><p>对于数据库连接对象，我们可以使用单例模式做进一步优化，例子如下：</p>
<p>postgre.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pg = <span class="built_in">require</span>(<span class="string">'pg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pgConfig = &#123;</span><br><span class="line">    user: <span class="string">'postgres'</span>,</span><br><span class="line">    database: <span class="string">'test_koa2'</span>,</span><br><span class="line">    password: <span class="string">'wyzane'</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="string">'5432'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pool = <span class="keyword">new</span> pg.Pool(pgConfig);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Postgres</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.dbClient = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.connect()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connect () &#123;</span><br><span class="line">        <span class="keyword">let</span> _that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_that.dbClient) &#123;</span><br><span class="line">                pool.connect(<span class="function">(<span class="params">err, client, done</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    _that.dbClient = client;</span><br><span class="line">                    resolve(_that.client);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(_that.dbClient);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list (sql, values) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">                client.query(sql, values, (err, results) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(results);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> postgres = <span class="keyword">new</span> Postgres();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = postgres;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，使用了一个 dbClient 属性，当 dbClient 存在时，直接返回，而不是再次连接数据库，这样节省了连接数据库所耗费的时间。</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>nginx中https的配置</title>
    <url>/blog/2020/06/06/nginx%E4%B8%ADhttps%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>今天聊一下如何在nginx中配置https</p>
<p>在web应用开发中，为保证前端访问后端服务器的安全，需要使用https连接，现在来聊一下如何在nginx中配置https.</p>
<a id="more"></a>

<h1 id="申请ssl证书"><a href="#申请ssl证书" class="headerlink" title="申请ssl证书"></a>申请ssl证书</h1><p>在阿里云，腾讯云，华为云等云服务提供商的网站一般都会有免费ssl证书，申请一个即可；下面配置以华为云为例展开。</p>
<h1 id="下载证书"><a href="#下载证书" class="headerlink" title="下载证书"></a>下载证书</h1><p>证书申请后，下载它，会得到server.key和server.crt两个文件；在与nginx.conf同目录下创建ssl文件夹(名字任意), 把这两个证书放入刚创建的文件夹中；</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在nginx.conf的server中增加如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>                 <span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server_name</span>            www.test.com <span class="comment"># 域名         </span></span><br><span class="line">    ssl                    <span class="literal">on</span>;  <span class="comment"># 启用ssl功能            </span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>        ssl/server.crt;           </span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>    ssl/server.key;           </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>    <span class="number">5m</span>;       <span class="comment"># 客户端可以重用会话参数的时间</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span>          TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;    <span class="comment"># 使用的协议     </span></span><br><span class="line">    <span class="attribute">ssl_ciphers</span>            ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;   <span class="comment"># 配置加密套件    </span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>     <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">       ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置443端口之前，需要先打开防火墙和443端口，下面介绍如何打开防火墙，以Centos7为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) 开启防火墙: systemctl start firewalld</span><br><span class="line">	查看防火墙状态: systemctl status firewalld</span><br><span class="line">2) 查看开通了哪些端口: firewall-cmd –list-ports</span><br><span class="line">3) 开通443端口: firewall-cmd –zone&#x3D;public –add-port&#x3D;443&#x2F;tcp –permanent</span><br><span class="line">4) 重新加载下防火墙配置: firewall-cmd –reload</span><br><span class="line">	注意: 如果还有其它应用在运行，开启防火墙后，需要开通相应的端口，否则不能访问。</span><br></pre></td></tr></table></figure>

<p>打开防火墙后，需要将80端口重定向至443端口，在nginx.conf的server上面增加如下的server：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.test.com;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://www.test.com<span class="variable">$1</span> <span class="literal">permanent</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>执行 /usr/sbin/nginx -t，返回如下信息则表示配置成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<p>重启nginx：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>



<p>nginx中配置 https 就介绍到这里。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>koa2模块化开发</title>
    <url>/blog/2020/06/12/koa2%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>模块化开发可以使我们的项目结构更加清晰，协作开发更加方便，后期维护更加容易。下面介绍下 koa2 中的模块化开发。</p>
<a id="more"></a>

<h1 id="koa-generator"><a href="#koa-generator" class="headerlink" title="koa-generator"></a>koa-generator</h1><p>模块化开发就是将接口、视图等归类，按照业务功能分别存放在不同的目录下，koa2 中我们可以使用脚手架 koa-generator 来生成项目结构，它的使用步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装 npm install -g koa-generator</span><br><span class="line">2. 创建项目 koa koa_demo</span><br><span class="line">3. cd koa_demo</span><br><span class="line">4. 安装依赖 npm install</span><br><span class="line">5. 启动项目 npm start</span><br></pre></td></tr></table></figure>

<p>使用 koa-generator 生成的项目目录结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─bin</span><br><span class="line">│  ├─www</span><br><span class="line">├─node_modules</span><br><span class="line">├─public</span><br><span class="line">│  ├─images</span><br><span class="line">│  ├─javascripts</span><br><span class="line">│  └─stylesheets</span><br><span class="line">├─routes</span><br><span class="line">│  ├─admin.js</span><br><span class="line">│  ├─users.js</span><br><span class="line">│  ├─goods.js</span><br><span class="line">└─views</span><br><span class="line">├─app.js</span><br><span class="line">└─package.json</span><br></pre></td></tr></table></figure>

<p>上面自动生成的代码中，将路由和视图模块化了，不同的业务场景路由放在不同的文件下。然后将路由文件引入到 app.js 中统一调用。</p>
<h1 id="路由模块化例子"><a href="#路由模块化例子" class="headerlink" title="路由模块化例子"></a>路由模块化例子</h1><p>admin.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/auth"</span>, (ctx)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'这是权限管理'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/base"</span>, (ctx)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'这是基本信息'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>

<p>user.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/list"</span>, (ctx)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'这是用户列表'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/detail"</span>, (ctx)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'这是用户详情'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>

<p>app.js中的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入子路由</span></span><br><span class="line"><span class="keyword">const</span> admin = <span class="built_in">require</span>(<span class="string">'./routes/admin.js'</span>);</span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">'./routes/user.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置子路由</span></span><br><span class="line">router.use(<span class="string">'/admin'</span>, admin.routes());</span><br><span class="line">router.use(<span class="string">'/user'</span>, user.routes());</span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9091</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start ...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="视图模块化"><a href="#视图模块化" class="headerlink" title="视图模块化"></a>视图模块化</h1><p>视图模块化中，我们使用 art-template 模板引擎为例子。</p>
<p>目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F:.</span><br><span class="line">├─module</span><br><span class="line">├─node_modules</span><br><span class="line">├─public</span><br><span class="line">│  ├─images</span><br><span class="line">│  ├─javascripts</span><br><span class="line">│  └─stylesheets</span><br><span class="line">├─routes</span><br><span class="line">│  ├─admin.js</span><br><span class="line">│  ├─users.js</span><br><span class="line">│  ├─goods.js</span><br><span class="line">├─statics</span><br><span class="line">└─views</span><br><span class="line">    ├─goods</span><br><span class="line">    	├─add.html</span><br><span class="line">      	└─list.html</span><br><span class="line">    └─user</span><br><span class="line">      	├─add.html</span><br><span class="line">      	│─detail.html</span><br><span class="line">      	└─list.html</span><br></pre></td></tr></table></figure>



<p>app.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> render = <span class="built_in">require</span>(<span class="string">'koa-art-template'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置art-template模板引擎</span></span><br><span class="line">render(app, &#123;</span><br><span class="line">    root: path.join(__dirname, <span class="string">'views'</span>),  <span class="comment">// 指定模板的路径</span></span><br><span class="line">    extname: <span class="string">'.html'</span>,                     <span class="comment">// 指定模板后缀</span></span><br><span class="line">    debug: process.env.NODE_ENV != <span class="string">'production'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入子路由</span></span><br><span class="line"><span class="keyword">const</span> admin = <span class="built_in">require</span>(<span class="string">'./routes/admin.js'</span>);</span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">'./routes/user.js'</span>);</span><br><span class="line"><span class="keyword">const</span> goods = <span class="built_in">require</span>(<span class="string">'./routes/goods.js'</span>);</span><br><span class="line"></span><br><span class="line">router.use(<span class="string">'/admin'</span>, admin.routes());</span><br><span class="line">router.use(<span class="string">'/user'</span>, user.routes());</span><br><span class="line">router.use(<span class="string">'/goods'</span>, goods.routes());</span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9091</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start ...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>user.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/list"</span>, <span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    <span class="comment">// render()中的第一个参数指定模板的路径</span></span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'user/list'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/detail"</span>, <span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'user/detail'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/add"</span>, <span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'user/add'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>

<p>goods.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/list"</span>, <span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'goods/list'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/detail"</span>, <span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'这是商品详情'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/add"</span>, <span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'goods/add'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>

<p>上面就是模块化的一个例子。</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>nginx中处理http请求的流程</title>
    <url>/blog/2020/08/02/nginx%E4%B8%AD%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>今天总结下 nginx 处理http请求的流程，重点介绍下处理 http 请求的11个阶段。</p>
<p>nginx 处理 http 请求时，首先会对请求行和请求体进行解析，解析完成后进入11 个阶段，这 11 个阶段会根据 nginx.conf 中的配置信息进行相应的重定向、权限控制、日志记录等操作。</p>
<a id="more"></a>

<h1 id="http请求的11个阶段"><a href="#http请求的11个阶段" class="headerlink" title="http请求的11个阶段"></a>http请求的11个阶段</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST_READ：读取到请求头之后会进入该阶段，realip模块在该阶段使用</span><br><span class="line">SERVER_REWRITE：执行server块内，location块外的指令，rewrite 模块在该阶段生效</span><br><span class="line">FIND_CONFIG：根据配置，寻找对应的 location 块并执行</span><br><span class="line">REWRITE：执行 location 块中的重写指令</span><br><span class="line">POST_REWRITE：根据上阶段的重写指令跳转到合适的阶段</span><br><span class="line">PREACCESS：访问权限控制之前的阶段，执行访问频率、连接数等控制</span><br><span class="line">ACCESS：访问权限的控制阶段，例如基于ip黑名单的权限控制</span><br><span class="line">POST_ACCESS：访问权限控制的后一阶段，该阶段根据权限控制阶段的执行结果进行相应处理</span><br><span class="line">PRECONTENT：try_files指令的处理阶段，如果没有配置try_files指令，则该阶段被跳过</span><br><span class="line">CONTENT：内容生成阶段，该阶段产生响应，并发送到客户端</span><br><span class="line">LOG：记录访问日志</span><br></pre></td></tr></table></figure>

<p>各个请求阶段的顺序如下：</p>
<p><img src="nginx%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B52.png" alt="nginx处理http请求的11个阶段2"></p>
<p>上面简单介绍了 nginx 处理 http 请求的各个阶段，以及各个阶段使用到的模块（导数第二行是 content 阶段，最后一行是 log 阶段）。下面具体介绍各个阶段的功能。</p>
<h2 id="POST-READ"><a href="#POST-READ" class="headerlink" title="POST_READ"></a>POST_READ</h2><p>解析完请求体后，首先会进入 post_read 阶段，该阶段主要获取客户端真实 ip。</p>
<h3 id="realip模块"><a href="#realip模块" class="headerlink" title="realip模块"></a>realip模块</h3><p>realip 模块在 POST_READ 节点生效，可以用来获取客户端的真实 ip 地址。</p>
<p>在 http 请求中，可以通过请求头中的 X-Forwarded-For 和 X-Real-IP 获取 ip 地址，X-Forwarded-For 中可能保存了多个</p>
<p>ip，X-Real-IP 中保存了客户端的真实 ip。realip 模块会把从 X-Forwarded-For 和 X-Real-IP 获取的值赋值到 nginx 变量 binary_remote_addr 和 remote_addr 中，从而通过这两个变量就能获取客户端真实 ip 地址，后续会进一步做限流、限速等工作（在 limit_conn 模块中）。</p>
<p>realip 模块默认没有编译进 nginx ，可以通过 –with-http_realip_module 参数将其编译进 nginx。</p>
<p>realip 中的指令（具体说明可以查阅官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html）" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_realip_module.html）</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. set_real_ip_from addr|CIDR|unix;</span><br><span class="line">作用：设置信任地址，从该地址过来的请求会被获取真实地址，并替换 remote_addr 中的值</span><br><span class="line">例子：set_real_ip_from  192.168.1.0&#x2F;24|192.168.2.1;</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. real_ip_header field | X-Real-IP | X-Forwarded-For | proxy_protocol;</span><br><span class="line">作用：从请求头的哪个参数中获取真实ip</span><br><span class="line">例子：real_ip_header X-Real-IP（默认）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. real_ip_recursive on | off;</span><br><span class="line">作用：设置为 off 时，匹配信任地址（由 set_real_ip_from 设置）的真实客户端地址会被一个值替换，这个值是 real_ip_header 指定的请求头参数中最后一个值；为 on 时，真实客户端地址会被一个非信任值替代，这个值也是 real_ip_header 指定的请求头参数中的值</span><br></pre></td></tr></table></figure>

<p>realip 中指令的配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> realip.wzblogs.cn;</span><br><span class="line">    <span class="attribute">set_real_ip_from</span> <span class="number">223.73.212.4</span>;</span><br><span class="line">    <span class="attribute">real_ip_recursive</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="comment"># real_ip_recursive on;</span></span><br><span class="line">    <span class="attribute">real_ip_header</span> X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">"client real ip is：<span class="variable">$remote_addr</span>\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SERVER-REWRITE"><a href="#SERVER-REWRITE" class="headerlink" title="SERVER_REWRITE"></a>SERVER_REWRITE</h2><p>该阶段中，在 server 块内，location 块外的指令会被执行。</p>
<h3 id="rewrite模块"><a href="#rewrite模块" class="headerlink" title="rewrite模块"></a>rewrite模块</h3><p>rewrite 模块在 server_write 阶段生效，该模块主要功能是改变请求 URI，主要有以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. return code URL | return URL | return code [text]</span><br><span class="line">作用：停止请求的访问，并返回给客户端状态码和重定向url</span><br><span class="line">例子：return 302 &#x2F;redirect_url;</span><br><span class="line">上下文：server, location, if</span><br><span class="line"></span><br><span class="line">return 中的一些状态码：</span><br><span class="line">HTTP 1.0：</span><br><span class="line">301 永久重定向（访问站点a时，被重定向到站点b，则下次遇到访问站点a的请求就会直接访问站点b）</span><br><span class="line">302 临时重定向，禁止被缓存（访问站点a时，被重定向到站点b，则下次还会先访问站点a，再被重定向到b）</span><br><span class="line"></span><br><span class="line">HTTP 1.1:</span><br><span class="line">303 临时重定向，允许改变请求方法，禁止被缓存</span><br><span class="line">307 临时重定向，不允许改变请求方法，禁止被缓存</span><br><span class="line">308 永久重定向，不允许改变请求方法</span><br><span class="line"></span><br><span class="line">error_page 指令与 return 指令的不同</span><br><span class="line">error_page code uri;</span><br><span class="line">作用：nginx接收到指定状态码时，返回特定的页面或者uri</span><br><span class="line">例子： error_page 404 &#x2F;404.html;|error_page 500 501 502 503 &#x2F;50x.html;</span><br><span class="line">error_page 404 &#x3D;200 &#x2F;empty.gif (接收到404时，返回一张图片，响应状态码是200)</span><br><span class="line">上下文：http, server, location, if in location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. rewrite regex replacement [flag]</span><br><span class="line">作用：用于修改接收到的uri，如果如果正则表达式匹配uri，则匹配的uri会被replacement替换。其中 flag 有以下几个值：last,break,redirect,permanent</span><br><span class="line">last： 使用 replacement 继续进行 location匹配</span><br><span class="line">break: 停止当前脚本指令的执行，等价于独立的 break 指令</span><br><span class="line">redirect: 返回302重定向</span><br><span class="line">permanent: 返回301重定向</span><br><span class="line">上下文：server, location, if</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. rewrite_log on | off;</span><br><span class="line">作用：是否记录 rewrite 模块产生的日志，默认为 off，为 on 时，会将日志记录在 error_log 指定的文件中</span><br><span class="line">上下文：http, server, location, if</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. if (condition) &#123; ... &#125;</span><br><span class="line">作用：判断变量的值，如果满足条件，则执行 if 块中的内容</span><br><span class="line">上下文：server, location</span><br><span class="line">condition中可以有下面的功能：</span><br><span class="line">1. 检查变量为空或者为0</span><br><span class="line">2. 将变量与字符串做匹配，使用&#x3D;或者!&#x3D;</span><br><span class="line">3. 将变量与正则表达式匹配</span><br><span class="line">4. 检查文件是否存在，使用 -f 或者 !-f</span><br><span class="line">5. 检查目录是否存在，使用 -d 或者 !-d</span><br><span class="line">6. 检查文件、目录、软链接是否存在，使用 -e 或者 !-e</span><br><span class="line">7. 检查是否为可执行文件，使用 -x 或者 !-x</span><br><span class="line"></span><br><span class="line">if 中也可以使用正则表达式匹配，正则表达式规则如下：</span><br><span class="line">&#x3D;&#x3D;:等值比较;</span><br><span class="line">~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br><span class="line">!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br></pre></td></tr></table></figure>

<h3 id="error-page与return的优先级"><a href="#error-page与return的优先级" class="headerlink" title="error_page与return的优先级"></a>error_page与return的优先级</h3><p>return.conf 的配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8095</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line">    <span class="attribute">error_page</span>  <span class="number">404</span> /<span class="number">403</span>.html;</span><br><span class="line">    <span class="comment"># return 405;</span></span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">        <span class="comment"># return 404 "find nothing\n";</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 nginx 后，执行请求 curl localhost:8095/xxx，会直接返回 html/403.html 中的内容；当打开 location 块中的 return 后，会返回 “find nothing”；同样的，将 server 块中的 return 打开，同样的请求，会返回 405 的错误；这说明 return 指令会覆盖 它前面的 error_page 指令。</p>
<h3 id="rewrite与return的使用"><a href="#rewrite与return的使用" class="headerlink" title="rewrite与return的使用"></a>rewrite与return的使用</h3><p>下面看一个 rewrite 指令的使用例子，rewrite.conf 配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /first &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /first(.*) /second<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'first\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /second &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /second(.*) /third<span class="variable">$1</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'second\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /third &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'third\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /redirect &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /redirect(.*) <span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，html 目录的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 403.html</span><br><span class="line">├── 50x.html</span><br><span class="line">├── first</span><br><span class="line">│   └── 1.txt</span><br><span class="line">├── index.html</span><br><span class="line">├── second</span><br><span class="line">│   └── 2.txt</span><br><span class="line">└── third</span><br><span class="line">    └── 3.txt</span><br></pre></td></tr></table></figure>

<p>启动 nginx 服务后，执行 curl localhost:8096/first/3.txt，返回的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">second</span><br></pre></td></tr></table></figure>

<p>可以看到，先匹配到了 location /first，然后再去匹配 location /second，最后执行了 return 指令，返回了结果。</p>
<p>在 location /second 中的 rewrite 指令后加上 break 后，返回的内容就是 third/3.txt 文件中的内容，此时说明 break 指令生效了，此时访问  curl localhost:8096/second/3.txt 也会得到相同结果。</p>
<h3 id="if-指令使用例子"><a href="#if-指令使用例子" class="headerlink" title="if 指令使用例子"></a>if 指令使用例子</h3><p>if 指令使用例子如下，server_if.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8097;</span><br><span class="line"></span><br><span class="line">    if ($request_uri ~* &#x2F;aaa&#x2F;test.html)&#123;</span><br><span class="line">        return 200 &quot;test.html returned\n&quot;;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        return 200 &quot;location returned\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行 curl localhost:8097/aaa/test.html 时，会进入 if 块中，返回 test.html returned。</p>
<h2 id="FIND-CONFIG"><a href="#FIND-CONFIG" class="headerlink" title="FIND_CONFIG"></a>FIND_CONFIG</h2><p>find_config 阶段主要功能是选择哪个 location 块，并执行 location 块中的配置。location 块中常用指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location </span><br><span class="line">上下文：server，location</span><br><span class="line">location 后面可以跟以下数据：</span><br><span class="line">1. 前缀字符串</span><br><span class="line">	&#x3D;：精确匹配</span><br><span class="line">	^~：匹配成功后，则不再进行正则表达式匹配</span><br><span class="line">	常规字符串</span><br><span class="line">2. 正则表达式</span><br><span class="line">	~：大小写敏感</span><br><span class="line">	~*：忽略大小写</span><br><span class="line">3. 内部跳转的命名location（使用@符号 + 名称）</span><br></pre></td></tr></table></figure>

<p>当 nginx 中配置了多个 location 块时，它的匹配规则是怎么样的呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 首先会遍历所有前缀字符串，找到匹配的 location （与 location 顺序无关）</span><br><span class="line">	1）&#x3D; 精确匹配优先级最高</span><br><span class="line">	2）没有精确匹配时使用 ^~ 匹配上的location</span><br><span class="line">	3）当有多个匹配上时，选择 location 中 url 最长的匹配 </span><br><span class="line">2. 按照正则表达式匹配（此时会根据 location 的顺序进行匹配）</span><br><span class="line">	1）按照正则表达式，匹配上则使用该 location</span><br></pre></td></tr></table></figure>



<p>下面看一下 location 指令使用的具体例子，location.conf的配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8099</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    <span class="attribute">location</span> /aaa &#123;</span><br><span class="line">        <span class="comment"># 前缀匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'prefix string match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /aaa/$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配，大小写敏感</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex strict match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* /aaa/$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配，忽略大小写</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex none strice match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4</span></span><br><span class="line">    <span class="attribute">location</span> /aaa/bbb &#123;</span><br><span class="line">        <span class="comment"># 前缀最长匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'long prefix string match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* /aaa/(\w+)$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'long regex match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /aaa$</span> &#123;</span><br><span class="line">        <span class="comment"># 正则表达式匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7</span></span><br><span class="line">    <span class="attribute">location</span> = /aaa &#123;</span><br><span class="line">        <span class="comment"># 精确匹配</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'exatc match\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 8</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /aaa &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'^~ match \n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当有前缀匹配、正则匹配、^~匹配、精确匹配时，优先精确匹配、其次^~匹配、然后正则匹配、最后前缀匹配，对应上面配置的顺序为7861</span><br><span class="line">curl localhost:8099&#x2F;aaa                                 </span><br><span class="line">响应：exatc match</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正则匹配，优先匹配区分大小写的配置</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;                                </span><br><span class="line">响应：regex strict match</span><br><span class="line"></span><br><span class="line"># 正则匹配，不区分大小写</span><br><span class="line">curl localhost:8099&#x2F;Aaa&#x2F;</span><br><span class="line">响应：regex none strice match</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正则匹配，优先匹配5中的配置而不是4</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;bbb</span><br><span class="line">响应：long regex match</span><br><span class="line"></span><br><span class="line"># 正则表达式未匹配到，使用字符串最长匹配规则，匹配4而不是5</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;bbb&#x2F;</span><br><span class="line">long prefix string match</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ^~，匹配后，则不再使用正选择匹配</span><br><span class="line">curl localhost:8099&#x2F;aaa&#x2F;ccc                             </span><br><span class="line">响应：^~ match </span><br><span class="line"></span><br><span class="line">如果加上配置：</span><br><span class="line">location &#x2F;aaa&#x2F;ccc &#123;</span><br><span class="line">    # 前缀最长匹配</span><br><span class="line">    return 200 &#39;long prefix string match ccc\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">则 curl localhost:8099&#x2F;aaa&#x2F;ccc 会返回 long prefix string match ccc</span><br></pre></td></tr></table></figure>

<h2 id="PREACCESS"><a href="#PREACCESS" class="headerlink" title="PREACCESS"></a>PREACCESS</h2><p>preaccess 阶段主要功能是对客户端的请求数或者连接数进行限制。</p>
<p>限制连接数时，需要用到 nginx 的 ngx_http_limit_conn_module 模块，限制请求数时，要使用 ngx_http_limit_req_module 模块。</p>
<h3 id="limit-conn"><a href="#limit-conn" class="headerlink" title="limit_conn"></a>limit_conn</h3><p>ngx_http_limit_conn_module 模块的生效范围是全部worker（基于共享内存），并且限制的有效性取决于 key 的设计（依赖于 postread 阶段中realip模块取到的真实ip）。 </p>
<p>常用指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">limit_conn_zone key zone&#x3D;name:size;</span><br><span class="line">功能：为一块共享内存指定一个 key，会记录每个 key 的状态（状态中包含了 key 对应的当前连接数）</span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_conn zone number;</span><br><span class="line">功能：限制 key 的并发连接数</span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_conn_log_level info | notice | warn | error;（默认 error）</span><br><span class="line">功能：发生限制并发连接时，打印日志的格式</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_conn_status code;（默认 503）</span><br><span class="line">功能：发生并发连接数限制时，向客户端返回的状态码</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure>

<p>限制客户端连接数的配置例子为：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=addr:<span class="number">10m</span>;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8099</span>;</span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line">    <span class="attribute">error_log</span>  logs/err_limit.log <span class="literal">info</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_conn_status</span> <span class="number">503</span>;</span><br><span class="line">        <span class="attribute">limit_conn_log_level</span>  <span class="literal">warn</span>;</span><br><span class="line">        <span class="comment"># 限制向客户端返回数据的速率（每秒50字节）</span></span><br><span class="line">        <span class="attribute">limit_rate</span> <span class="number">50</span>;</span><br><span class="line">        <span class="attribute">limit_conn</span> addr <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="limit-req"><a href="#limit-req" class="headerlink" title="limit_req"></a>limit_req</h3><p>ngx_http_limit_req_module 模块的生效范围也是全部 worker  进程，使用的算法是 leaky bucket 算法。</p>
<p>常用指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">limit_req_zone key zone&#x3D;name:size rate&#x3D;rate;</span><br><span class="line">功能：与 limit_conn_zone 功能类似，定义共享内存大小，以及根据 key 关键字限制速率，rate 是每秒或每分钟处理的请求数（r&#x2F;s、r&#x2F;m）</span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req limit_req zone&#x3D;name [burst&#x3D;number] [nodelay | delay&#x3D;number];</span><br><span class="line">功能：限制并发连接数，burst表示最大请求数，nodelay表示对burst中的请求立刻处理</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req_log_level info | notice | warn | error;</span><br><span class="line">功能：限制发生时的日志级别</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">limit_req_status code;</span><br><span class="line">功能：限制发生时，返回给客户端的状态码</span><br><span class="line">上下文: http, server, location</span><br></pre></td></tr></table></figure>

<p>限制客户端请求数的配置例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 每分钟处理两次请求</span><br><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;req:10m rate&#x3D;2r&#x2F;m;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8099;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log  logs&#x2F;err_limit.log info;</span><br><span class="line">   </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        limit_req zone&#x3D;req burst&#x3D;3 nodelay;</span><br><span class="line">        # limit_req zone&#x3D;req;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当同时配置了 limit_conn 和 limit_req 时，由于 limt_req 模块在 limit_conn 模块之前，所以 limit_req 模块会先返回，limit_conn 模块则不会返回。</p>
<h2 id="ACCESS"><a href="#ACCESS" class="headerlink" title="ACCESS"></a>ACCESS</h2><p>access 阶段主要负责对 ip 访问的权限控制，常用模块 ngx_http_access_module（用户对 ip 做限制）、 ngx_http_auth_basic_module（校验用户名和密码）、ngx_http_auth_request_module（使用第三方的权限验证）</p>
<p>与 access 阶段相关的一个指令 satisfy ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">satisfy all | any;</span><br><span class="line">功能：配置为all时，所有模块（ngx_http_access_module, ngx_http_auth_basic_module, ngx_http_auth_request_module, ngx_http_auth_jwt_module）通过时，请求才能继续；为 any 时，至少有一个模块通过请求才能继续。默认为 all</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure>



<p>access （ngx_http_access_module）模块常用指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow address | CIDR | unix: | all;</span><br><span class="line">功能：允许哪些地址访问</span><br><span class="line">上下文：http, server, location, limit_except</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deny address | CIDR | unix: | all;</span><br><span class="line">功能：不允许哪些地址访问</span><br><span class="line">上下文：http, server, location, limit_except</span><br></pre></td></tr></table></figure>

<p>配置例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    deny 192.168.1.1;</span><br><span class="line">    allow 192.168.1.0&#x2F;24;</span><br><span class="line">    allow 10.1.1.0&#x2F;16;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>auth_basic（ngx_http_auth_basic_module） 模块常用指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth_basic string | off;</span><br><span class="line">功能：开启或者禁用 auth_basic，默认off，string表示浏览器上标签页显示的对话框名称</span><br><span class="line">上下文：http, server, location, limit_except</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth_basic_user_file file;</span><br><span class="line">功能：指定用户名、密码配置文件</span><br><span class="line">上下文：http, server, location, limit_except</span><br></pre></td></tr></table></figure>

<p>配置例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8099;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        satisfy any;</span><br><span class="line">        auth_basic &#39;auth_test&#39;;</span><br><span class="line">        # 指定密码文件为 passwd&#x2F;user.pass</span><br><span class="line">        auth_basic_user_file passwd&#x2F;user.pass;</span><br><span class="line">        deny all;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>auth_request（ngx_http_auth_request_module） 模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理：收到请求后，生成一个子请求，通过反向代理把子请求传到上游第三方服务器，根据上游服务器返回的响应来处理收到的原请求。若上游服务器范围的状态码为 2xx，则允许请求继续，若范围的是 401 或者 403，则将请求返回给客户端。</span><br></pre></td></tr></table></figure>

<p>常用指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth_request uri | off;</span><br><span class="line">功能：配置子请求访问的url，默认为off</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth_request_set $variable value;</span><br><span class="line">功能：权限校验完成后，设置新的变量和值，值中可以包含上游请求的一些信息</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure>

<h2 id="PRECONTENT阶段"><a href="#PRECONTENT阶段" class="headerlink" title="PRECONTENT阶段"></a>PRECONTENT阶段</h2><h3 id="try-files模块"><a href="#try-files模块" class="headerlink" title="try_files模块"></a>try_files模块</h3><p>try_files 模块中有一个 try_files 指令，其功能如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">功能：依次访问文件，当文件存在时，返回文件中的内容，后面的文件将不再访问，若文件都不存在，返回最后的 url 或者 code</span><br><span class="line">语法：try_files file1 file2 file3 ... uri|&#x3D;code;</span><br><span class="line">上下文：server, location</span><br></pre></td></tr></table></figure>

<p>使用例子如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8090</span>;</span><br><span class="line">    <span class="attribute">root</span> html/;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /first &#123;</span><br><span class="line">        <span class="attribute">try_files</span> /tmp/index.html <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html <span class="variable">$uri</span>.html <span class="variable">@lasturl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@lasturl</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'lasturl \n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /second &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mirror模块"><a href="#mirror模块" class="headerlink" title="mirror模块"></a>mirror模块</h3><p>mirror 模块具有实时流量拷贝的功能，可以把生产环境的请求拷贝一份到测试环境中。该模块中提供了以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. mirror</span><br><span class="line">功能：处理请求时，生成子请求访问其他服务，对于子请求的返回值则不做处理</span><br><span class="line">语法：mirror uri | off(默认);</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. mirror_request_body</span><br><span class="line">功能：是否把请求体也转发到其他服务</span><br><span class="line">语法：mirror_request_body on(默认) | off;</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure>

<h2 id="CONTENT阶段"><a href="#CONTENT阶段" class="headerlink" title="CONTENT阶段"></a>CONTENT阶段</h2><h3 id="static模块"><a href="#static模块" class="headerlink" title="static模块"></a>static模块</h3><p>content阶段中有一个 static 模块，它提供了两个我们常用的指令：root 和 alias，这两个指令的功能都是将 url 映射为文件路径，以返回静态文件中的内容。其中 root 将完整的 url 映射为文件路径，alias 将 location 后的 url 映射为文件路径。两个指令的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. root</span><br><span class="line">语法：root path; （默认：root html）</span><br><span class="line">上下文：http, server, location, if in location</span><br><span class="line"></span><br><span class="line">2. alias</span><br><span class="line">语法：alias path;（无默认值）</span><br><span class="line">上下文：location</span><br></pre></td></tr></table></figure>

<p>static 模块中还提供了三个静态文件相关的变量：request_filename（待访问文件的完整路径）、document_root（由 URI 和 root/alias 指定的规则生成的文件对应的目录）、realpath_root（若document_root中有软链接，则会将软链接替换成真实路径）。</p>
<p>static模块中还提供了以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. types</span><br><span class="line">功能：映射文件扩展名和响应中的 content-type</span><br><span class="line">语法：types &#123;text&#x2F;html  html; image&#x2F;gif  gif; image&#x2F;jpeg jpg;&#125;</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. default_type</span><br><span class="line">功能：设置响应中默认的 content-type</span><br><span class="line">语法：default_type mime-type;</span><br><span class="line">默认：	default_type text&#x2F;plain;</span><br><span class="line">上下文: http, server, location</span><br></pre></td></tr></table></figure>

<h3 id="index模块"><a href="#index模块" class="headerlink" title="index模块"></a>index模块</h3><p>index 模块的功能是：当访问的 url 以 / 结尾时，index 模块就会寻找该目录下是否有 index.html 文件，如果有，就会将 index.html 的内容返回。可以通过 index 指令指定要寻找的文件名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：index file;</span><br><span class="line">默认：index index.html;</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure>

<h3 id="autoindex模块"><a href="#autoindex模块" class="headerlink" title="autoindex模块"></a>autoindex模块</h3><p>audoindex 模块的功能是：当请求 url 以 / 结尾时，会尝试以 html/xml/jspn/jsonp 等形式返回 root/alias 所指向目录的目录结构。指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. autoindex</span><br><span class="line">功能：展示或者不展示目录结构</span><br><span class="line">用法：autoindex on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. autoindex_format</span><br><span class="line">功能：显示的格式</span><br><span class="line">用法：autoindex_format html | xml | json | jsonp;（默认 html）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. autoindex_localtime</span><br><span class="line">功能：是否显示本地时间（仅 html 格式生效）</span><br><span class="line">用法：autoindex_localtime on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. autoindex_exact_size</span><br><span class="line">功能：是否显示文件大小（仅 html 格式生效）</span><br><span class="line">用法：autoindex_exact_size on | off;（默认 off，显示字节数）</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure>

<h3 id="concat-模块"><a href="#concat-模块" class="headerlink" title="concat 模块"></a>concat 模块</h3><p>concat 模块的功能是：可以把多个小文件的内容合并到一个 http 响应中返回。该模块的 github 地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nginx-http-concat</span><br></pre></td></tr></table></figure>

<p>当请求多个文件内容时，请求url后需要跟两个?，再配合该模块，就可以接收多个文件的内容，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;example.com&#x2F;??style1.css,style2.css,foo&#x2F;style3.css</span><br><span class="line">http:&#x2F;&#x2F;example.com&#x2F;xxx&#x2F;??style1.css,style2.css,foo&#x2F;style3.css</span><br></pre></td></tr></table></figure>



<p>下载后，可以通过 –add-modules 来安装该模块。它提供的指令有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. concat</span><br><span class="line">功能：是否启用合并功能</span><br><span class="line">用法：concat on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. concat_types</span><br><span class="line">功能：指定对哪些文件类型做合并</span><br><span class="line">用法：concat_types MIME types</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. concat_delimiter</span><br><span class="line">功能：返回多个文件时，指定文件内容的分隔符</span><br><span class="line">用法：concat_delimiter: string;</span><br><span class="line">上下文：http, server, locatione</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. concat_unique</span><br><span class="line">功能：是否仅对一种文件类型合并</span><br><span class="line">用法：concat_unique on | off;（默认 on, 仅对一种文件类型合并）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. concat_ignore_file_error</span><br><span class="line">功能：是否忽略文件不存在等错误</span><br><span class="line">用法：concat_ignore_file_error: on | off;（默认 off）</span><br><span class="line">上下文：http, server, location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. concat_max_files</span><br><span class="line">功能：指定最多合并的文件数量</span><br><span class="line">用法：concat_max_files number（默认 10）</span><br><span class="line">上下文：http, server, location</span><br></pre></td></tr></table></figure>

<h2 id="LOG阶段"><a href="#LOG阶段" class="headerlink" title="LOG阶段"></a>LOG阶段</h2><p>log阶段中有 log 模块，它的功能是把 http 请求相关的信息记录到日志文件中。常用指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. log_format</span><br><span class="line">功能：定义日志的格式</span><br><span class="line">用法：log_format name [escape&#x3D;default|json|none] string ...;</span><br><span class="line">默认：log_format combined &#39;...&#39;;（日志有一个默认格式）</span><br><span class="line">上下文: http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. access_log</span><br><span class="line">功能：指定日志文件路径和格式</span><br><span class="line">用法：access_log path [format [buffer&#x3D;size] [gzip[&#x3D;level]] [flush&#x3D;time] [if&#x3D;condition]];</span><br><span class="line">默认：access_log path combined;</span><br><span class="line">上下文：http, server, location, if in location, limit_except</span><br><span class="line"></span><br><span class="line">access_log 后的 path 中可以包含变量，它后面也可以跟 buffer、gzip、flush等参数，这些参数有如下功能：</span><br><span class="line">1. 日志缓存：批量将内存中的日志写入缓存中，写入磁盘的条件有1）所欲待写入磁盘的日志大小超出缓存大小 2）达到 flush 指定的过期时间 3）worker进程执行 reopen 命令</span><br><span class="line">2. 日志压缩：批量压缩内存中的日志，再写入磁盘，buffer参数值的默认大小为64k，压缩级别默认为1（1最快压缩压缩率最低 9最慢压缩压缩率最高）</span><br></pre></td></tr></table></figure>



<p>….. 未完待续</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>pg数据库创建分区表</title>
    <url>/blog/2019/11/29/pg%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
    <content><![CDATA[<p>提高应用程序查询数据库效率方面，除了优化程序中的代码，对数据库的管理与维护也是很重要的一方面。比如在开发阶段表中字段的类型、是否创建索引、大表是否创建分区表及是否单独指定表空间等。</p>
<a id="more"></a>

<p>下面以postgresql 10.8(以下简称pg)为例，介绍下在pg中如何创建分区表。</p>
<h2 id="PostgreSQL中创建分区表"><a href="#PostgreSQL中创建分区表" class="headerlink" title="PostgreSQL中创建分区表"></a>PostgreSQL中创建分区表</h2><p>首先，贴出来pg的官方文档，上面讲的还是比较详细的：</p>
<p><a href="https://www.postgresql.org/docs/10/index.html" target="_blank" rel="noopener">https://www.postgresql.org/docs/10/index.html</a></p>
<p>pg中有两种分区方式，一个是pg提供的内建分区方式，另一种是自定义创建分区的方式。</p>
<h3 id="内建分区方式"><a href="#内建分区方式" class="headerlink" title="内建分区方式"></a>内建分区方式</h3><p>内建分区表类型：范围分区，列表分区。下面以范围分区为例。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建分区主表，以call_time作为范围分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> partition_test_table_master</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>  <span class="built_in">SERIAL</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    call_time   <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    session_id  <span class="built_in">char</span>(<span class="number">64</span>),</span><br><span class="line">    user_input  <span class="built_in">char</span>(<span class="number">1024</span>),</span><br><span class="line">    intention   <span class="built_in">char</span>(<span class="number">1024</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (call_time);</span><br></pre></td></tr></table></figure>

<p>创建分区表时，也可以使用多个字段作为分区键。如果使用多个字段作为分区键，可能会创建大量子分区，每个子分区占用的空间会变小。<br>当使用较少的字段作为分区键时，可能会以粗粒度的标准创建若干分区，分区数量也会相对变少，当有查询满足条件时，扫描的分区也会减少。</p>
<p>当插入的数据没有被分到任何分区时，会报错，这时我们可以手工创建一个新分区存放这些数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建分区表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> partition_2019_06 </span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">OF</span> partition_test_table_master</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2019-06-01 00:00:00'</span>) <span class="keyword">TO</span> (<span class="string">'2019-07-01 00:00:00'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> partition_2019_07</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">OF</span> partition_test_table_master</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2019-07-01 00:00:00'</span>) <span class="keyword">TO</span> (<span class="string">'2019-08-01 00:00:00'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建子分区并指定所在表空间，将大表单独保存在一个表空间中，也可以提高查询效率</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> partition_2019_08</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">OF</span> partition_test_table_master</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2019-08-01 00:00:00'</span>) <span class="keyword">TO</span> (<span class="string">'2019-09-01 00:00:00'</span>)</span><br><span class="line"><span class="keyword">TABLESPACE</span> tablespace_test;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 为子分区创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">ON</span> partition_2019_06 (call_time);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">ON</span> partition_2019_06 (session_id);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 向分区表中插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.partition_test_table_master(</span><br><span class="line">    call_time, session_id, user_input, intention)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="keyword">now</span>(), <span class="string">'wyzaneitnfyhwyq'</span>, <span class="string">'你好'</span>, <span class="string">'打招呼'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.partition_test_table_master(</span><br><span class="line">    call_time, session_id, user_input, intention)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">'2019-06-01 00:00:00'</span>, <span class="string">'wyzaneitnfyhwyq'</span>, <span class="string">'你好'</span>, <span class="string">'打招呼'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.partition_test_table_master(</span><br><span class="line">    call_time, session_id, user_input, intention)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">'2019-07-01 00:00:00'</span>, <span class="string">'wyzaneitnfyhwyq'</span>, <span class="string">'你好'</span>, <span class="string">'打招呼'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.partition_test_table_master(</span><br><span class="line">    call_time, session_id, user_input, intention)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">'2019-08-23 00:00:00'</span>, <span class="string">'wyzaneitnfyhwyq'</span>, <span class="string">'你好'</span>, <span class="string">'打招呼'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.partition_test_table_master(</span><br><span class="line">    call_time, session_id, user_input, intention)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">'2019-04-23 00:00:00'</span>, <span class="string">'wyzaneitnfyhwyq'</span>, <span class="string">'你好'</span>, <span class="string">'打招呼'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.partition_test_table_master(</span><br><span class="line">    call_time, session_id, user_input, intention)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">'2019-10-23 00:00:00'</span>, <span class="string">'wyzaneitnf</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 当你想删除不需要的数据时，可以直接删除子分区</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> partition_2019_06;</span><br><span class="line"><span class="comment">-- 或者可以将子分区从当前分区表中移除，但是表中的数据仍然存在，这是一种不错的处理方式</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> partition_test_table_master </span><br><span class="line">DETACH <span class="keyword">PARTITION</span> partition_2019_07;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将一个已创建的表加入到子分区中</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> partition_2019_10</span><br><span class="line">  (<span class="keyword">LIKE</span> partition_test_table_master </span><br><span class="line">   <span class="keyword">INCLUDING</span> <span class="keyword">DEFAULTS</span> <span class="keyword">INCLUDING</span> <span class="keyword">CONSTRAINTS</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> partition_2019_10 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> cons_partition_2019_10</span><br><span class="line">   <span class="keyword">CHECK</span> ( call_time &amp;gt;= DATE '2019-10-01 00:00:00' </span><br><span class="line">          AND call_time &amp;lt; DATE '2019-11-01 00:00:00' );</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> partition_test_table_master ATTACH <span class="keyword">PARTITION</span> partition_2019_10</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2019-10-01 00:00:00'</span>) <span class="keyword">TO</span> (<span class="string">'2019-11-01 00:00:00'</span> );</span><br></pre></td></tr></table></figure>

<p>上面创建分区表的缺点<br>1.必须分别对每个分区创建索引，也就是说不能在所有分区上创建主键，唯一约束，排他性约束<br>2.分区表不支持主键，也不支持外键索引<br>3.执行更新操作后，数据不能改变分区<br>4.行触发器应该单独定义在每个子分区，而不是在分区表上定义</p>
<h3 id="自定义分区"><a href="#自定义分区" class="headerlink" title="自定义分区"></a>自定义分区</h3><p>使用表继承的方式创建分区表</p>
<p>自定义分区的优势<br>1.允许子分区含有额外的列<br>2.可以多继承<br>3.可以根据用户选择的任何方式进行分区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建主表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> partition_test_table_master_2</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>  <span class="built_in">SERIAL</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    call_time   <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    session_id  <span class="built_in">char</span>(<span class="number">64</span>),</span><br><span class="line">    user_input  <span class="built_in">char</span>(<span class="number">1024</span>),</span><br><span class="line">    intention   <span class="built_in">char</span>(<span class="number">1024</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建分区表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> partition_2019_11 (</span><br><span class="line">    <span class="keyword">CHECK</span> ( call_time &amp;gt;= DATE '2019-11-01 00:00:00' </span><br><span class="line">           AND call_time &amp;lt; DATE '2019-12-01 00:00:00' )</span><br><span class="line">) INHERITS (partition_test_table_master_2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> partition_2019_12 (</span><br><span class="line">    <span class="keyword">CHECK</span> ( call_time &amp;gt;= DATE '2019-12-01 00:00:00' </span><br><span class="line">           AND call_time &amp;lt; DATE '2020-01-01 00:00:00' )</span><br><span class="line">) INHERITS (partition_test_table_master_2);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_partition_2019_11 <span class="keyword">ON</span> partition_2019_11 (call_time);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建函数，将对主表的insert操作映射到对应子分区上</span></span><br><span class="line"><span class="comment">-- NEW表示将要插入的那行数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> func_partition_insert()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">IF</span> ( NEW.call_time &amp;gt;= DATE '2019-11-01 00:00:00' AND</span><br><span class="line">         NEW.call_time &amp;lt; DATE '2019-12-01 00:00:00' ) THEN</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> partition_2019_11 <span class="keyword">VALUES</span> (NEW.*);</span><br><span class="line">    ELSIF ( NEW.call_time &amp;gt;= DATE '2019-12-01 00:00:00' AND</span><br><span class="line">            NEW.call_time &amp;lt; DATE '2020-01-01 00:00:00' ) THEN</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> partition_2019_12 <span class="keyword">VALUES</span> (NEW.*);</span><br><span class="line">    ELSE</span><br><span class="line">        RAISE EXCEPTION 'Date out of range.  Fix the partition_test_table_master() function!';</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    RETURN NULL;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建触发器，每次执行插入操作时调用上面的函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_partition_insert</span><br><span class="line">    <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> partition_test_table_master_2</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> func_partition_insert();</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入数据，执行insert操作时，会触发trigger_partition_insert触发器</span></span><br><span class="line"><span class="comment">-- 触发器中会调用函数func_partition_insert()</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.partition_test_table_master_2(</span><br><span class="line">    call_time, session_id, user_input, intention)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">'2019-11-23 00:00:00'</span>, <span class="string">'wyzaneitnfyhwyq'</span>, <span class="string">'你好'</span>, <span class="string">'打招呼'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 也可以把上面的function和trigger换成rule</span></span><br><span class="line"><span class="keyword">CREATE</span> RULE rule_partition_insert_2019_11 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">INSERT</span> <span class="keyword">TO</span> partition_test_table_master_2 <span class="keyword">WHERE</span></span><br><span class="line">    ( call_time &amp;gt;= DATE '2019-11-01 00:00:00' </span><br><span class="line">     AND call_time &amp;lt; DATE '2019-12-01 00:00:00' )</span><br><span class="line"><span class="keyword">DO</span> INSTEAD</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> partition_2019_11 <span class="keyword">VALUES</span> (NEW.*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> RULE rule_partition_insert_2019_12 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">INSERT</span> <span class="keyword">TO</span> partition_test_table_master_2 <span class="keyword">WHERE</span></span><br><span class="line">    ( call_time &amp;gt;= DATE '2019-12-01 00:00:00' </span><br><span class="line">     AND call_time &amp;lt; DATE '2020-01-01 00:00:00' )</span><br><span class="line"><span class="keyword">DO</span> INSTEAD</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> partition_2019_12 <span class="keyword">VALUES</span> (NEW.*);</span><br></pre></td></tr></table></figure>



<p>通过上面的介绍，可以看出自定义分区相比于内建分区还是复杂一些，需要自定义触发器和插入数据时的逻辑。对于一般的日志表、交易流水表等，可以使用内建方式以时间分区，对于更复杂的场景，还是需要使用自定义方式创建分区。对于不熟悉pg的存储过程或者函数语法的同学，可能编写函数或者触发器有些困难。pg的存储过程或者函数的语法与oracle和mysql的语法有很多相似之处。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx的安装与使用(一)</title>
    <url>/blog/2020/04/19/nginx%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8-%E4%B8%80/</url>
    <content><![CDATA[<p>今天主要介绍下 nginx 的安装与简单使用。</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装步骤如下（ubuntu18.04）：</span><br><span class="line">1. 安装依赖项：</span><br><span class="line">	sudo apt-get update</span><br><span class="line">	sudo apt-get install build-essential zlib1g-dev libpcre3 libpcre3-dev libssl-dev    			libxml2-dev libgeoip-dev libgoogle-perftools-dev libperl-dev libtool</span><br><span class="line">	sudo apt-get install openssl</span><br><span class="line">2. 下载 nginx 源码包并解压</span><br><span class="line">	wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.1.tar.gz</span><br><span class="line">3. 执行安装命令 （ngx_http_proxy_connect_module是一个正向代理的模块，如果有需求，还可以安装其他模块）</span><br><span class="line">	.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream </span><br><span class="line">	 --add-module&#x3D;&#x2F;home&#x2F;wyzane&#x2F;softwares&#x2F;ngx_http_proxy_connect_module</span><br><span class="line">	sudo make</span><br><span class="line">	sudo make install</span><br><span class="line">安装完成后，就可以启动了</span><br><span class="line"></span><br><span class="line">4. 创建软链接</span><br><span class="line">	sudo ln -s &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">5. 查看nginx是否启动成功</span><br><span class="line">	浏览器中输入：http:&#x2F;&#x2F;127.0.0.1:8081&#x2F;</span><br><span class="line">	出现nginx的欢迎页即表明nginx启动成功</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">安装步骤如下（centos8.1）：</span><br><span class="line">1. 安装依赖</span><br><span class="line">	yum update</span><br><span class="line">	yum install gcc-c++</span><br><span class="line">	yum install -y pcre pcre-devel</span><br><span class="line">	yum install -y zlib zlib-devel</span><br><span class="line">	yum install -y openssl openssl-devel</span><br><span class="line">2. 下载 nginx 源码包并解压</span><br><span class="line">	wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.1.tar.gz</span><br><span class="line">3. 安装patch命令（对于nginx-1.16，ngx_http_proxy_connect_module需要打补丁）</span><br><span class="line">	yum -y install patch</span><br><span class="line">4. 给ngx_http_proxy_connect_module打补丁</span><br><span class="line">	patch -p1 &lt; &#x2F;home&#x2F;wz&#x2F;softwares&#x2F;ngx_http_proxy_connect_module&#x2F;patch&#x2F;proxy_connect_rewrite_101504.patch</span><br><span class="line">5. 执行命令</span><br><span class="line">	.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream </span><br><span class="line">		--add-module&#x3D;&#x2F;home&#x2F;wz&#x2F;softwares&#x2F;ngx_http_proxy_connect_module</span><br><span class="line">	make</span><br><span class="line">	make install</span><br><span class="line">	</span><br><span class="line">	make clean：重新编译安装</span><br><span class="line">6. 创建软链接</span><br><span class="line">	sudo ln -s &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可能的问题：</span><br><span class="line">1）centos编译安装Nginx提示 bash: make: command not found</span><br><span class="line">	解决：yum -y install gcc automake autoconf libtool make</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu上安装net工具：</span><br><span class="line">sudo apt-get install net-tools</span><br><span class="line">安装后可以使用 netstat 命令</span><br></pre></td></tr></table></figure>



<p>下面的操作都是在 ubuntu18.04 上完成的。</p>
<h1 id="设置系统服务"><a href="#设置系统服务" class="headerlink" title="设置系统服务"></a>设置系统服务</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将nginx添加到系统服务的步骤如下：</span><br><span class="line">1. 新增nginx.service文件</span><br><span class="line">	sudo vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service</span><br><span class="line">2. 添加如下内容：</span><br><span class="line">	[Unit]</span><br><span class="line">    Description&#x3D;nginx - high performance web server</span><br><span class="line">    After&#x3D;network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">    [Service]</span><br><span class="line">    Type&#x3D;forking</span><br><span class="line">    ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">    ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br><span class="line">    ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop</span><br><span class="line"></span><br><span class="line">    [Install]</span><br><span class="line">    WantedBy&#x3D;multi-user.target</span><br><span class="line">    </span><br><span class="line">    配置说明：</span><br><span class="line">        [Unit]部分</span><br><span class="line">        Description:描述服务</span><br><span class="line">        After:依赖，当依赖的服务启动之后再启动自定义的服务</span><br><span class="line"></span><br><span class="line">        [Service]部分</span><br><span class="line">        Type&#x3D;forking是后台运行的形式</span><br><span class="line">        ExecStart为服务的具体运行命令(需要根据路径适配)</span><br><span class="line">        ExecReload为重启命令(需要根据路径适配)</span><br><span class="line">        ExecStop为停止命令(需要根据路径适配)</span><br><span class="line">        PrivateTmp&#x3D;True表示给服务分配独立的临时空间</span><br><span class="line">        </span><br><span class="line">        [Install]部分</span><br><span class="line">		服务安装的相关设置，可设置为多用户</span><br><span class="line">3. 配置完成后，常用命令如下：</span><br><span class="line">	# 设置了自启动后，任意目录下执行</span><br><span class="line">    systemctl enable nginx.service</span><br><span class="line">    # 启动nginx服务</span><br><span class="line">    systemctl start nginx.service</span><br><span class="line">    # 设置开机自动启动</span><br><span class="line">    systemctl enable nginx.service</span><br><span class="line">    # 停止开机自动启动</span><br><span class="line">    systemctl disable nginx.service</span><br><span class="line">    # 查看状态</span><br><span class="line">    systemctl status nginx.service</span><br><span class="line">    # 重启服务</span><br><span class="line">    systemctl restart nginx.service</span><br><span class="line">    # 查看所有服务</span><br><span class="line">    systemctl list-units --type&#x3D;service</span><br></pre></td></tr></table></figure>



<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c: 指定开启nginx时使用的配置文件</span><br><span class="line"></span><br><span class="line">nginx -s: 发送信号</span><br><span class="line">nginx -s stop</span><br><span class="line">nginx -s quit  优雅的停止服务</span><br><span class="line">nginx -t: 修改配置文件后，先测试</span><br><span class="line">nginx -v：查看nginx版本</span><br><span class="line"></span><br><span class="line">.&#x2F;nginx -s reload 不停止Nginx服务的方式重启nginx</span><br><span class="line">重启命令还有如下方式：</span><br><span class="line">kill -SIGHUP masterpid  与reload相同，都是重启nginx服务（主进程重新生成子进程）</span><br><span class="line"></span><br><span class="line">此外，还有一个命令：</span><br><span class="line">kill -SIGTERM childpid  向子进程发送退出命令，并告知主进程，主进程会产生新的子进程</span><br></pre></td></tr></table></figure>



<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压后nginx的目录结构如下：</span><br><span class="line">auto: 文件夹</span><br><span class="line">CHANGES: 文件，介绍nginx每个版本的特性</span><br><span class="line">conf: 配置文件所在文件夹</span><br><span class="line">configure: 脚本，在编译前执行，生成中间文件</span><br><span class="line">contrib:</span><br><span class="line">html: 提供两个标准html文件: 50x.html,index.html</span><br><span class="line">man: linux对nginx的帮助文件  man .&#x2F;nginx.8</span><br><span class="line">src: nginx的源代码</span><br></pre></td></tr></table></figure>

<h1 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx 主要由二进制文件（定义nginx的功能）、conf配置文件（控制nginx的行为）、access.log（记录nginx的执行信息）、error.log（记录nginx的错误信息） 这四部分组成。</span><br></pre></td></tr></table></figure>



<h1 id="热部署方式"><a href="#热部署方式" class="headerlink" title="热部署方式"></a>热部署方式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">热部署nginx：不停止当前nginx的情况下升级nginx，只需要更换nginx二进制文件</span><br><span class="line">步骤如下：</span><br><span class="line">1.备份当前nginx二进制文件： cp nginx nginx.old</span><br><span class="line">2.用编译后的最新版本的nginx二进制文件替换掉现在的nginx文件</span><br><span class="line">3.给当前nginx的master进程发送信号：kill -USR2 pid</span><br><span class="line">	此时会使用新的二进制文件生成新的master进程，老的进程也在使用，两者会平滑的过度；老的进程不会再监听80或者443端口</span><br><span class="line">4.向老的master进程发送信号，优雅的关闭所有进程：kill -WINCH pid。此时老的master进程已经没有了子进程。</span><br><span class="line">	若再想恢复老的版本，可以向master进程发起reload命令（用于做版本回退）</span><br><span class="line"></span><br><span class="line">日志切割：</span><br><span class="line">1.备份原先的日志文件 mv old.log bak.log</span><br><span class="line">2.重新生成日志文件 .&#x2F;nginx -s reopen  会重新生成一个old.log日志文件</span><br><span class="line">	（可以每天或者每周定时执行日志切割）</span><br></pre></td></tr></table></figure>



<h1 id="搭建静态资源服务器"><a href="#搭建静态资源服务器" class="headerlink" title="搭建静态资源服务器"></a>搭建静态资源服务器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搭建静态资源服务器时，可以将下面的内容放在http块下：</span><br><span class="line"># 使用了很多变量，日志格式命名，便于区分不同域名下的日志格式</span><br><span class="line">log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       8081;</span><br><span class="line">        server_name  192.168.0.105;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            alias  docs&#x2F;;</span><br><span class="line">            autoindex  on;  # 显示docs目录结构</span><br><span class="line">        	set $limit_rate 1k; # limit_rate是内置变量，用于限制访问速度，每秒传输多少字节到浏览器中 </span><br><span class="line">            # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">上面的docs就表示静态资源文件夹</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>openrestry的安装</title>
    <url>/blog/2020/08/30/openresty%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>OpenResty 是一个基于 Nginx 的可伸缩的 Web 平台，提供了很多高质量的第三方模块；它也是一个强大的 Web 应用服务器，开发人员可以使用 Lua 脚本语言调用 Nginx 支持的各种 C 以及 Lua 模块。</p>
<p>今天介绍下 OpenResty 在 Ubuntu 1804 上的安装。</p>
<a id="more"></a>

<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>安装依赖时，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install libpcre3-dev libssl-dev perl make build-essential curl</span><br></pre></td></tr></table></figure>

<p>需要注意的是，执行上面的命令时，可能会出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E: py3compile:243: Requested versions are not installed</span><br></pre></td></tr></table></figure>

<p>这是因为我们安装的 python3 版本与 py3compile 不一致引起的，py3compile 是属于 python3-minimal 的，我们只需要安装对应的 python3-minimal 即可。python3-minimal 的下载地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mirrors.edge.kernel.org&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;p&#x2F;python3-defaults&#x2F;</span><br></pre></td></tr></table></figure>

<p>下载完成后，执行以下命令安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i python3-minimal_3.6.7-1~18.04_amd64.deb</span><br></pre></td></tr></table></figure>

<p>安装 python3-minimal 可能还会出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#x2F;python3-minimal.postinst: py3compile: not found</span><br></pre></td></tr></table></figure>

<p>这是因为安装过程中，python3-minimal 会寻找 python3.6（根据安装版本不同而不同），我的系统中 /usr/bin 下只有python3，这时候添加一个 python3.6 的软链接即可。</p>
<h1 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h1><p>依赖安装完成后，可以到以下地址下载相应版本的 OpenResty ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;openresty.org&#x2F;cn&#x2F;download.html</span><br></pre></td></tr></table></figure>

<p>下载完成后，解压缩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzvf openresty-1.17.8.2.tar.gz</span><br></pre></td></tr></table></figure>

<p>执行配置及安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty --with-luajit</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>命令执行完成后，在 /usr/local 下会生成一个 openrestry 目录，里面就行 openrestry 的一些源码文件、配置文件和可执行文件。</p>
<p>其它系统的安装步骤可以参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;openresty.org&#x2F;cn&#x2F;installation.html</span><br></pre></td></tr></table></figure>

<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="hello-world的例子"><a href="#hello-world的例子" class="headerlink" title="hello world的例子"></a>hello world的例子</h2><p>我们可以在 /usr/local/openresty 目录下新建一个文件 conf/openrestry.conf 配置文件，文件内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">error_log</span> logs/error.log;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">                ngx.say("&lt;p&gt;hello, world&lt;/p&gt;")</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动 openrestry 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;conf&#x2F;openrestry.conf</span><br></pre></td></tr></table></figure>

<p>执行命令，请求 openrestry 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:8080&#x2F;</span><br></pre></td></tr></table></figure>

<p>请求后，会返回下面的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;hello, world&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>



<h2 id="接收请求参数"><a href="#接收请求参数" class="headerlink" title="接收请求参数"></a>接收请求参数</h2><p>openresty 中接收客户端请求参数的配置为：</p>
<p>conf/params.conf：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">                local params = ngx.req.get_uri_args();</span></span><br><span class="line"><span class="string">                ngx.print(params.name);</span></span><br><span class="line"><span class="string">                ngx.print(params.age);</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在终端请求 <a href="http://localhost:8080/test/?name=aaa&amp;age=12" target="_blank" rel="noopener">http://localhost:8080/test/?name=aaa&amp;age=12</a> 时，返回的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaa12</span><br></pre></td></tr></table></figure>

<p>ngx.req.get_uri_args 的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">args, err &#x3D; ngx.req.get_uri_args()，用于获取客户端请求 uri 中的参数。</span><br><span class="line"></span><br><span class="line">它的说明文档为：https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;lua-nginx-module#ngxreqget_uri_args</span><br></pre></td></tr></table></figure>

<p>其中，ngx.print() 函数的功能是将参数作为响应体返回给调用的客户端，未返回响应头时，首先返回响应头，再返回响应体。</p>
<p>还有一个 ngx.say() 方法，它与 ngx.print() 方法的功能一样，但是 ngx.say() 最后会返回一个换行符。</p>
<p>上面的方法 ngx.req.get_uri_args() 是接收 get 请求的参数，接收 post 请求参数的配置为：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">                ngx.req.read_body();</span><br><span class="line">                <span class="attribute">local</span> params = ngx.req.get_post_args();</span><br><span class="line">                ngx.say(params.name);</span><br><span class="line">                ngx.say(params.age);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在终端执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:8080&#x2F;test -X POST -d &#39;name&#x3D;aaa&amp;age&#x3D;12&#39;</span><br></pre></td></tr></table></figure>

<p>得到的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaa</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>接收 post 请求使用的是 ngx.req.get_post_args()。，在使用该方法之前，需要调用方法：ngx.req.read_body()。ngx.req.read_body() 的作用是：在不阻塞 nginx event loop 的请求下，异步读取客户端的请求体数据。</p>
<h2 id="内部调用"><a href="#内部调用" class="headerlink" title="内部调用"></a>内部调用</h2><p>在 openresty 中，可以进行内部 location 之间的调用，配置例子如下：</p>
<p>conf/inner.conf：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">                local res = ngx.location.capture(</span></span><br><span class="line"><span class="string">                    "/getname", &#123;args=&#123;name=ngx.var["arg_name"], age=18&#125;&#125;</span></span><br><span class="line"><span class="string">                )</span></span><br><span class="line"><span class="string">                ngx.say(ngx.var["arg_name"]);</span></span><br><span class="line"><span class="string">                ngx.say("status:", res.status, " resp:", res.body)</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /getname &#123;</span><br><span class="line">            <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">                local params = ngx.req.get_uri_args();</span></span><br><span class="line"><span class="string">                ngx.print(params.name);</span></span><br><span class="line"><span class="string">            '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，当访问 <a href="http://localhost:8080/test/?name=xxx" target="_blank" rel="noopener">http://localhost:8080/test/?name=xxx</a> 时，会打印出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxx</span><br><span class="line">status:200 resp:aaa</span><br></pre></td></tr></table></figure>

<p>配置文件中，ngx.location.capture 的作用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">功能：在 nginx 内部调用其它 location 块</span><br><span class="line">语法：res &#x3D; ngx.location.capture(uri, options)</span><br><span class="line">上面的配置文件中，它的作用域是 content_by_lua 开头的模块</span><br><span class="line"></span><br><span class="line">ngx.location.capture 会返回一个 lua table 对象，有以下4个属性：res.status, res.header, res.body, and res.truncated</span><br><span class="line"></span><br><span class="line">ngx.location.capture 的说明文档为：https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;lua-nginx-module#ngxlocationcapture</span><br></pre></td></tr></table></figure>



<h2 id="指定lua脚本文件"><a href="#指定lua脚本文件" class="headerlink" title="指定lua脚本文件"></a>指定lua脚本文件</h2><p>在 openresty 的 location 中，可以指定 lua 脚本来执行，配置例子为：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> = /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">	</span><br><span class="line">            <span class="attribute">content_by_lua_file</span> /usr/local/openresty/lua_code/test.lua;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，使用 content_by_lua_file 来指定请求进来时需要运行的 lua 脚本文件。</p>
<p>test.lua 的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngx.say(&quot;lua test file&quot;);</span><br></pre></td></tr></table></figure>

<p>在终端执行  curl <a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a> 后，会返回 lua test file。</p>
<h2 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis"></a>连接redis</h2><p>openresty 中通过 lua 连接 redis 的例子如下：redis.lua：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- redis use</span><br><span class="line"></span><br><span class="line">local resty_redis &#x3D; require(&#39;resty.redis&#39;)</span><br><span class="line">local redis &#x3D; resty_redis:new()</span><br><span class="line"></span><br><span class="line">redis:settimeout(1000)</span><br><span class="line"></span><br><span class="line">local ok, err &#x3D; redis:connect(&#39;127.0.0.1&#39;, 6379)</span><br><span class="line">if not ok then</span><br><span class="line">        ngx.say(err)</span><br><span class="line">        ngx.eof()</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 连接 redis 后进行密码验证</span><br><span class="line">local res, err &#x3D; redis:auth(&#39;wyzane&#39;)</span><br><span class="line">if not res then</span><br><span class="line">        ngx.say(&quot;failed to auth:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local res, err &#x3D; redis:get(&quot;name&quot;)</span><br><span class="line">if not res then</span><br><span class="line">        ngx.say(&quot;failed to get name:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ngx.say(res)</span><br><span class="line"></span><br><span class="line">local ok, err &#x3D; redis:set_keepalive(10000, 100)</span><br><span class="line">if not ok then</span><br><span class="line">        ngx.say(&quot;failed to set keeplive:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>redis.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line"></span><br><span class="line">        location &#x3D; &#x2F;test &#123;</span><br><span class="line">            default_type text&#x2F;html;</span><br><span class="line">	</span><br><span class="line">            content_by_lua_file &#x2F;home&#x2F;wyzane&#x2F;lua_code&#x2F;redis.lua;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h2><p>openresty 中使用 lua 连接 mysql 的例子如下：mysql.lua：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- mysql use</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> resty_mysql = <span class="built_in">require</span>(<span class="string">"resty.mysql"</span>)</span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">"cjson"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> db, err = resty_mysql:new()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> db <span class="keyword">then</span></span><br><span class="line">        ngx.say(<span class="string">'init mysql failed'</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">db:set_timeout(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ok, err, errcode, sqlstate = db:connect(&#123;</span><br><span class="line">    host = <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    post = <span class="number">3306</span>,</span><br><span class="line">    database = <span class="string">"test_koa"</span>,</span><br><span class="line">    user = <span class="string">"root"</span>,</span><br><span class="line">    password = <span class="string">"wyzane"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.say(<span class="string">"failed to connect mysql:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res, err, errcode, sqlstate = db:query(<span class="string">"select * from tb_user"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span></span><br><span class="line">        nga.say(<span class="string">"query failed:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">db:set_keepalive(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">ngx.say(cjson.encode(res))</span><br></pre></td></tr></table></figure>

<p>mysql.conf：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> = /test &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/html;</span><br><span class="line">	</span><br><span class="line">            <span class="attribute">content_by_lua_file</span> /home/wyzane/lua_code/mysql.lua;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Openresty 官网：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;openresty.org&#x2F;cn&#x2F;</span><br></pre></td></tr></table></figure>

<p>Openresty的 github 地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;openresty</span><br></pre></td></tr></table></figure>

<p>Openresty最佳实践：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.kancloud.cn&#x2F;allanyu&#x2F;openresty-best-practices&#x2F;82658</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>python中描述符的使用</title>
    <url>/blog/2019/11/28/python%E4%B8%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>描述符的官方文档如下，有问题可以查看官方文档。官方文档：<a href="https://docs.python.org/3.7/howto/descriptor.html?highlight=descriptor" target="_blank" rel="noopener">https://docs.python.org/3.7/howto/descriptor.html?highlight=descriptor</a></p>
<a id="more"></a>

<h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><h3 id="描述符介绍"><a href="#描述符介绍" class="headerlink" title="描述符介绍"></a>描述符介绍</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">描述符（descriptor）实际是一种类，但是这个类实现了__set__ __get__ __delete__ 这<span class="number">3</span>个方法中一个或多个。 其中__get__是必须的，其他<span class="number">2</span>个可选。</span><br><span class="line">如果实现中实现了__set__ __get__那么称之为数据描述符</span><br><span class="line">如果只实现了 __get__ 那么称之为非数据描述符</span><br><span class="line">   </span><br><span class="line">   __get__():调用一个属性时,触发</span><br><span class="line">   __set__():为一个属性赋值时,触发</span><br><span class="line">   __delete__():采用<span class="keyword">del</span>删除属性时,触发</span><br><span class="line">   </span><br><span class="line">   描述符作用：实现对属性的代理；在对属性获取，设置，删除时，可以进行额外的操作</span><br><span class="line"></span><br><span class="line">   数据描述符与非数据描述符的区别：</span><br><span class="line">   访问相同属性时，数据描述符优先于instance dictionary;instance dictionary优先于非数据描述符</span><br><span class="line">   </span><br><span class="line">   当然，我们也可以定义只读的数据描述符：</span><br><span class="line">   在类中同时定义__get__和__set__方法，并且在调用__set__方法时，抛出 AttributeError 异常即可。</span><br><span class="line">   </span><br><span class="line">   属性的调用顺序：</span><br><span class="line">   对象属性的调用顺序：</span><br><span class="line">   	在object.__getattribute__()中，会将 obj.x 转换成 type(obj).__dict__[<span class="string">'x'</span>].__get__(obj, type(obj))，再按照 数据描述符 &gt; instance variables &gt; 非数据描述符 &gt;  __getattr__() 的优先级顺序调用</span><br><span class="line">   类属性的调用顺序：</span><br><span class="line">   	type.__getattribute__()中 会将 <span class="class"><span class="keyword">class</span>.<span class="title">x</span> 转换成 <span class="title">B</span>.<span class="title">__dict__</span>['<span class="title">x</span>'].<span class="title">__get__</span><span class="params">(None, B)</span>，类似于下面这种调用：</span></span><br><span class="line"><span class="class">       	<span class="title">def</span> <span class="title">__getattribute__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">               v = object.__getattribute__(self, key)</span><br><span class="line">               <span class="keyword">if</span> hasattr(v, <span class="string">'__get__'</span>):</span><br><span class="line">                   <span class="keyword">return</span> v.__get__(<span class="literal">None</span>, self)</span><br><span class="line">               <span class="keyword">return</span> v</span><br><span class="line">           </span><br><span class="line">   通过上面的介绍，可以总结出下面的几点：</span><br><span class="line">   <span class="number">1.</span> 描述符会在 __getattribute__() 中被调用</span><br><span class="line">   <span class="number">2.</span> 重写 __getattribute__() 方法会阻止描述符的调用</span><br><span class="line">   <span class="number">3.</span> 数据描述符会重写 instance dictionary</span><br><span class="line">   <span class="number">4.</span> 非数据描述符可能会被 instance dictionary 重写</span><br></pre></td></tr></table></figure>



<h3 id="描述符应用场景"><a href="#描述符应用场景" class="headerlink" title="描述符应用场景"></a>描述符应用场景</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 访问属性时进行验证</span><br></pre></td></tr></table></figure>



<h3 id="property的使用"><a href="#property的使用" class="headerlink" title="property的使用"></a>property的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># property是一个描述符类，用于访问属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方式一：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"property get"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"property setter"</span>)</span><br><span class="line">        self._name = name</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Test(<span class="string">"小明"</span>, <span class="number">12</span>)</span><br><span class="line">    print(t.name)</span><br><span class="line">    t.name = <span class="string">"小刘"</span></span><br><span class="line">    print(t.name)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">_get_name</span></span><br><span class="line"><span class="string">小明</span></span><br><span class="line"><span class="string">===============</span></span><br><span class="line"><span class="string">_set_name</span></span><br><span class="line"><span class="string">_get_name</span></span><br><span class="line"><span class="string">小刘</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方式二：</span></span><br><span class="line">调用 property()方法 是创建数据描述符的一种简洁的方法</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_set_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"_set_name"</span>)</span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"_get_name"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用property描述符</span></span><br><span class="line">    name = property(_get_name, _set_name)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Test(<span class="string">"小明"</span>, <span class="number">12</span>)</span><br><span class="line">    print(t.name)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"==============="</span>)</span><br><span class="line">    t.name = <span class="string">"小刘"</span></span><br><span class="line">    print(t.name)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">_get_name</span></span><br><span class="line"><span class="string">小明</span></span><br><span class="line"><span class="string">===============</span></span><br><span class="line"><span class="string">_set_name</span></span><br><span class="line"><span class="string">_get_name</span></span><br><span class="line"><span class="string">小刘</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>对于 property() 如何实现的描述符协议，类似下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"Emulate PyProperty_Type() in Objects/descrobject.c"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></span><br><span class="line">        self.fget = fget</span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line">        <span class="keyword">if</span> doc <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            doc = fget.__doc__</span><br><span class="line">        self.__doc__ = doc</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">"unreadable attribute"</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fget(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">"can't set attribute"</span>)</span><br><span class="line">        self.fset(obj, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">"can't delete attribute"</span>)</span><br><span class="line">        self.fdel(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span><span class="params">(self, fget)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type(self)(fget, self.fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">(self, fset)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type(self)(self.fget, fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleter</span><span class="params">(self, fdel)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type(self)(self.fget, self.fset, fdel, self.__doc__)</span><br></pre></td></tr></table></figure>



<h3 id="描述符的使用"><a href="#描述符的使用" class="headerlink" title="描述符的使用"></a>描述符的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleDescriptor</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            instance: 类对象的实例</span></span><br><span class="line"><span class="string">            owner: 类对象</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> instance:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            instance: 类对象实例</span></span><br><span class="line"><span class="string">            value: 属性值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        name = self.name</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">"age"</span> <span class="keyword">and</span> value &lt; <span class="number">18</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"age less than 18"</span>)</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line"></span><br><span class="line">    name = SimpleDescriptor(<span class="string">"name"</span>)</span><br><span class="line">    age = SimpleDescriptor(<span class="string">"age"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Test(<span class="string">"小明"</span>, <span class="number">12</span>)</span><br><span class="line">    <span class="comment"># print(t.name)</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"============="</span>)</span><br><span class="line">    t.name = <span class="string">"小刘"</span></span><br><span class="line">    t.age = <span class="number">16</span></span><br><span class="line">    print(t.name)</span><br><span class="line">    print(t.age)</span><br></pre></td></tr></table></figure>



<h3 id="描述符的应用"><a href="#描述符的应用" class="headerlink" title="描述符的应用"></a>描述符的应用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 应用在 staticmethod 中 ，staticmethod是一个非数据描述符。下面两段代码片段功能相同</span></span><br><span class="line"><span class="comment"># 代码1：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    E.f(<span class="number">1</span>)</span><br><span class="line">    E().f(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 代码2：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line">    f = staticmethod(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    E.f(<span class="number">1</span>)</span><br><span class="line">    E().f(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 同样的， classmethod 也是一个非数据描述符，下面两段代码功能相同</span></span><br><span class="line"><span class="comment"># 代码1：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(cls, x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    E.f(<span class="number">1</span>)</span><br><span class="line">    E().f(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 代码2：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(cls, x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line">    f = classmethod(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    E.f(<span class="number">1</span>)</span><br><span class="line">    E().f(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<p>以上就是python中描述符的介绍！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python开发中locust库的使用</title>
    <url>/blog/2020/05/05/python%E5%BC%80%E5%8F%91%E4%B8%ADlocust%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>locust是一个易于使用的、分布式的压测工具，今天介绍下python开发中locust的使用。</p>
<a id="more"></a>

<h1 id="locust基础"><a href="#locust基础" class="headerlink" title="locust基础"></a>locust基础</h1><p>安装locust：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install locust</span><br><span class="line"></span><br><span class="line"># 查看是否安装成功</span><br><span class="line">locust --help</span><br></pre></td></tr></table></figure>



<p>locust中的常用类如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Locust</span><br><span class="line">代表请求待测系统的一个用户，使用task_set属性指定用户的行为，task_set属性的值是一个TaskSet类。如果压测http接口，可以使用下面的HttpLocust类。</span><br><span class="line"></span><br><span class="line">HttpLocust</span><br><span class="line">代表请求待测系统的一个http用户，使用task_set属性指定用户的行为，task_set属性的值是一个TaskSet类</span><br><span class="line">HttpLocust的属性：</span><br><span class="line">client：一个HttpSession实例，支持cookie，可以在http请求间保持对话。</span><br><span class="line"></span><br><span class="line">TaskSet</span><br><span class="line">定义一些任务供locust用户调用，TaskSet有下面一些属性：</span><br><span class="line">client: Locust实例中的client属性</span><br><span class="line">tasks: 一些待执行任务的集合，当它是一个列表时，列表中的任务会随机执行；是元祖或者字典时（(callable,int)或者&#123;callable:int&#125;，int是执行的权重）,会根据权重执行任务</span><br><span class="line">max_wait: 任务执行的最大时间间隔</span><br><span class="line">min_wait: 任务执行的最小时间间隔</span><br><span class="line">locust: 当TaskSet类被实例化后，该参数表示一个locust类实例</span><br></pre></td></tr></table></figure>



<h1 id="压测脚本例子"><a href="#压测脚本例子" class="headerlink" title="压测脚本例子"></a>压测脚本例子</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpTest</span><span class="params">(TaskSet)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""初始化</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @task(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hobby_detail</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = json.dumps(self.locust.hobby_detail_data)</span><br><span class="line"></span><br><span class="line">        resp = self.client.post(<span class="string">"/api/v1/hobby/detail"</span>,</span><br><span class="line">                                data=data,</span><br><span class="line">                                headers=self.locust.headers)</span><br><span class="line">        content = json.loads(resp.text, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">        print(<span class="string">"content:"</span>, content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @task(1)  # task参数表示执行权重，值越大，执行概率越高</span></span><br><span class="line">    <span class="comment"># def hobby_list(self):</span></span><br><span class="line">    <span class="comment">#     self.client.post("/api/v1/hobby/list")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpUser</span><span class="params">(HttpLocust)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># locust -f test.py --host=http://192/168/0/102:8001 --port=8090</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 待请求地址，也可以在命令行中使用--host参数指定</span></span><br><span class="line">    host = <span class="string">"http://192.168.0.102:8002"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定TaskSet类</span></span><br><span class="line">    task_set = HttpTest</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求头</span></span><br><span class="line">    headers = &#123;<span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求参数</span></span><br><span class="line">    hobby_detail_data = &#123;</span><br><span class="line">        <span class="string">"hobbyId"</span>: <span class="number">57</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个用户执行两个任务的时间间隔(单位: 毫秒)，</span></span><br><span class="line">    <span class="comment"># 上下限，具体值随机取，默认间隔位固定值1s</span></span><br><span class="line">    min_wait = <span class="number">1000</span></span><br><span class="line">    max_wait = <span class="number">3000</span></span><br></pre></td></tr></table></figure>



<h1 id="命令行测试"><a href="#命令行测试" class="headerlink" title="命令行测试"></a>命令行测试</h1><p>在命令行中输入以下命令进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locust -f test.py --host&#x3D;http:&#x2F;&#x2F;192.168.0.102:8001 --port&#x3D;8089</span><br></pre></td></tr></table></figure>

<p>在命令行中测试时，还可以提供以下参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locust -f test.py --csv&#x3D;foobar --no-web -c2 -t10s</span><br><span class="line"></span><br><span class="line"># --no-web：不使用web界面测试</span><br><span class="line"># --cvs: 测试结果的位置</span><br><span class="line"># -c: 设置虚拟用户数</span><br><span class="line"># -r: 设置每秒启动用户数</span><br><span class="line"># -t: 设置运行时间</span><br></pre></td></tr></table></figure>



<h1 id="浏览器测试"><a href="#浏览器测试" class="headerlink" title="浏览器测试"></a>浏览器测试</h1><p>我们也可以在 locust 为我们提供的管理控制台上进行测试。 在浏览器中访问地址 <a href="http://localhost:8089/" target="_blank" rel="noopener">http://localhost:8089/</a> 可以进入 locust 的界面，填入Number of users to simulate和Hatch rate参数（分别表示虚拟用户数量和每秒产生的用户数量），然后点击Start swarming，即可开始测试工作。</p>
<h1 id="分布式测试"><a href="#分布式测试" class="headerlink" title="分布式测试"></a>分布式测试</h1><p>locust也支持分布式测试。主从机中必须运行相同的测试代码（把主机中代码复制一份到多个从机中），主机负责收集测试数据，从机进行施压测试；</p>
<p>在主机终端中执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locust -f test.py --master</span><br></pre></td></tr></table></figure>

<p>从机终端执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locust -f  test.py --slave --master-host&#x3D;master ip</span><br></pre></td></tr></table></figure>

<p>开始测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locust -f test.py  --csv&#x3D;foobartt --no-web -c2 -t10s --master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python开发中django和tornado框架的异同</title>
    <url>/blog/2020/05/30/python%E5%BC%80%E5%8F%91%E4%B8%ADdjango%E5%92%8Ctornado%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>python中常用的几个web框架有django, tornado, flask等，今天来总结一下django和tornado的不同。</p>
<a id="more"></a>

<p>工作中django和tornado都用过，使用django相对更多一些。个人感觉django虽然好用，有搭建项目快、自带ORM、自动生成路由、自带管理后台等优势；但若实际工作中选择，我还是会偏向于使用tornado框架，因为torndo使用更加灵活，并且支持websocket,tcp等通信协议,最重要的是tornado是异步非阻塞的web框架；而在django中要实现websocket、异步非阻塞等功能则需要引入dwebsocket、celery等第三方模块。</p>
<p>本文使用的环境是python3.6, django2.0, tornado5.1。</p>
<p>下面主要从以下几个方面介绍一下这两个框架的不同：<br>1.创建项目的方式<br>2.数据库连接<br>3.异步非阻塞请求<br>4.websocket的使用</p>
<h1 id="项目创建方式"><a href="#项目创建方式" class="headerlink" title="项目创建方式"></a>项目创建方式</h1><h2 id="django"><a href="#django" class="headerlink" title="django"></a>django</h2><p>django主要是通过下面两个命令创建项目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">django-admin startproject Test  <span class="comment"># 创建项目，名称为Test</span></span><br><span class="line">django-admin startpapp Test01   <span class="comment"># 创建app，名称为Test01</span></span><br></pre></td></tr></table></figure>

<p>执行完成后，会生成如下的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:.</span><br><span class="line">│  manage.py</span><br><span class="line">│  test.txt</span><br><span class="line">│  </span><br><span class="line">├─.idea</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  │  Test.iml</span><br><span class="line">│  │  workspace.xml</span><br><span class="line">│  │  </span><br><span class="line">│  └─inspectionProfiles</span><br><span class="line">│          profiles_settings.xml</span><br><span class="line">│          </span><br><span class="line">├─Test</span><br><span class="line">│      settings.py</span><br><span class="line">│      urls.py</span><br><span class="line">│      wsgi.py</span><br><span class="line">│      __init__.py</span><br><span class="line">│      </span><br><span class="line">└─Test01</span><br><span class="line">    │  admin.py</span><br><span class="line">    │  apps.py</span><br><span class="line">    │  models.py</span><br><span class="line">    │  tests.py</span><br><span class="line">    │  views.py</span><br><span class="line">    │  __init__.py</span><br><span class="line">    │  </span><br><span class="line">    └─migrations</span><br><span class="line">            __init__.py</span><br></pre></td></tr></table></figure>

<p>主要是manage.py,Test,Test01这几个文件和文件夹，<br>manage.py是管理项目的文件，通过它运行django的一些内置命令，如模型迁移、启动项目等；<br>Test/settings.py是配置文件，项目配置存放在这里<br>Test/urls.py是路由文件，负责分发http请求<br>Test01/models.py是模型文件，Test01下创建的模型就放在这里，模型负责将表结构映射到数据库中<br>Test01/views.py是视图文件，django中的视图在这里定义<br>Test01/migrations目录中存放迁移后生成的迁移文件。<br>django项目的基本结构就是这样。</p>
<h2 id="tornado"><a href="#tornado" class="headerlink" title="tornado"></a>tornado</h2><p>tornado项目的创建比较灵活，没有什么项目名称和app的概念，全靠自己组织项目，就是创建一个个python文件和python package。可以像下面一样来组织tornado项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── App</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── Shop</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   └── views.py</span><br><span class="line">│   └── User</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       └── views.py</span><br><span class="line">├── application.py</span><br><span class="line">├── Config</span><br><span class="line">│   ├── config_base.py</span><br><span class="line">│   ├── config_db.conf</span><br><span class="line">│   ├── config_db_get.py</span><br><span class="line">│   ├── config_engine.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">├── Models</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── Shop</span><br><span class="line">│   │   └── __init__.py</span><br><span class="line">│   └── User</span><br><span class="line">│       ├── BaseClass.py</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       └── UserModel.py</span><br><span class="line">├── server.py</span><br><span class="line">├── static</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── templates</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── test.py</span><br><span class="line">└── Urls</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── Shop.py</span><br><span class="line">    └── User.py</span><br></pre></td></tr></table></figure>

<p>这里有几个主要文件App, Config, Models, Urls, static, templates, application.py, server.py。<br>项目的app可以集中放在App目录中，与数据库对应的模型文件可以放在Models中，http路由可以放在Urls中，项目配置信息可以放在Config目录中，静态文件和模板分别放在static和templates中。application.py文件可以加载路由信息和项目配置信息，server.py文件负责启动项目。<br>项目的基本配置信息可以放在Config/config_base.py中，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(__file__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">options = &#123;</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">8001</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本配置信息</span></span><br><span class="line">settings = &#123;</span><br><span class="line">    <span class="string">"debug"</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">"static_path"</span>: os.path.join(BASE_DIR, <span class="string">"static"</span>),</span><br><span class="line">    <span class="string">"template_path"</span>: os.path.join(BASE_DIR, <span class="string">"templates"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由信息可以放在Urls/User.py中，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> App.UserInfo <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_urls = [</span><br><span class="line">    (<span class="string">r'/user/'</span>, views.IndexHandler),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>application.py中加载路由信息和配置信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Config.config_base <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> Urls.UserInfo <span class="keyword">import</span> user_urls</span><br><span class="line"><span class="keyword">from</span> Urls.Shop <span class="keyword">import</span> shop_urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">路由配置</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span><span class="params">(web.Application)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        urls = user_urls + shop_urls</span><br><span class="line">        super(Application, self).__init__(urls, **settings)</span><br></pre></td></tr></table></figure>

<p>最后在server.py中启动项目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop, httpserver</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> application <span class="keyword">import</span> Application</span><br><span class="line"><span class="keyword">from</span> Config <span class="keyword">import</span> config_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = Application()</span><br><span class="line">    http_server = httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(config_base.options.get(<span class="string">"port"</span>))</span><br><span class="line"></span><br><span class="line">    ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure>



<h1 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h1><h2 id="django-1"><a href="#django-1" class="headerlink" title="django"></a>django</h2><p>django中使用数据库时，首先要在settings.py中配置数据库信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,   <span class="comment"># 数据库引擎</span></span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django_test'</span>,                  <span class="comment"># 你要存储数据的库名，事先要创建之</span></span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,                         <span class="comment"># 数据库用户名</span></span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'test'</span>,                     <span class="comment"># 密码</span></span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'localhost'</span>,                    <span class="comment"># 主机</span></span><br><span class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span>,                         <span class="comment"># 数据库使用的端口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在每个app下编写完models.py后，执行以下两个命令后，就可以使用数据库了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>可以调用模型管理器对象objects的相应方法，执行增删改查等操作。</p>
<h2 id="tornado-1"><a href="#tornado-1" class="headerlink" title="tornado"></a>tornado</h2><p>这里说一下在tornado中使用sqlalchemy连接数据库，需要安装sqlalchemy和pymysql。</p>
<h3 id="首先在Config-config-db-conf中配置数据库信息"><a href="#首先在Config-config-db-conf中配置数据库信息" class="headerlink" title="首先在Config/config_db.conf中配置数据库信息"></a>首先在Config/config_db.conf中配置数据库信息</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[db_user]</span></span><br><span class="line"><span class="attr">name</span> = db_tornado03</span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">user</span> = root</span><br><span class="line"><span class="attr">host</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">pass</span> = test</span><br><span class="line"><span class="attr">pool_size</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="然后在Config-config-engine-py中配置engine"><a href="#然后在Config-config-engine-py中配置engine" class="headerlink" title="然后在Config/config_engine.py中配置engine"></a>然后在Config/config_engine.py中配置engine</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Config.config_db_get <span class="keyword">import</span> ConfigDBUser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库配置信息 可以配置多个engine, 每个数据库对应一个engine</span></span><br><span class="line">db_user = ConfigDBUser(<span class="string">"db_user"</span>)</span><br><span class="line">engine_user = create_engine(</span><br><span class="line">    <span class="string">"mysql+pymysql://%s:%s@%s:%d/%s"</span> % (</span><br><span class="line">        db_user.get_db_user(),</span><br><span class="line">        db_user.get_db_pass(),</span><br><span class="line">        db_user.get_db_host(),</span><br><span class="line">        db_user.get_db_port(),</span><br><span class="line">        db_user.get_db_database()</span><br><span class="line">    ),</span><br><span class="line">    encoding=<span class="string">'utf-8'</span>,</span><br><span class="line">    echo=<span class="literal">True</span>,</span><br><span class="line">    pool_size=<span class="number">20</span>,</span><br><span class="line">    pool_recycle=<span class="number">100</span>,</span><br><span class="line">    connect_args=&#123;<span class="string">"charset"</span>: <span class="string">'utf8mb4'</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>create_engine用来初始化数据库连接。</p>
<h3 id="在Models-UserInfo-BaseClass-py中配置连接数据库的session信息"><a href="#在Models-UserInfo-BaseClass-py中配置连接数据库的session信息" class="headerlink" title="在Models/UserInfo/BaseClass.py中配置连接数据库的session信息"></a>在Models/UserInfo/BaseClass.py中配置连接数据库的session信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> scoped_session, sessionmaker</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Config.config_engine <span class="keyword">import</span> engine_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 创建session对象，并且用scoped_session维护session对象</span></span><br><span class="line">        <span class="comment"># 数据库的增删改查通过session对象来完成</span></span><br><span class="line">        self.engine_user = scoped_session(</span><br><span class="line">            sessionmaker(</span><br><span class="line">                bind=engine_user,</span><br><span class="line">                autocommit=<span class="literal">False</span>,</span><br><span class="line">                autoflush=<span class="literal">True</span>,</span><br><span class="line">                expire_on_commit=<span class="literal">False</span></span><br><span class="line">            )</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h3 id="在Models-UserInfo-UserModel-py中配置模型信息，用于映射到数据库中对应的表"><a href="#在Models-UserInfo-UserModel-py中配置模型信息，用于映射到数据库中对应的表" class="headerlink" title="在Models/UserInfo/UserModel.py中配置模型信息，用于映射到数据库中对应的表"></a>在Models/UserInfo/UserModel.py中配置模型信息，用于映射到数据库中对应的表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, MetaData</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Config.config_engine <span class="keyword">import</span> engine_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseModel = declarative_base()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_model</span><span class="params">(table_name)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">        __tablename__ = table_name</span><br><span class="line">        metadata = MetaData(engine_user)</span><br><span class="line"></span><br><span class="line">        Table(__tablename__, metadata, autoload=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> UserModel</span><br></pre></td></tr></table></figure>

<p>配置模型信息前，需要在数据库中把表创建好，这是就需要写sql语句创建表了。对于熟练sql的同学，写sql语句应该不算什么；对应不熟悉sql的同学，可能更习惯于django中那种创建表的方式。</p>
<h3 id="在视图中使用"><a href="#在视图中使用" class="headerlink" title="在视图中使用"></a>在视图中使用</h3><p>App/UserInfo/views.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">from</span> Models.UserInfo.BaseClass <span class="keyword">import</span> BaseClass</span><br><span class="line"><span class="keyword">from</span> Models.UserInfo.UserModel <span class="keyword">import</span> user_model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoHandler</span><span class="params">(web.RequestHandler, BaseClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取用户信息</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># user_model中的参数对应数据库中的表名</span></span><br><span class="line">        user_info = user_model(<span class="string">"user_info"</span>)</span><br><span class="line">        <span class="comment"># 获取参数</span></span><br><span class="line">        user_id = self.get_query_argument(<span class="string">"id"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># self.engine_user其实就是一个session对象；query()方法会返回一个query.Query对象，通过这个对象查询数据库</span></span><br><span class="line">        user_info_obj = self.engine_user.query(user_info).filter(user_info.id==user_id).first()</span><br><span class="line">        self.write(user_info_obj.name)</span><br><span class="line">        self.finish()</span><br></pre></td></tr></table></figure>

<h3 id="最后配置路由"><a href="#最后配置路由" class="headerlink" title="最后配置路由"></a>最后配置路由</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Urls/UserInfo.py：</span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> App.UserInfo <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_urls = [</span><br><span class="line">    (<span class="string">r'/userinfo'</span>, views.UserInfoHandler),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">application.py:</span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Config.config_base <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> Urls.UserInfo <span class="keyword">import</span> user_urls</span><br><span class="line"><span class="keyword">from</span> Urls.Shop <span class="keyword">import</span> shop_urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">路由配置</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span><span class="params">(web.Application)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        urls = user_urls + shop_urls</span><br><span class="line">        super(Application, self).__init__(urls, **settings)</span><br></pre></td></tr></table></figure>

<p>启动服务后，就可以访问了。</p>
<h1 id="异步非阻塞请求"><a href="#异步非阻塞请求" class="headerlink" title="异步非阻塞请求"></a>异步非阻塞请求</h1><h2 id="django-2"><a href="#django-2" class="headerlink" title="django"></a>django</h2><p>django中可以通过celery来实现异步任务，也可以使用asyncio和aiohttp实现异步。下面讲一下celery的使用:<br>首先需要安装 celery和 django-celery，使用pip安装就行了；<br>然后在zsettings.py中进行如下配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在INSTALLED_APPS中加入djcelery。</span><br><span class="line"><span class="keyword">import</span> djcelery</span><br><span class="line"><span class="comment"># Celery便会去查看INSTALLD_APPS下包含的所有app目录中的tasks.py文件，找到标记为task的方法，将它们注册为celery task</span></span><br><span class="line">djcelery.setup_loader()</span><br><span class="line">BROKER_URL = <span class="string">'redis://127.0.0.1:6379/2'</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://127.0.0.1:6379/3'</span>  </span><br><span class="line"><span class="comment"># 或者使用rabbitmq: </span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://test:test@192.168.173.1:5672/testhost'</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'amqp://test:test@192.168.173.1:5672/testhost'</span></span><br></pre></td></tr></table></figure>

<p>在需要使用异步的app中创建tasks.py文件，然后编辑该文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> task</span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    预处理</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>耗时的任务就可以放在使用@task修饰的函数中<br>在views.py中调用tasks.py中的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> .tasks <span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CeleryTrainView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">                ret = test.delay(str(i))</span><br><span class="line">                print(<span class="string">"ret:"</span>, ret)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> Response(dict(msg=str(e), code=<span class="number">10001</span>))</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>

<p>上面的结果ret是一个AsyncResult对象，可以通过这个对象拿到保存在CELERY_RESULT_BACKEND中的结果。如果想立即得到结果，可以直接调用get()方法，但是这样就会阻塞其他请求，直到结果返回：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> .tasks <span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CeleryTrainView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">                ret = test.delay(str(i))</span><br><span class="line">                print(<span class="string">"ret:"</span>, ret.get())</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> Response(dict(msg=str(e), code=<span class="number">10001</span>))</span><br><span class="line">        <span class="keyword">return</span> Response(dict(msg=<span class="string">"OK"</span>, code=<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>

<p>最后启动celery：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先启动服务器</span></span><br><span class="line">python manage.py runserver</span><br><span class="line"><span class="comment">#再启动worker </span></span><br><span class="line">python manage.py celery worker</span><br></pre></td></tr></table></figure>



<h2 id="tornado-2"><a href="#tornado-2" class="headerlink" title="tornado"></a>tornado</h2><p>tornado中实现异步有回调和协程这两种方式，这里只举一个协程实现异步的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        client = AsyncHTTPClient()</span><br><span class="line">        url = <span class="string">'http://ip.taobao.com/service/getIpInfo.php?ip=14.130.112.24'</span></span><br><span class="line">        <span class="comment"># 根据ip地址获取相关信息</span></span><br><span class="line">        resp = <span class="keyword">yield</span> client.fetch(url)</span><br><span class="line">        data = str(resp.body, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">        print(<span class="string">"data:"</span>, data)</span><br><span class="line">        self.write(data)</span><br><span class="line">        self.finish()</span><br></pre></td></tr></table></figure>

<p>或者像下面这样，把获取ip信息的部分封装成一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        ip_info = <span class="keyword">yield</span> self.get_ip_info()</span><br><span class="line">        self.write(ip_info)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ip_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        client = AsyncHTTPClient()</span><br><span class="line">        url = <span class="string">'http://ip.taobao.com/service/getIpInfo.php?ip=14.130.112.24'</span></span><br><span class="line">        resp = <span class="keyword">yield</span> client.fetch(url)</span><br><span class="line">        data = str(resp.body, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>也可以同时发起多个异步请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        ips = [</span><br><span class="line">            <span class="string">"14.130.112.24"</span>,</span><br><span class="line">            <span class="string">"14.130.112.23"</span>,</span><br><span class="line">            <span class="string">"14.130.112.22"</span></span><br><span class="line">        ]</span><br><span class="line">        info1, info2, info3 = <span class="keyword">yield</span> [self.get_ip_info(ips[<span class="number">0</span>]), self.get_ip_info(ips[<span class="number">1</span>]), self.get_ip_info(ips[<span class="number">2</span>])]</span><br><span class="line">        self.write(info1)</span><br><span class="line">        self.write(info2)</span><br><span class="line">        self.write(info3)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ip_info</span><span class="params">(self, ip)</span>:</span></span><br><span class="line">        client = AsyncHTTPClient()</span><br><span class="line">        url = <span class="string">'http://ip.taobao.com/service/getIpInfo.php?ip='</span> + ip</span><br><span class="line">        resp = <span class="keyword">yield</span> client.fetch(url)</span><br><span class="line">        data = str(resp.body, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>AsyncHTTPClient的fetch()方法有两种调用方式，一种是像上面那样只传入一个url的字符串，另一种是接收一个HTTPRequest对象作为参数，像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_info</span><span class="params">(self, ip)</span>:</span></span><br><span class="line">    client = AsyncHTTPClient()</span><br><span class="line">    url = <span class="string">'http://ip.taobao.com/service/getIpInfo.php?ip='</span> + ip</span><br><span class="line">    header = &#123;<span class="string">'Accept'</span>: <span class="string">'application/json;charset=utf-8'</span>,</span><br><span class="line">              <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded;charset=utf-8'</span>&#125;</span><br><span class="line">    param1 = <span class="string">'test'</span></span><br><span class="line">    http_request = HTTPRequest(url=url,</span><br><span class="line">                               method=<span class="string">'POST'</span>,</span><br><span class="line">                               headers=header,</span><br><span class="line">                               body=urlencode(&#123;<span class="string">'param1'</span>: param1&#125;))</span><br><span class="line">    resp = <span class="keyword">yield</span> client.fetch(http_request)</span><br><span class="line">    data = str(resp.body, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<h1 id="websocket的使用"><a href="#websocket的使用" class="headerlink" title="websocket的使用"></a>websocket的使用</h1><h2 id="django-3"><a href="#django-3" class="headerlink" title="django"></a>django</h2><p>django中使用websocket需要安装第三方包dwebsocket。</p>
<h2 id="tornado-3"><a href="#tornado-3" class="headerlink" title="tornado"></a>tornado</h2><p>tornado中实现websocket功能需要用到tornado.websocket模块，主要有以下几个方法：open(), write_message(), on_message(), on_close()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">open(): 当websocket客户端连接时所做的操作</span><br><span class="line">write_message(): 使用这个方法向客户端发送消息</span><br><span class="line">on_message(): 接收并处理客户端的消息</span><br><span class="line">on_close(): websocket关闭连接时所作的操作</span><br></pre></td></tr></table></figure>

<p>下面看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">views.py:</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.render(<span class="string">"chat.html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatHandler</span><span class="params">(websocket.WebSocketHandler)</span>:</span></span><br><span class="line">    clients = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.clients.add(self)</span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> self.clients:</span><br><span class="line">            client.write_message(<span class="string">"%s上线了"</span> % self.request.remote_ip)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> self.clients:</span><br><span class="line">            client.write_message(<span class="string">"%s: %s"</span> % (self.request.remote_ip, message))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.clients.remove(self)</span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> self.clients:</span><br><span class="line">            client.write_message(<span class="string">"%s下线了"</span> % self.request.remote_ip)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_origin</span><span class="params">(self, origin)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用于处理跨域问题</span></span><br><span class="line"><span class="string">        :param origin:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>路由：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> App.UserInfo <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_urls = [</span><br><span class="line">    (<span class="string">r'/index'</span>, views.IndexHandler),</span><br><span class="line">    (<span class="string">r'/chat'</span>, views.ChatHandler),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>chat.html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>聊天室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span> <span class="attr">style</span>=<span class="string">"height: 500px;overflow: auto;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">onclick</span>=<span class="string">"sendMsg()"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;&#123; static_url('js/jquery.min.js') &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://192.168.1.104:8001/chat"</span>);</span></span><br><span class="line"><span class="actionscript">        ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#content"</span>).append(<span class="string">"&lt;p&gt;"</span>+ data.data +<span class="string">"&lt;/p&gt;"</span>)</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = $(<span class="string">"#msg"</span>).val();</span></span><br><span class="line">            if (msg) &#123;</span><br><span class="line">                ws.send(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面一个例子通过websocket实现了简单的聊天室功能。</p>
<p>以上就简单的比较了django和tornado几个方面的不同，它们各有优缺点，实际工作中可以根据不同的需求选择不同的框架进行开发。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>python开发之使用Redis实现发布订阅功能</title>
    <url>/blog/2020/05/30/python%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>redis中的发布/订阅模型是一种消息通信模式，今天聊一下在python中实现简单的发布订阅功能。</p>
<a id="more"></a>

<h1 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h1><p>redis_helper.py：封装发布订阅方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisHelper</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__conn = redis.Redis(host=<span class="string">"localhost"</span>)</span><br><span class="line">        <span class="comment"># 订阅频道</span></span><br><span class="line">        self.chan_sub = <span class="string">"fm104.5"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在指定频道上发布消息</span></span><br><span class="line"><span class="string">        :param msg:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># publish(): 在指定频道上发布消息，返回订阅者的数量</span></span><br><span class="line">        self.__conn.publish(self.chan_sub, msg)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回发布订阅对象，通过这个对象你能1）订阅频道 2）监听频道中的消息</span></span><br><span class="line">        pub = self.__conn.pubsub()</span><br><span class="line">        <span class="comment"># 订阅频道，与publish()中指定的频道一样。消息会发布到这个频道中</span></span><br><span class="line">        pub.subscribe(self.chan_sub)</span><br><span class="line">        ret = pub.parse_response()  <span class="comment"># [b'subscribe', b'fm86', 1]</span></span><br><span class="line">        print(<span class="string">"ret:%s"</span> % ret)</span><br><span class="line">        <span class="keyword">return</span> pub</span><br></pre></td></tr></table></figure>



<p>redis_pub.py： 发布者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis_helper <span class="keyword">import</span> RedisHelper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = RedisHelper()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    obj.public(<span class="string">"hello_%s"</span> % i)</span><br></pre></td></tr></table></figure>

<p>redis_sub.py： 订阅者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis_helper <span class="keyword">import</span> RedisHelper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = RedisHelper()</span><br><span class="line">redis_sub = obj.subscribe()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = redis_sub.parse_response()</span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>

<h1 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a>实现方式二</h1><p>redis_helper.py： 封装发布订阅方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisHelper</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__conn = redis.Redis(host=<span class="string">"localhost"</span>)</span><br><span class="line">        <span class="comment"># 频道名称</span></span><br><span class="line">        self.chan_sub = <span class="string">"orders"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在指定频道上发布消息</span></span><br><span class="line"><span class="string">        :param msg:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># publish(): 在指定频道上发布消息，返回订阅者的数量</span></span><br><span class="line">        self.__conn.publish(self.chan_sub, msg)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回发布订阅对象，通过这个对象你能1）订阅频道 2）监听频道中的消息</span></span><br><span class="line">        pub = self.__conn.pubsub()</span><br><span class="line">        <span class="comment"># 订阅某个频道，与publish()中指定的频道一样。消息会发布到这个频道中</span></span><br><span class="line">        pub.subscribe(self.chan_sub)</span><br><span class="line">        <span class="keyword">return</span> pub</span><br></pre></td></tr></table></figure>

<p>redis_pub.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis_helper <span class="keyword">import</span> RedisHelper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = RedisHelper()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    obj.public(<span class="string">"hello_%s"</span> % i)</span><br></pre></td></tr></table></figure>

<p>redis_sub.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis_helper <span class="keyword">import</span> RedisHelper</span><br><span class="line"></span><br><span class="line">obj = RedisHelper()</span><br><span class="line">redis_sub = obj.subscribe()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># listen()函数封装了parse_response()函数</span></span><br><span class="line">    msg = redis_sub.listen()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> msg:</span><br><span class="line">        <span class="keyword">if</span> i[<span class="string">"type"</span>] == <span class="string">"message"</span>:</span><br><span class="line">            print(str(i[<span class="string">"channel"</span>], encoding=<span class="string">"utf-8"</span>) + <span class="string">":"</span> + str(i[<span class="string">"data"</span>], encoding=<span class="string">"utf-8"</span>))</span><br><span class="line">        <span class="keyword">elif</span> i[<span class="string">"type"</span>] == <span class="string">"subscrube"</span>:</span><br><span class="line">            print(str(i[<span class="string">"chennel"</span>], encoding=<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure>

<p>以上两种方式的不同之处在于，方式一使用发布订阅对象的parse_response()方法获取订阅信息，方式二使用发布订阅对象的listen()方法获取订阅信息。listen()方法是对parse_response()方法的封装，加入了阻塞，并将parse_response()返回的结果进行了处理，使结果更加简单。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>tornado开发之使用tcpserver和tcpclient实现echo服务器</title>
    <url>/blog/2020/05/30/tornado%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BD%BF%E7%94%A8tcpserver%E5%92%8Ctcpclient%E5%AE%9E%E7%8E%B0echo%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>本文主要介绍了在tornado框架中使用tcpserver,tcpclient,struct.pack(),struct.unpack实现简单echo服务器的过程。</p>
<a id="more"></a>

<p>在网络通信中，需要发送二进制流数据；struct.pack()函数负责数据组包，即将数据按照规定的传输协议组合起来；struct.unpack()函数负责数据拆包，即按照规定的协议将数据拆分开来。</p>
<p>不多说，具体实现代码咱们来看一下。</p>
<p>tcp客户端代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, port)</span>:</span></span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stream = <span class="keyword">yield</span> TCPClient().connect(self.host, self.port)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> self.send_message()</span><br><span class="line">            <span class="keyword">yield</span> self.receive_message()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 待发送数据</span></span><br><span class="line">        msg = input(<span class="string">"输入:"</span>)</span><br><span class="line">        bytes_msg = bytes(msg.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">        <span class="comment"># 消息发送者</span></span><br><span class="line">        chat_id = <span class="number">10000000</span></span><br><span class="line">        <span class="comment"># 消息接收者</span></span><br><span class="line">        receive_id = <span class="number">10000001</span></span><br><span class="line">        <span class="comment"># 消息类型 1-文本 2-图片 3-语音 4-视频 等</span></span><br><span class="line">        msg_type = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        binary_msg = struct.pack(<span class="string">"!IIBI"</span>+str(len(msg))+<span class="string">"s"</span>, chat_id, receive_id, msg_type, len(msg), bytes_msg)</span><br><span class="line">        <span class="comment"># 发送数据</span></span><br><span class="line">        <span class="keyword">yield</span> self.stream.write(binary_msg)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive_message</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        接收数据</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            logger.debug(<span class="string">"receive data ..."</span>)</span><br><span class="line">            <span class="comment"># 消息发送者 4字节</span></span><br><span class="line">            sender = <span class="keyword">yield</span> self.stream.read_bytes(<span class="number">4</span>, partial=<span class="literal">True</span>)</span><br><span class="line">            sender = struct.unpack(<span class="string">'!I'</span>, sender)[<span class="number">0</span>]</span><br><span class="line">            logger.debug(<span class="string">"sender:%s"</span>, sender)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 消息类型 1字节</span></span><br><span class="line">            msg_type = <span class="keyword">yield</span> self.stream.read_bytes(<span class="number">1</span>, partial=<span class="literal">True</span>)</span><br><span class="line">            msg_type = struct.unpack(<span class="string">'!B'</span>, msg_type)[<span class="number">0</span>]</span><br><span class="line">            logger.debug(<span class="string">"msg_type:%s"</span>, msg_type)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 消息长度 4字节</span></span><br><span class="line">            msg_len = <span class="keyword">yield</span> self.stream.read_bytes(<span class="number">4</span>, partial=<span class="literal">True</span>)</span><br><span class="line">            msg_len = struct.unpack(<span class="string">'!I'</span>, msg_len)[<span class="number">0</span>]</span><br><span class="line">            logger.debug(<span class="string">"msg_len:%s"</span>, msg_len)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 真实数据</span></span><br><span class="line">            data = <span class="keyword">yield</span> self.stream.read_bytes(msg_len, partial=<span class="literal">True</span>)</span><br><span class="line">            data = struct.unpack(<span class="string">"!"</span> + str(msg_len) + <span class="string">"s"</span>, data)</span><br><span class="line">            logger.debug(<span class="string">"data:%s"</span>, data)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">"tcp client exception:%s"</span>, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    c1 = ChatClient(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>)</span><br><span class="line">    c1.start()</span><br><span class="line">    ioloop.IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>tcp服务端代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.tcpserver <span class="keyword">import</span> TCPServer</span><br><span class="line"><span class="keyword">from</span> tornado.netutil <span class="keyword">import</span> bind_sockets</span><br><span class="line"><span class="keyword">from</span> tornado.iostream <span class="keyword">import</span> StreamClosedError</span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">tcpserver-struct.unpack()拆包</span></span><br><span class="line"><span class="string">接收数据包格式:消息头+消息体</span></span><br><span class="line"><span class="string">消息头:消息发送者(4字节)+消息接收者(4字节)+消息类型(1字节)+消息体中数据长度(4字节)</span></span><br><span class="line"><span class="string">消息体:待接收数据</span></span><br><span class="line"><span class="string">struct.pack()组包</span></span><br><span class="line"><span class="string">转发数据包格式:消息头+消息体</span></span><br><span class="line"><span class="string">消息头:消息发送者(4字节)+消息类型(1字节)+消息体中数据长度(4字节)</span></span><br><span class="line"><span class="string">消息体:待发送数据</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span><span class="params">(TCPServer)</span>:</span></span><br><span class="line"></span><br><span class="line">    PORT = <span class="number">8888</span></span><br><span class="line">    clients = dict()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_stream</span><span class="params">(self, stream, address)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        数据拆包并解析</span></span><br><span class="line"><span class="string">        :param stream:</span></span><br><span class="line"><span class="string">        :param address:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logger.debug(<span class="string">"%s已上线"</span>, address)</span><br><span class="line">        ChatServer.clients[address] = stream</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># !表示使用大端方式解析数据</span></span><br><span class="line">                <span class="comment"># 消息发送者 4字节</span></span><br><span class="line">                sender = <span class="keyword">yield</span> stream.read_bytes(<span class="number">4</span>, partial=<span class="literal">True</span>)</span><br><span class="line">                sender = struct.unpack(<span class="string">'!I'</span>, sender)[<span class="number">0</span>]</span><br><span class="line">                logger.debug(<span class="string">"sender:%s"</span>, sender)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 消息接收者 4字节</span></span><br><span class="line">                receiver = <span class="keyword">yield</span> stream.read_bytes(<span class="number">4</span>, partial=<span class="literal">True</span>)</span><br><span class="line">                receiver = struct.unpack(<span class="string">'!I'</span>, receiver)[<span class="number">0</span>]</span><br><span class="line">                logger.debug(<span class="string">"receiver:%s"</span>, receiver)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 消息类型 1字节</span></span><br><span class="line">                msg_type = <span class="keyword">yield</span> stream.read_bytes(<span class="number">1</span>, partial=<span class="literal">True</span>)</span><br><span class="line">                msg_type = struct.unpack(<span class="string">'!B'</span>, msg_type)[<span class="number">0</span>]</span><br><span class="line">                logger.debug(<span class="string">"msg_type:%s"</span>, msg_type)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 消息长度 4字节</span></span><br><span class="line">                msg_len = <span class="keyword">yield</span> stream.read_bytes(<span class="number">4</span>, partial=<span class="literal">True</span>)</span><br><span class="line">                msg_len = struct.unpack(<span class="string">'!I'</span>, msg_len)[<span class="number">0</span>]</span><br><span class="line">                logger.debug(<span class="string">"msg_len:%s"</span>, msg_len)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> msg_type == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 文本信息处理</span></span><br><span class="line">                    logger.debug(<span class="string">"text message ..."</span>)</span><br><span class="line">                    self.handle_text_stream(stream, sender, msg_len)</span><br><span class="line">                <span class="keyword">elif</span> msg_type == <span class="number">2</span>:</span><br><span class="line">                    logger.debug(<span class="string">"picture message ..."</span>)</span><br><span class="line">                    self.handle_pic_stream(stream, sender, msg_len)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> StreamClosedError:</span><br><span class="line">                logger.debug(<span class="string">"%s已下线"</span>, address)</span><br><span class="line">                <span class="keyword">del</span> ChatServer.clients[address]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_text_stream</span><span class="params">(self, stream, sender, msg_len)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理文本数据</span></span><br><span class="line"><span class="string">        :param stream:</span></span><br><span class="line"><span class="string">        :param send_to:</span></span><br><span class="line"><span class="string">        :param msg_len:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data = <span class="keyword">yield</span> stream.read_bytes(msg_len, partial=<span class="literal">True</span>)</span><br><span class="line">        data = struct.unpack(<span class="string">"!"</span>+str(msg_len)+<span class="string">"s"</span>, data)</span><br><span class="line">        logger.debug(<span class="string">"data:%s"</span>, data)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 打包数据,数据格式:数据发送者+数据类型+数据长度+数据体</span></span><br><span class="line">            binary_msg = struct.pack(<span class="string">"!IBI"</span> + str(msg_len) + <span class="string">"s"</span>, sender, <span class="number">1</span>, msg_len, data[<span class="number">0</span>])</span><br><span class="line">            <span class="comment"># 发送数据</span></span><br><span class="line">            <span class="keyword">yield</span> stream.write(binary_msg)</span><br><span class="line">            logger.debug(<span class="string">"="</span>*<span class="number">25</span>)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># 将离线消息保存到数据库</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_pic_stream</span><span class="params">(self, stream, sender, msg_len)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sockets = bind_sockets(ChatServer.PORT)</span><br><span class="line">    server = ChatServer()</span><br><span class="line">    server.add_sockets(sockets)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure>

<p>以上就是具体的代码实现。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>tornado</tag>
      </tags>
  </entry>
  <entry>
    <title>python开发之使用RabbitMQ做消息队列</title>
    <url>/blog/2020/05/30/python%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BD%BF%E7%94%A8RabbitMQ%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>最近在研究redis做消息队列时，顺便看了一下RabbitMQ做消息队列的实现。以下是总结的RabbitMQ中三种exchange模式的实现，分别是fanout, direct和topic。</p>
<a id="more"></a>

<h1 id="实例化MQ"><a href="#实例化MQ" class="headerlink" title="实例化MQ"></a>实例化MQ</h1><p>base.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取认证对象，参数是用户名、密码。远程连接时需要认证</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">"admin"</span>, <span class="string">"admin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># BlockingConnection(): 实例化连接对象</span></span><br><span class="line"><span class="comment"># ConnectionParameters(): 实例化链接参数对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">    <span class="string">"192.168.0.102"</span>, <span class="number">5672</span>, <span class="string">"/"</span>, credentials))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的channel(通道)</span></span><br><span class="line">channel = connection.channel()</span><br></pre></td></tr></table></figure>



<h1 id="fanout模式"><a href="#fanout模式" class="headerlink" title="fanout模式"></a>fanout模式</h1><p>fanout模式会向绑定到指定exchange的queue中发送消息，消费者从queue中取出数据，类似于广播模式、发布订阅模式。<br>绑定方式: 在接收端channel.queue_bind(exchange=”logs”, queue=queue_name)<br>代码：<br>publisher.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> channel, connection</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明exchange, 不声明queue</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">"logs"</span>, exchange_type=<span class="string">"fanout"</span>)  <span class="comment"># 广播</span></span><br><span class="line">message = <span class="string">"hello fanout"</span></span><br><span class="line">channel.basic_publish(</span><br><span class="line">    exchange=<span class="string">"logs"</span>,</span><br><span class="line">    routing_key=<span class="string">""</span>,</span><br><span class="line">    body=message</span><br><span class="line">)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>



<p>consumer.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> channel, connection</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明exchange</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">"logs"</span>, exchange_type=<span class="string">"fanout"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定queue名字, rabbitmq会随机分配一个名字, 消息处理完成后queue会自动删除</span></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取queue名字</span></span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定exchange和queue</span></span><br><span class="line">channel.queue_bind(exchange=<span class="string">"logs"</span>, queue=queue_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">"body:%s"</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    callback,</span><br><span class="line">    queue=queue_name</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>



<h1 id="direct模式"><a href="#direct模式" class="headerlink" title="direct模式"></a>direct模式</h1><p>direct模式中发送端会绑定一个routing_key1, queue中绑定若干个routing_key2, 若key1与key2相等，或者key1在key2中，则消息就会发送到这个queue中，再由相应的消费者去queue中取数据。<br>publisher.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> channel, connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">"direct_test"</span>, exchange_type=<span class="string">"direct"</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">channel.basic_publish(</span><br><span class="line">    exchange=<span class="string">"direct_test"</span>,</span><br><span class="line">    routing_key=<span class="string">"info"</span>,  <span class="comment"># 绑定key</span></span><br><span class="line">    body=message</span><br><span class="line">)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<p>consumer01.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> channel, connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">"direct_test"</span>, exchange_type=<span class="string">"direct"</span>)</span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.queue_bind(</span><br><span class="line">    exchange=<span class="string">"direct_test"</span>,</span><br><span class="line">    queue=queue_name,</span><br><span class="line">    <span class="comment"># 绑定的key,与publisher中的相同</span></span><br><span class="line">    routing_key=<span class="string">"info"</span>  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">"body:%s"</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    callback,</span><br><span class="line">    queue=queue_name</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>consumer02.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> channel, connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">"direct_test"</span>, exchange_type=<span class="string">"direct"</span>)</span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.queue_bind(</span><br><span class="line">    exchange=<span class="string">"direct_test"</span>,</span><br><span class="line">    queue=queue_name,</span><br><span class="line">    <span class="comment"># 绑定的key</span></span><br><span class="line">    routing_key=<span class="string">"error"</span>   </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, bosy)</span>:</span></span><br><span class="line">    print(<span class="string">"body:%s"</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    callback,</span><br><span class="line">    queue=queue_name</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>consumer03.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> channel, connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">"direct_test"</span>, exchange_type=<span class="string">"direct"</span>)</span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key_list = [<span class="string">"info"</span>, <span class="string">"warning"</span>]</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> key_list:</span><br><span class="line">    channel.queue_bind(</span><br><span class="line">        exchange=<span class="string">"direct_test"</span>,</span><br><span class="line">        queue=queue_name,</span><br><span class="line">        <span class="comment"># 一个queue同时绑定多个key，有一个key满足条件时就可以收到数据</span></span><br><span class="line">        routing_key=key  </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">"body:%s"</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    callback,</span><br><span class="line">    queue=queue_name</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python producer.py</span><br><span class="line">python consumer01.py</span><br><span class="line">python consumer02.py</span><br><span class="line">python consumer03.py</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">consumer01.py: body:<span class="string">b'hello'</span></span><br><span class="line">consumer02.py没收到结果</span><br><span class="line">consumer03.py: body:<span class="string">b'hello'</span></span><br></pre></td></tr></table></figure>



<h1 id="topic模式"><a href="#topic模式" class="headerlink" title="topic模式"></a>topic模式</h1><p>topic模式不是太好理解，我的理解如下:<br>对于发送端绑定的routing_key1，queue绑定若干个routing_key2；若routing_key1满足任意一个routing_key2，则该消息就会通过exchange发送到这个queue中，然后由接收端从queue中取出其实就是direct模式的扩展。</p>
<p>发送端绑定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(</span><br><span class="line">    exchange=<span class="string">"topic_logs"</span>,</span><br><span class="line">    routing_key=routing_key,</span><br><span class="line">    body=message</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>接收端绑定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.queue_bind(</span><br><span class="line">    exchange=<span class="string">"topic_logs"</span>,</span><br><span class="line">    queue=queue_name,</span><br><span class="line">    routing_key=binding_key</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>publisher.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> channel, connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明exchange</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">"topic_test"</span>, exchange_type=<span class="string">"topic"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 待发送消息</span></span><br><span class="line">message = <span class="string">" "</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"hello topic"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布消息</span></span><br><span class="line">channel.basic_publish(</span><br><span class="line">    exchange=<span class="string">"topic_test"</span>,</span><br><span class="line">    routing_key=<span class="string">"mysql.error"</span>,   <span class="comment"># 绑定的routing_key</span></span><br><span class="line">    body=message</span><br><span class="line">)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<p>consumer01.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> channel, connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">"topic_test"</span>, exchange_type=<span class="string">"topic"</span>)</span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.queue_bind(</span><br><span class="line">    exchange=<span class="string">"topic_test"</span>,</span><br><span class="line">    queue=queue_name,</span><br><span class="line">    routing_key=<span class="string">"*.error"</span>    <span class="comment"># 绑定的routing_key</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">"body:%s"</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    callback,</span><br><span class="line">    queue=queue_name,</span><br><span class="line">    no_ack=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>consumer02.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> channel, connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">"topic_test"</span>, exchange_type=<span class="string">"topic"</span>)</span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.queue_bind(</span><br><span class="line">    exchange=<span class="string">"topic_test"</span>,</span><br><span class="line">    queue=queue_name,</span><br><span class="line">    routing_key=<span class="string">"mysql.*"</span>    <span class="comment"># 绑定的routing_key</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">"body:%s"</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    callback,</span><br><span class="line">    queue=queue_name,</span><br><span class="line">    no_ack=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python publisher02.py <span class="string">"this is a topic test"</span></span><br><span class="line">python consumer01.py</span><br><span class="line">python consumer02.py</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">consumer01.py的结果: body:<span class="string">b'this is a topic test'</span></span><br><span class="line">consumer02.py的结果: body:<span class="string">b'this is a topic test'</span></span><br></pre></td></tr></table></figure>

<p>说明通过绑定相应的routing_key，两个消费者都收到了消息</p>
<p>将publisher.py的routing_key改成”mysql.info”<br>再次执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python publisher02.py <span class="string">"this is a topic test"</span></span><br><span class="line">python consumer01.py</span><br><span class="line">python consumer02.py</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">consumer01.py没收到结果</span><br><span class="line">consumer02.py的结果: body:<span class="string">b'this is a topic test'</span></span><br></pre></td></tr></table></figure>

<p>通过这个例子我们就能明白topic的运行方式了。</p>
<p>RabbitMQ的三种exchange模式就介绍到这里。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>svn的简单使用</title>
    <url>/blog/2020/06/27/svn%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>与 git 一样，svn （Subversion）也是一个开源的版本控制系统，相比于 git 的分布式管理，svn是一个集中式的版本管理工具。今天介绍下它的简单使用。</p>
<a id="more"></a>

<p>svn 是集中式的版本管理工具，它依赖于 svn 服务器，所有的版本信息都保存在服务器上。</p>
<h1 id="svn使用总结"><a href="#svn使用总结" class="headerlink" title="svn使用总结"></a>svn使用总结</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>svn的使用步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu安装svn</span><br><span class="line">1. apt-get update</span><br><span class="line">2. apt-get install subversion</span><br><span class="line">安装完成后，可以执行 svnserve --version 查看版本信息</span><br><span class="line"></span><br><span class="line">创建版本库：</span><br><span class="line">1. 在 &#x2F;home&#x2F;wyzane 下创建 svn 目录（作为中央仓库）</span><br><span class="line">2. 创建仓库：svnadmin create &#x2F;home&#x2F;wyzane&#x2F;svn</span><br><span class="line">3. 创建完成后，在 svn 下会生成 conf、db 等目录</span><br><span class="line">目录结构如下：</span><br><span class="line">        .</span><br><span class="line">        ├── conf</span><br><span class="line">        │   ├── authz</span><br><span class="line">        │   ├── hooks-env.tmpl</span><br><span class="line">        │   ├── passwd</span><br><span class="line">        │   └── svnserve.conf</span><br><span class="line">        ├── db</span><br><span class="line">        │   ├── current</span><br><span class="line">        │   ├── format</span><br><span class="line">        │   ├── fsfs.conf</span><br><span class="line">        │   ├── fs-type</span><br><span class="line">        │   ├── min-unpacked-rev</span><br><span class="line">        │   ├── rep-cache.db</span><br><span class="line">        │   ├── rep-cache.db-journal</span><br><span class="line">        │   ├── revprops</span><br><span class="line">        │   ├── revs</span><br><span class="line">        │   ├── transactions</span><br><span class="line">        │   ├── txn-current</span><br><span class="line">        │   ├── txn-current-lock</span><br><span class="line">        │   ├── txn-protorevs</span><br><span class="line">        │   ├── uuid</span><br><span class="line">        │   └── write-lock</span><br><span class="line">        ├── format</span><br><span class="line">        ├── hooks</span><br><span class="line">        │   ├── post-commit.tmpl</span><br><span class="line">        │   ├── post-lock.tmpl</span><br><span class="line">        │   ├── post-revprop-change.tmpl</span><br><span class="line">        │   ├── post-unlock.tmpl</span><br><span class="line">        │   ├── pre-commit.tmpl</span><br><span class="line">        │   ├── pre-lock.tmpl</span><br><span class="line">        │   ├── pre-revprop-change.tmpl</span><br><span class="line">        │   ├── pre-unlock.tmpl</span><br><span class="line">        │   └── start-commit.tmpl</span><br><span class="line">        ├── locks</span><br><span class="line">        │   ├── db.lock</span><br><span class="line">        │   └── db-logs.lock</span><br><span class="line">        └── README.txt</span><br><span class="line">其中，conf目录下存放了配置文件，passwd 是用户配置文件，可以配置用户名和密码。authz 是权限配置文件，可以配置用户对应的读写权限，也可以对用户进行分组配置。svnserve.conf 是基本的配置文件。</span><br><span class="line"></span><br><span class="line">启动服务：</span><br><span class="line">svnserve -d -r &#x2F;home&#x2F;wyzane&#x2F;svn  (默认端口 3690)</span><br><span class="line">其中：</span><br><span class="line">	-d：表示在后台运行</span><br><span class="line">	-r：指定服务器的根目录</span><br><span class="line">查看进程：ps aux | grep svnserve</span><br><span class="line"></span><br><span class="line">客户端 checkout 代码需要执行以下命令：</span><br><span class="line">svn checkout svn:&#x2F;&#x2F;192.168.0.105&#x2F; --username wyzane</span><br></pre></td></tr></table></figure>

<p>在 windows 下使用时，我们可以下载 svn 的 windows 版本进行安装，下载地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;subversion.apache.org&#x2F;packages.html</span><br></pre></td></tr></table></figure>

<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 首先创建 branches 目录并提交</span><br><span class="line">2. 创建分支：svn copy trunk&#x2F; branches&#x2F;sub，并使用 svn commit 提交（基于 trunk 的分支）</span><br><span class="line">3. 修改 sub 分支上的内容并提交</span><br><span class="line">4. 合并分支：切换到 trunk 目录，执行svn merge ..&#x2F;branches&#x2F;sub&#x2F;</span><br><span class="line">5. 提交合并后的内容：svn commit -m &quot;update&quot;</span><br></pre></td></tr></table></figure>

<h2 id="tag操作"><a href="#tag操作" class="headerlink" title="tag操作"></a>tag操作</h2><p>通过 tag 标签，可以给某一具体的版本加上一个有意义的名称，便于更好的管理，tag 的使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建 tags 目录并提交：mkdir tags &amp; svn add tags &amp; svn commit -m &quot;commit tags dir&quot;</span><br><span class="line">2. 在当前的 trunk 版本上打一个 tag：svn copy trunk&#x2F; tags&#x2F;v1.0</span><br><span class="line">3. 提交到版本库：svn commit -m &quot;v1.0&quot;</span><br></pre></td></tr></table></figure>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn add test.txt   # 添加文件到版本库中</span><br><span class="line">A         test.txt</span><br><span class="line">svn status         # 查看状态</span><br><span class="line">A       test.txt  </span><br><span class="line">svn commit -m &quot;update&quot;   # 将改动的文件提交到版本库，此时再使用 svn status 时，就不会有输出信息了</span><br><span class="line"></span><br><span class="line">svn update  # 更新版本哭的改动到本地</span><br><span class="line"></span><br><span class="line">svn log   # 查看版本库的提交历史</span><br></pre></td></tr></table></figure>



<h1 id="使用时可能的错误"><a href="#使用时可能的错误" class="headerlink" title="使用时可能的错误"></a>使用时可能的错误</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. commit failed， 没有找到事务5-9</span><br><span class="line">解决：这是因为 svnserve 的服务没有开启，启动 svnserve 即可。</span><br><span class="line"></span><br><span class="line">2. the error was 条目不可读</span><br><span class="line">解决：配置文件中修改 anon-access 的值为 none，然后重启即可</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title>为已安装的nginx动态添加模块</title>
    <url>/blog/2020/07/25/%E4%B8%BA%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84nginx%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>今天介绍下如何为已安装的 nginx 动态添加模块。</p>
<a id="more"></a>

<p>首先，我们下载需要编译进 nginx 模块，或者使用 nginx 自带的模块如：realip 模块。</p>
<p>然后，执行 nginx -V，查看nginx信息和之前的安装记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  conf nginx -V                                  </span><br><span class="line">nginx version: nginx&#x2F;1.16.1</span><br><span class="line">built by gcc 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) </span><br><span class="line">built with OpenSSL 1.1.1  11 Sep 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic</span><br></pre></td></tr></table></figure>

<p>可以看到，我们之前编译 nginx 时使用的参数是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic</span><br></pre></td></tr></table></figure>

<p>那么，我们这次编译时，如果想把 nginx 自带的模块编译进去，如 realip，则执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic --with-http_realip_module</span><br></pre></td></tr></table></figure>

<p>如果想把第三方模块编译进去，则可以执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-stream --with-mail&#x3D;dynamic -–add-module&#x3D;第三方模块所在目录</span><br></pre></td></tr></table></figure>

<p>上述命令执行完成后，再执行 make 命令（不需要指定 make install命令）就行了。</p>
<p>最后，将现有的 nginx 二进制文件备份（例如：备份文件 /usr/local/nginx/sbin/nginx），备份完成后，再使用刚刚生成的 nginx 二进制文件替换现有的 nginx 二进制文件既可。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>zeroc ice在python中的使用</title>
    <url>/blog/2020/07/11/zeroc-ice%E5%9C%A8python%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>zeroc ice 指的是 zeroc 公司开发的一款网络通讯引擎 ice。ice 是一个面向对象的 RPC 框架，可以搭建分布式应用。最主要的一点，它是跨语言的，不管你使用 Python、Java 还是 C++、Ruby、C# 等开发语言，它都支持。还有一点，ice 提供了其他功能，包括：IceStorm（一种订阅服务，类似于消息队列）、IceGrid 等。</p>
<a id="more"></a>

<p>下面从安装、使用等几个方面介绍下 ice 在 python 中的使用。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装环境是 python3.6.9，ubuntu18.04。</p>
<h2 id="安装方式一"><a href="#安装方式一" class="headerlink" title="安装方式一"></a>安装方式一</h2><p>安装步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. sudo apt-get install openssl libssl-dev libbz2-dev</span><br><span class="line">    第一步安装不成功时，可以使用 aptitude 来安装需要的包：</span><br><span class="line">	sudo apt-get install aptitude </span><br><span class="line">	sudo aptitude install xxxxx</span><br><span class="line">2. 安装 ice for python: pip install zeroc-ice</span><br><span class="line">3. 安装 ice for linux</span><br><span class="line">	1）将源码克隆到本地: git clone https:&#x2F;&#x2F;github.com&#x2F;zeroc-ice&#x2F;ice.git</span><br><span class="line">		若网速太慢，可以先在码云上创建项目并将ice.git克隆过去，再从码云上克隆</span><br><span class="line">	2）克隆完成后，切换分支到3.7: git checkout 3.7（安装3.7版本）</span><br><span class="line">	3）编译：make supported-languages&#x3D;&#39;cpp python&#39; （只编译c++和python，还可以编译其他语言）</span><br><span class="line">	4）安装：make install supported-languages&#x3D;&#39;cpp python&#39; prefix&#x3D;&#x2F;opt&#x2F;zeroc-ice </span><br><span class="line">	5）配置环境变量：在 .zshrc 中添加配置: PATH&#x3D;$PATH:&#x2F;opt&#x2F;zeroc-ice&#x2F;bin</span><br><span class="line">	6）执行命令: icegridnode -v，会输出响应版本</span><br><span class="line">4. 安装完成后，可以从 github 上克隆 ice-demos 来学习。</span><br></pre></td></tr></table></figure>



<h2 id="安装方式二"><a href="#安装方式二" class="headerlink" title="安装方式二"></a>安装方式二</h2><p>或者，可以按照 zeroc 官方文档进行安装，官方文档如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;zeroc.com&#x2F;downloads&#x2F;ice&#x2F;3.7&#x2F;python</span><br></pre></td></tr></table></figure>



<h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><p>首先简单介绍下 ice 中相关概念和一些基础知识。</p>
<h2 id="slice语言"><a href="#slice语言" class="headerlink" title="slice语言"></a>slice语言</h2><p>Slice (Specification Language for Ice) 是实现 Ice 协议的开发语言，它可以把 Ice 接口的实现翻译成不同的开发语言版本。对于不同的应用开发语言，有不同的映射规则。</p>
<p>Slice 提供一个基本的抽象机制用于分离接口和他们的实现。Slice 用于描述接口，建立客户端和服务端之间的关系。Slice的接口描述与具体实现语言无关，即它可以让你定义 client 和 server 之间的交互而不用关心具体的开发语言，例如 C++，Java、Python等。通过编译，可以把 Slice对接口的描述转换成不同的开发语言。</p>
<h2 id="client-与-server"><a href="#client-与-server" class="headerlink" title="client 与 server"></a>client 与 server</h2><p>在 ice 中，client 和 server 不是指一个应用系统的特定部分，它们是在一个持续请求中扮演不同角色，具有不同的功能。</p>
<p>client 会主动向 server 发送服务请求，而 server 端只能被动的接收请求，并针对请求，为 client 端提供不同的服务。通常，client 会主动向 server 端发起请求，也可以接收 server 端的回调通知，这样看来，client 既有 client 端属性也有 server 端属性。</p>
<p>client 和 server 的结构如下：</p>
<p><img src="Ice_Client_and_Server_Structure.gif" alt="Ice_Client_and_Server_Structure"></p>
<p>上面的结构中，有以下几部分。</p>
<h3 id="Ice-Core"><a href="#Ice-Core" class="headerlink" title="Ice Core"></a>Ice Core</h3><p>ice core 包含了 client 和 server 的运行时，用于支持远程通信。这部分包含了网络通信、线程、字节序及其他网络相关的代码实现，并与应用层代码分离开来。ice core 提供了一系列库供 client 和 server 端调用。</p>
<h3 id="Ice-API"><a href="#Ice-API" class="headerlink" title="Ice API"></a>Ice API</h3><p>ice 中通过 ice api 来访问 ice core，使用 ice api 来做一些基础工作，例如初始化和资源回收。ice api 对于 client 和 server 端来说没有什么区别。</p>
<h3 id="Proxy-Code"><a href="#Proxy-Code" class="headerlink" title="Proxy Code"></a>Proxy Code</h3><p>proxy code 部分是根据 slice 文件中定义的内容生成的，它规定了对象和数据的类型。proxy code 主要有两个功能：</p>
<ol>
<li>为 client 端提供向下调用的接口，在 proxy API 调用函数最终会向 server 端发送一个 RPC 消息，然后在服务端执行响应的目标函数</li>
<li>提供组包和解包代码，组包是序列化复杂数据结构的过程，例如为了在网络上传送，序列化一个序列或者字典。组包会将数据转换成一种标准的数据传输格式，并且不受字节序的影响。解包就是相反的过程。</li>
</ol>
<h3 id="Skeleton-Code"><a href="#Skeleton-Code" class="headerlink" title="Skeleton Code"></a>Skeleton Code</h3><p>skeleton code 与 proxy code 功能相似，只是它在 server 端发挥作用，proxy code 是在 client 端的。它提供了向上调用的接口，并且允许 ice 运行时将控制线程转换为应用代码。skeleton 中也包含组包和解包的功能，以便 server 端能接收 client 端传入的参数，并且向 client 端返回结果或者异常。</p>
<h3 id="Object-Adapter"><a href="#Object-Adapter" class="headerlink" title="Object Adapter"></a>Object Adapter</h3><p>object adapter 是 ice api 的一部分，它只在 server 端使用，它由如下几个功能：</p>
<ol>
<li>将客户端请求与编程语言中的特定方法映射，即 object adapter 会找到内存中具有特定标识的对象</li>
<li>object adapter 与传输协议有关，如果一个 object adapter 对应多个传输协议，server 就能提供多种服务</li>
<li>object adapter 可以生成 proxy（proxy 会被发送到 client 端）。object adapter 中记录了每个对象的类型、名称、传输信息。当 server 端想要创建 proxy 时，object adapter 能创建 proxy 而不需要知道具体细节。</li>
</ol>
<h2 id="Ice-Objects"><a href="#Ice-Objects" class="headerlink" title="Ice Objects"></a>Ice Objects</h2><p>简单来说，ice object 对象中定义了一些接口，通过调用这些接口，client 能向服务器发送请求。我的理解是（以 Python 为例），ice object 中定义了一些方法，这些方法实现了请求创建、数据传递、数据接收等功能；我们在 slice 文件中定义的接口，经过转换后是 ice object 的子类；server 端需要继承 ice object 的子类来实现具体的功能。</p>
<h2 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h2><p>通过 proxy，client 能与 ice object 关联起来，proxy 就类似于 ice object 的一个使者。当 client 想调用 ice object 中的某个功能时（其实就是某个方法），需要通过 proxy ，这时会执行以下流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 定位 ice object</span><br><span class="line">2. 激活 ice object</span><br><span class="line">3. 激活 server 端的 ice object</span><br><span class="line">4. 传递入参到 ice object 中</span><br><span class="line">5. 等待操作完成</span><br><span class="line">6. 把出参和结果返回给 client 端</span><br></pre></td></tr></table></figure>

<p>proxy 信息可以用一个字符串表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimplePrinter:default -p 10000</span><br></pre></td></tr></table></figure>

<p>这种字符串形式的 proxy 更加易于理解和存储。</p>
<p>proxy 还分为 Direct Proxy 和 Indirect Proxy。Direct Proxy 通常包括 proxy 对象名称和服务器地址，包括以下两类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. a protocol identifier (such TCP&#x2F;IP or UDP)</span><br><span class="line">2. a protocol-specific address (such as a host name and port number)</span><br></pre></td></tr></table></figure>

<p>Indirect Proxy 有两种形式，一种是仅仅提供对象名称（如：SimplePrinter），另一种是提供对象名称和对象适配器名称（如：SimplePrinter@PrinterAdapter）。</p>
<h2 id="Ice-Protocol"><a href="#Ice-Protocol" class="headerlink" title="Ice Protocol"></a>Ice Protocol</h2><p>ice能提供 RPC 协议，这些 RPC 协议可以使用多种底层协议，最常用的是TCP和UDP，但是ice也支持 Websocket, Bluetooth 和 Apple’s iAP。Ice还可以使用 SSL 协议对传输数据加密。</p>
<p>Ice 协议中定义了以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 定义了一些消息类型，例如请求\应答的消息类型</span><br><span class="line">2. 定义了状态机，确定客户端和服务端如何交换数据</span><br><span class="line">3. 定义编码规则，确定怎样表示数据类型</span><br><span class="line">4. 定义了消息类型的头部，包括消息类型、消息大小、使用的协议等。</span><br></pre></td></tr></table></figure>

<p>Ice也支持数据压缩，当客户端与服务端传输的数据量非常大时，这很有用。<br>Ice 协议非常适合创建高效的事件分发机制，因为它允许我们分发消息而不用关心消息内部的实现。<br>Ice 协议也支持双向的操作，即：如果服务端传输数据到客户端提供的回调对象上，回调过程可以通过客户端最初创建的连接来完成。</p>
<h2 id="Ice-Service"><a href="#Ice-Service" class="headerlink" title="Ice Service"></a>Ice Service</h2><p>对于开发分布式应用程序，Ice Core提供了一个复杂的 client-server 平台，然而，实际开发中不仅仅需要远程处理能力，也需要按需提供服务、向客户端分发代理、分发异步任务、向应用程序分发补丁等等。Ice 提供了以下服务来实现上面的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. IceGrid</span><br><span class="line">2. IceStorm</span><br><span class="line">3. IcePatch2</span><br><span class="line">4. Glacier2</span><br><span class="line">5. IceBridge</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的介绍中，我们可以发现，开发 ice 的 client 和 server 时，我们需要以下几个部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. slice 文件</span><br><span class="line">2. ice object</span><br><span class="line">3. proxy code</span><br><span class="line">4. object adapter</span><br></pre></td></tr></table></figure>

<p>上面这些都会在下面的代码中体现出来，可以回想一下它们的功能分别是什么。</p>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>安装完成后，首先看第一个使用的例子。</p>
<h2 id="编写-Slice-File"><a href="#编写-Slice-File" class="headerlink" title="编写 Slice File"></a>编写 Slice File</h2><p>开发时，首先要编写 slice 文件，slice 文件是与开发语言无关的。编写完成后，需要使用编译器将其转换成不同的开发语言，例如转换成 Python 时，就需要使用 slice2py。slice 文件里面的内容其实就是一些接口，server 端开发时需要编写 Python 类来实现这些接口。</p>
<p>Printer.ice：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module Demo</span><br><span class="line">&#123;</span><br><span class="line">    interface Printer</span><br><span class="line">    &#123;</span><br><span class="line">        void printString(string s);</span><br><span class="line"></span><br><span class="line">        int addMun(int num1, int num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中， Demo 是模块名称，Printer 是接口名称，接口里面是方法的定义。</p>
<p>编写完成后，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slice2py Printer.ice</span><br></pre></td></tr></table></figure>

<p>执行完成后，会生成 Printer_ice.py 文件和 Demo 文件夹。Demo文件夹下的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── __init__.py</span><br><span class="line">└── __pycache__</span><br><span class="line">    └── __init__.cpython-36.pyc</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Demo&#x2F;__init__.py 内容如下：</span><br><span class="line"># Generated by slice2py - DO NOT EDIT!</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">import Ice</span><br><span class="line">Ice.updateModule(&quot;Demo&quot;)</span><br><span class="line"></span><br><span class="line"># Modules:</span><br><span class="line">import Printer_ice</span><br><span class="line"></span><br><span class="line"># Submodules:</span><br></pre></td></tr></table></figure>

<p>Printer_ice.py 文件中的内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright (c) ZeroC, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Ice version 3.7.4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;auto-generated&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Generated from file `Printer.ice'</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Warning: do not edit this file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;/auto-generated&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> version_info <span class="keyword">as</span> _version_info_</span><br><span class="line"><span class="keyword">import</span> Ice, IcePy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start of module Demo</span></span><br><span class="line">_M_Demo = Ice.openModule(<span class="string">'Demo'</span>)</span><br><span class="line">__name__ = <span class="string">'Demo'</span></span><br><span class="line"></span><br><span class="line">_M_Demo._t_Printer = IcePy.defineValue(<span class="string">'::Demo::Printer'</span>, Ice.Value, <span class="number">-1</span>, (), <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">None</span>, ())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'PrinterPrx'</span> <span class="keyword">not</span> <span class="keyword">in</span> _M_Demo.__dict__:</span><br><span class="line">    _M_Demo.PrinterPrx = Ice.createTempClass()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PrinterPrx</span><span class="params">(Ice.ObjectPrx)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printString</span><span class="params">(self, s, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.invoke(self, ((s, ), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printStringAsync</span><span class="params">(self, s, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.invokeAsync(self, ((s, ), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">begin_printString</span><span class="params">(self, s, _response=None, _ex=None, _sent=None, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.begin(self, ((s, ), _response, _ex, _sent, context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">end_printString</span><span class="params">(self, _r)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_printString.end(self, _r)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addMun</span><span class="params">(self, num1, num2, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.invoke(self, ((num1, num2), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addMunAsync</span><span class="params">(self, num1, num2, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.invokeAsync(self, ((num1, num2), context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">begin_addMun</span><span class="params">(self, num1, num2, _response=None, _ex=None, _sent=None, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.begin(self, ((num1, num2), _response, _ex, _sent, context))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">end_addMun</span><span class="params">(self, _r)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.Printer._op_addMun.end(self, _r)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">checkedCast</span><span class="params">(proxy, facetOrContext=None, context=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.PrinterPrx.ice_checkedCast(proxy, <span class="string">'::Demo::Printer'</span>, facetOrContext, context)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">uncheckedCast</span><span class="params">(proxy, facet=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _M_Demo.PrinterPrx.ice_uncheckedCast(proxy, facet)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_staticId</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'::Demo::Printer'</span></span><br><span class="line">    _M_Demo._t_PrinterPrx = IcePy.defineProxy(<span class="string">'::Demo::Printer'</span>, PrinterPrx)</span><br><span class="line"></span><br><span class="line">    _M_Demo.PrinterPrx = PrinterPrx</span><br><span class="line">    <span class="keyword">del</span> PrinterPrx</span><br><span class="line"></span><br><span class="line">    _M_Demo.Printer = Ice.createTempClass()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Printer</span><span class="params">(Ice.Object)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_ids</span><span class="params">(self, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">'::Demo::Printer'</span>, <span class="string">'::Ice::Object'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_id</span><span class="params">(self, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'::Demo::Printer'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ice_staticId</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'::Demo::Printer'</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printString</span><span class="params">(self, s, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">"servant method 'printString' not implemented"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addMun</span><span class="params">(self, num1, num2, current=None)</span>:</span></span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">"servant method 'addMun' not implemented"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> IcePy.stringify(self, _M_Demo._t_PrinterDisp)</span><br><span class="line"></span><br><span class="line">        __repr__ = __str__</span><br><span class="line"></span><br><span class="line">    _M_Demo._t_PrinterDisp = IcePy.defineClass(<span class="string">'::Demo::Printer'</span>, Printer, (), <span class="literal">None</span>, ())</span><br><span class="line">    Printer._ice_type = _M_Demo._t_PrinterDisp</span><br><span class="line"></span><br><span class="line">    Printer._op_printString = IcePy.Operation(<span class="string">'printString'</span>, Ice.OperationMode.Normal, Ice.OperationMode.Normal, <span class="literal">False</span>, <span class="literal">None</span>, (), (((), IcePy._t_string, <span class="literal">False</span>, <span class="number">0</span>),), (), <span class="literal">None</span>, ())</span><br><span class="line">    Printer._op_addMun = IcePy.Operation(<span class="string">'addMun'</span>, Ice.OperationMode.Normal, Ice.OperationMode.Normal, <span class="literal">False</span>, <span class="literal">None</span>, (), (((), IcePy._t_int, <span class="literal">False</span>, <span class="number">0</span>), ((), IcePy._t_int, <span class="literal">False</span>, <span class="number">0</span>)), (), ((), IcePy._t_int, <span class="literal">False</span>, <span class="number">0</span>), ())</span><br><span class="line"></span><br><span class="line">    _M_Demo.Printer = Printer</span><br><span class="line">    <span class="keyword">del</span> Printer</span><br><span class="line"></span><br><span class="line"><span class="comment"># End of module Demo</span></span><br></pre></td></tr></table></figure>

<p>从上面的内容中可以看出，Printer_ice.py 中主要有两个 Python 类 PrinterPrx 和 Printer。</p>
<h2 id="编写-Server-端"><a href="#编写-Server-端" class="headerlink" title="编写 Server 端"></a>编写 Server 端</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, Ice</span><br><span class="line"><span class="keyword">import</span> Demo</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterI</span><span class="params">(Demo.Printer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printString</span><span class="params">(self, s, current=None)</span>:</span></span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addMun</span><span class="params">(self, n1, n2, current=None)</span>:</span></span><br><span class="line">        ret = n1 + n2</span><br><span class="line">        print(ret)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> Ice.initialize(sys.argv) <span class="keyword">as</span> communicator:</span><br><span class="line">    adapter = communicator.createObjectAdapterWithEndpoints(<span class="string">"SimplePrinterAdapter"</span>, <span class="string">"default -p 10000"</span>)</span><br><span class="line">    object = PrinterI()</span><br><span class="line">    adapter.add(object, communicator.stringToIdentity(<span class="string">"SimplePrinter"</span>))</span><br><span class="line">    adapter.activate()</span><br><span class="line">    communicator.waitForShutdown()</span><br></pre></td></tr></table></figure>

<p>server 端的代码中主要有两部分：一个 Python 类 PrinterI，继承了 Demo.Printer 并实现了其中的方法；with 代码块。</p>
<p>with 代码块中的含义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Ice.initialize()初始化 Ice 运行环境，返回一个Ice.Communicator对象，它是 Ice 运行时的主要对象</span><br><span class="line">2. communicator.createObjectAdapterWithEndpoints()创建一个 Object Adapter 对象，</span><br><span class="line">   &quot;SimplePrinterAdapter&quot;表示 Adapter 对象名称，&quot;default -p 10000&quot; 表示使用 TCP&#x2F;IP协议并监听10000端口</span><br><span class="line">3. object &#x3D; PrinterI() 表示实例化 Printer 接口的子类</span><br><span class="line">4. 调用 Adapter 对象的 add 方法，将实例化的对象绑定到 Adapter 中。add() 方法的第一个参数就是 PrinterI 类的对    象，第二个参数是给 PrinterI 对象指定一个名称，如果有多个实例化的对象时，每个对象的名称都不能相同</span><br><span class="line">5. adapter.activate() 表示启用 Adapter </span><br><span class="line">6. 最后，调用 communicator.waitForShutdown() 会阻塞直到服务关闭</span><br></pre></td></tr></table></figure>



<h2 id="编写-Client-端"><a href="#编写-Client-端" class="headerlink" title="编写 Client 端"></a>编写 Client 端</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, Ice</span><br><span class="line"><span class="keyword">import</span> Demo</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> Ice.initialize(sys.argv) <span class="keyword">as</span> communicator:</span><br><span class="line">    base = communicator.stringToProxy(<span class="string">"SimplePrinter:default -p 10000"</span>)</span><br><span class="line">    printer = Demo.PrinterPrx.checkedCast(base)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> printer:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"Invalid proxy"</span>)</span><br><span class="line"> </span><br><span class="line">    printer.printString(<span class="string">"Hello World!"</span>)</span><br><span class="line">    ret = printer.addMun(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"client:"</span>, ret)</span><br></pre></td></tr></table></figure>

<p>client 中只有一个 with 代码块，其含义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Ice.initialize()：初始化 Ice 运行环境</span><br><span class="line">2. communicator.stringToProxy()：获得远端 printer 的一个代理对象，参数 &quot;SimplePrinter:default -p 10000&quot;    表示在服务端指定的 printer 对象名称和监听端口</span><br><span class="line">3. stringToProxy()方法返回的是一个Ice.ObjectPrx类型，它是其他所有接口的父类。但是，实际上我们是需要一个          Demo.Printer 类型，所以需要类型向下的转换。使用 Demo.PrinterPrx.checkedCast(base) 可以向服务器发送消息，    确认代理是否是 Demo.Printer类型，如果是，就返回一个 Demo.PrinterPrx 类型的代理，否则返回None</span><br><span class="line">4. printer.printString(&quot;Hello World!&quot;) 调用方法。</span><br></pre></td></tr></table></figure>



<p>编写完成后，执行 Python 文件就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python server.py</span><br><span class="line">python client.py</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>书单-《终身成长》读后感</title>
    <url>/blog/2020/05/30/%E4%B9%A6%E5%8D%95-%E3%80%8A%E7%BB%88%E8%BA%AB%E6%88%90%E9%95%BF%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>《终身成长》这本书属于心理学研究方面的书籍，书中主要介绍了两种思维模式对我们方方面面的影响，这两种思维模式是：固定思维模式和成长思维模式。</p>
<a id="more"></a>

<p>在心理学等方面的书籍中，欧美作家们总是会通过例举大量实验和真实案例来佐证他们的研究结论，本书中也例举了大量实验和真实案例，讲述了这两种思维模式在生活、学习、工作、恋爱等方面对我们的影响。如果你也看完了这本书，不妨想一下自己属于哪种思维模式，这种思维模式如何影响你生活的方方面面，以及我们如何取长补短，改进思维模式对我们不好的影响。</p>
<h1 id="什么是固定思维模式"><a href="#什么是固定思维模式" class="headerlink" title="什么是固定思维模式"></a>什么是固定思维模式</h1><h1 id="什么是成长思维模式"><a href="#什么是成长思维模式" class="headerlink" title="什么是成长思维模式"></a>什么是成长思维模式</h1><h1 id="思维模式的影响"><a href="#思维模式的影响" class="headerlink" title="思维模式的影响"></a>思维模式的影响</h1>]]></content>
      <categories>
        <category>reader</category>
      </categories>
      <tags>
        <tag>reader</tag>
      </tags>
  </entry>
  <entry>
    <title>分享一个项目重启的shell脚本</title>
    <url>/blog/2020/05/24/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E9%87%8D%E5%90%AF%E7%9A%84shell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>今天分享一个重启 Django 项目的 shell 脚本，当然，修改一下也可以重启其他项目。</p>
<a id="more"></a>

<p>脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取项目进程号</span></span><br><span class="line">pids=$(ps -ef | grep 8000 | awk '&#123;if($9=="manage.py") &#123;print $2&#125;&#125;')</span><br><span class="line">echo "pid-"$&#123;pids&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">kill</span>项目进程</span></span><br><span class="line">kill -9 $&#123;pids&#125;</span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">    echo "kill success"</span><br><span class="line">    # 启动项目</span><br><span class="line">    nohup python manage.py runserver 127.0.0.1:8000 &amp;amp;</span><br><span class="line">    if [ $? -eq 0 ];then</span><br><span class="line">        echo "restart success"</span><br><span class="line">    else</span><br><span class="line">        echo "restart failure"</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    echo "kill failure"</span><br><span class="line">fi</span><br><span class="line">echo "end!!!"</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>国外优质开发者社区汇总</title>
    <url>/blog/2020/06/15/%E5%9B%BD%E5%A4%96%E4%BC%98%E8%B4%A8%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>今天分享一些优质的国外开发者社区，从这些社区中我们能了解软件行业的发展前景、各种新奇有趣的开发技术，帮助我们拓宽视野，增长知识，顺便学习一下英语。</p>
<p>开发者社区有下面这些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;dzone.com&#x2F;</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.infoq.com&#x2F;</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;bytes.com</span><br></pre></td></tr></table></figure>

<p>后续还会更新 …</p>
]]></content>
  </entry>
  <entry>
    <title>使用nginx搭建反向代理服务器</title>
    <url>/blog/2020/07/20/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>今天分享下，如何使用 nginx 搭建具有反向代理功能的服务器。</p>
<p>首先把 nginx 官方文档地址贴出来，有问题可以随时查阅：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>首先介绍下正向代理与反向代理的区别。</p>
<p>正向代理是发送请求时，隐藏了真正的客户端，即服务端不知道请求的客户端信息，客户端的请求都被代理服务器代替来请求。正向代理的常用场景就是在爬虫系统中。<br>反向代理是客户端不知道将要请求的服务器的信息，而是请求一个代理服务器，代理服务器再去请求上游服务器，并把上游服务器的响应返回给客户端。</p>
<p>其实，正向代理和反向代理的请求流程都是一样的，只是被代理对象不同。正向代理代理的对象是客户端，反向代理代理的对象是服务端，也就是说，谁被代理就隐藏了谁。</p>
<h2 id="反向代理服务器搭建"><a href="#反向代理服务器搭建" class="headerlink" title="反向代理服务器搭建"></a>反向代理服务器搭建</h2><p>下面看一个 nginx 配置反向代理的例子。</p>
<p>使用 nginx 搭建一个反向代理，上游服务器是一个静态资源 web 服务，配置如下：</p>
<p>nginx.conf：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                  <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">127.0.0.1:8081</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span>  docs/;   <span class="comment"># 指定静态资源目录</span></span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;  <span class="comment"># 这个设置会显示docs目录结构</span></span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;  <span class="comment"># 限制速率</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反向代理服务器配置如下：</p>
<p>nginx2.conf：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">include</span>       ../confs/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                  <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定上游服务,这里可以配置负载均衡算法</span></span><br><span class="line">    <span class="attribute">upstream</span> local &#123;</span><br><span class="line">        <span class="attribute">server</span>  <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8082</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">192.168.0.105</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        	<span class="comment"># 将请求转发到指定的上游服务器</span></span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://local;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别启动两个服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">sudo nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx2.conf</span><br></pre></td></tr></table></figure>

<p>启动后，再浏览器地址栏输入 <a href="http://192.168.0.105:8082/" target="_blank" rel="noopener">http://192.168.0.105:8082/</a> 便可以访问静态资源了。</p>
<h2 id="反向代理服务加入缓存功能"><a href="#反向代理服务加入缓存功能" class="headerlink" title="反向代理服务加入缓存功能"></a>反向代理服务加入缓存功能</h2><p>如果想提高响应速率，可以在 nginx 反向代理服务器上增加缓存功能。</p>
<p>反向代理增加缓存后，客户端的请求会首先从nginx缓存中获取数据，并返回给客户端，当没有缓存数据或者缓存数据过期时，才会请求上游服务器。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">include</span>       ../confs/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                  <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy_cache_path 参数用于设置缓存路径，并且可以指定其他参数</span></span><br><span class="line">    <span class="comment"># levels=1:2 参数指定缓存等级，值从1到3（暂时没弄明白这里的意思）</span></span><br><span class="line">    <span class="comment"># keys_zone  参数指定共享内存大小和名称</span></span><br><span class="line">    <span class="comment"># inactive 参数指定数据缓存的时长，默认10分钟</span></span><br><span class="line">    <span class="comment"># max_size 参数指定缓存数据的最大值</span></span><br><span class="line">    <span class="comment"># use_temp_path 指定是否使用临时文件存放缓存数据</span></span><br><span class="line">    指定保存缓存数据的路径, keys_zone表示开了一个10m的共享内存用于存放key，my_cache是共享内存名称 </span><br><span class="line">    <span class="attribute">proxy_cache_path</span>  /tmp/nginx_cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span> </span><br><span class="line">                      inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定上游服务,这里可以配置负载均衡算法</span></span><br><span class="line">    <span class="attribute">upstream</span> local &#123;</span><br><span class="line">        <span class="attribute">server</span>  <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8082</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">192.168.0.105</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 指定刚刚开辟的共享内存</span></span><br><span class="line">            <span class="attribute">proxy_cache</span>  my_cache;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定义缓存数据对应的 key 由什么组成</span></span><br><span class="line">            <span class="attribute">proxy_cache_key</span>  <span class="variable">$host</span><span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 给指定的想用窗台吗设置缓存过期时间，最后一个值时过期时间，可以是小时、分钟等单位</span></span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">302</span> <span class="number">1d</span>;            </span><br><span class="line">           </span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://local;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置中也介绍了一些常用的缓存参数，详细参数信息可以参考 nginx 的官方文档，文档地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_proxy_module.html#proxy_cache_path</span><br></pre></td></tr></table></figure>

<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>既然提到了反向代理，那么负载均衡是一定要说一下的。负载均衡的大意就是反向代理服务器把客户端的请求均匀的，或者按照一定的规则分发给上游服务器，从而保证服务可用性。</p>
<p>实现负载均衡有以下几种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 水平扩展：基于 Round-Robin或者least-connect算法进行请求分发</span><br><span class="line">2. 按功能扩展：根据请求URL，按照功能分发请求到上游服务器</span><br><span class="line">3. 基于用户信息扩展：根据请求客户端ip或者其他信息分发客户端请求（基于hash的某些算法）</span><br></pre></td></tr></table></figure>

<p>上面的方式可以组合起来使用，并不是只能单独使用。</p>
<p>nginx支持多种协议的反向代理，即客户端使用http协议请求服务时，nginx可以将其转换成fastcgi、uwsgi、rpc、websocket等协议，再向上游服务器发起请求。</p>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>nginx 中负责与上游服务器交互的模块是 upstream 模块，该模块中提供了一个基本的负载均衡算法 Round-Robin。</p>
<p>upstream 模块中，指定上游服务器的指令是 upstream，上面的例子中已经见过，该指令的作用域是 http 上下文。在 upstream 中，使用 server 指令指定上游服务器地址信息。</p>
<p>Round-Robin负载均衡算法介绍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该算法功能：以轮询的方式访问 server 指令指定的上游服务器，该算法集成在 Nginx 的 upstream 模块中。</span><br></pre></td></tr></table></figure>

<p>该算法提供以下指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wieght: 上游服务器权重，默认1</span><br><span class="line">max_conns：上游服务器的最大并发连接数，仅用于单 worker 进程，默认0，表示没有限制</span><br><span class="line">max_fails: 与fail_timeout配合使用。在fail_timeout时间段内，最大的失败次数。当达到最大失败次数时，在fail_timeout时间内，该上游服务器不再被选择</span><br><span class="line">fail_timeout:单位秒，默认为10，与max_fails配合使用，有两个功能：，指定一段时间内最大的失败次数max_fails；当到达max_fails后，该上游服务器不能再被访问</span><br></pre></td></tr></table></figure>



<h2 id="反向代理服务中加入负载均衡"><a href="#反向代理服务中加入负载均衡" class="headerlink" title="反向代理服务中加入负载均衡"></a>反向代理服务中加入负载均衡</h2><h3 id="基于-Round-Robin-算法的负载均衡"><a href="#基于-Round-Robin-算法的负载均衡" class="headerlink" title="基于  Round-Robin 算法的负载均衡"></a>基于  Round-Robin 算法的负载均衡</h3><h4 id="反向代理服务配置"><a href="#反向代理服务配置" class="headerlink" title="反向代理服务配置"></a>反向代理服务配置</h4><p>nginx.conf：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">        <span class="comment"># server_name  192.168.0.103;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line">        <span class="attribute">error_log</span>   logs/error.log;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span>  docs/;</span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;  <span class="comment"># 显示docs目录结构</span></span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;</span><br><span class="line">            <span class="comment"># index  index.html index.htm;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 指定反向代理的配置文件，配置文件中加入了负载均衡</span></span><br><span class="line">    <span class="attribute">include</span> reverse_proxy.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reverse_proxy.conf：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> proxy &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8011</span> weight=<span class="number">2</span> max_conns=<span class="number">2</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8012</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8091</span>;</span><br><span class="line">    <span class="attribute">error_log</span>  logs/reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  http://proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上游服务配置"><a href="#上游服务配置" class="headerlink" title="上游服务配置"></a>上游服务配置</h4><p>nginx2.conf：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">127.0.0.1:8082</span>;</span><br><span class="line">        <span class="comment"># server_name  192.168.0.103;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line">        <span class="attribute">error_log</span>   logs/error.log;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span>  docs/;</span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;  <span class="comment"># 显示docs目录结构</span></span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;</span><br><span class="line">            <span class="comment"># index  index.html index.htm;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 指定上游服务配置文件</span></span><br><span class="line">    <span class="attribute">include</span> upstream.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>upstream.conf：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 监听 8011 端口</span></span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8011</span>;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'8011 server response'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 监听 8012 端口</span></span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8012</span>;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'8012 server response'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的服务配置好以后，可以分别启动服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动反向代理服务：sudo nginx -c nginx.conf</span><br><span class="line">启动上游服务：sudo nginx -c nginx2.conf</span><br></pre></td></tr></table></figure>

<p>服务启动后，在终端多次执行 curl localhost:8091，可以发现，响应结果中，’8011 server response’ 和 ‘8012 server response’ 的比例大致为 2:1，这说明我们配置的负载均衡已经生效了。</p>
<h3 id="基于-ip-hash-的负载均衡"><a href="#基于-ip-hash-的负载均衡" class="headerlink" title="基于 ip hash 的负载均衡"></a>基于 ip hash 的负载均衡</h3><p>基于 ip 地址的 hash 算法可以根据客户端 ip 的不同，将请求转发到不同的上游服务器，它的配置如下（仅仅修改了 reverse_proxy.conf文件）：</p>
<p>reverse_proxy.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    set_real_ip_from  192.168.0.105;</span><br><span class="line">    real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，上面使用了 realip 模块的一些指令，现在的 nginx 版本中，realip模块默认没有编译进 nginx，如果要使用 该模块，需要将 realip 模块编译进 nginx 中。如何把某个模块编译进已安装的 nginx 中，可以查看我的另一篇博客。</p>
<p>上面指定的大致意思如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip_hash：根据用户的 ip 地址分发客户端的请求到上游服务器</span><br><span class="line">set_real_ip_from：设置可信任的地址</span><br><span class="line">real_ip_recursive on：表示原始客户端 ip 地址会被请求头中的某个非信任 ip 地址（由real_ip_header决定）替换</span><br><span class="line">real_ip_header X-Forwarded-For：表示以 X-Forwarded-For 中的最后一个 ip 作为 ip_hash 对应的 ip 地址</span><br></pre></td></tr></table></figure>

<p>具体解释可以查看官方文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_realip_module.html#set_real_ip_from</span><br></pre></td></tr></table></figure>

<p>配置完成重启后，我们可以在终端执行以下命令来测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &quot;X-Forwarded-For: 10.112.23.45&quot; localhost:8091</span><br></pre></td></tr></table></figure>

<p>可以更换 ip ，查看返回的结果。</p>
<h3 id="基于关键字-hash-的负载均衡"><a href="#基于关键字-hash-的负载均衡" class="headerlink" title="基于关键字  hash 的负载均衡"></a>基于关键字  hash 的负载均衡</h3><p>使用关键字 hash 时，reverse_proxy.conf的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    # 使用特定的字符串作为hash值</span><br><span class="line">    hash user_$arg_username;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    set_real_ip_from  192.168.0.105;</span><br><span class="line">    real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求服务时时，传入不同的 username 参数，会请求不同的上游服务器。</p>
<h3 id="hash算法优化"><a href="#hash算法优化" class="headerlink" title="hash算法优化"></a>hash算法优化</h3><p>当有上游服务器宕机或者需要扩容时，hash 算法会导致负载均衡的路由发生变化，这样会导致一系列问题（例如缓存失效）。一致性 hash 算法可以解决这个问题。</p>
<p>nginx 中配置一致性 hash 比较简单，配置如下：</p>
<p>reverse_proxy.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    # 使用特定的字符串作为hash值</span><br><span class="line">    hash user_$arg_username consistent;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # set_real_ip_from  192.168.0.105;</span><br><span class="line">    # real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原来的 hash key 后面加上 consistent 即可实现一致性 hash，具体介绍可以查看官方文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_upstream_module.html#hash</span><br></pre></td></tr></table></figure>

<h3 id="基于最少连接数算法的负载均衡"><a href="#基于最少连接数算法的负载均衡" class="headerlink" title="基于最少连接数算法的负载均衡"></a>基于最少连接数算法的负载均衡</h3><p>最少连接数算法中，nginx 反向代理服务器会将客户端请求转发到连接数最少的上游服务器中。当有多个上游服务器最少连接数相同时，会按照 Roubd-Robin 算法将请求发送到这几个服务器中的一个。最少连接数算法的配置如下：</p>
<p>reverse_proxy.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream proxy &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 127.0.0.1:8011 weight&#x3D;2 max_conns&#x3D;2 max_fails&#x3D;2 fail_timeout&#x3D;5;</span><br><span class="line">    server 127.0.0.1:8012 weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # set_real_ip_from  192.168.0.105;</span><br><span class="line">    # real_ip_recursive on;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line"></span><br><span class="line">    listen 8091;</span><br><span class="line">    error_log  logs&#x2F;reverse_proxy.err.log;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 upstream 上下文中，加入 least_conn 指令即可配置最少连接数算法。</p>
<p>官方文档如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_upstream_module.html#least_conn</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>提高文本查询效率的几个命令</title>
    <url>/blog/2021/05/22/%E6%8F%90%E9%AB%98%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p> 查找日志定位问题时，往往被查询的日志可能是一个很大的文件或者是压缩文件，查找时为了提高效率，我们可以使用 more、zgrep 等命令来查找。</p>
<a id="more"></a>

<h1 id="more"><a href="#more" class="headerlink" title="more"></a>more</h1><p>more 命令与 cat 命令类似，但是查找文件时，more 是一页一页的显示，这样更方便我们查找。</p>
<p>我们执行 more –help ，可以看看 more 有哪些参数可以使用。</p>
<p>more 的基本用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 空格键：往下显示一页</span><br><span class="line">2. b键：往上显示一页</span><br><span class="line">3. more +n：从第n行开始显示</span><br><span class="line">4. more -n: 自定义每页显示行数</span><br><span class="line">5. &#x2F;待查找字符串：查找特定的字符串</span><br><span class="line">6. q：退出more命令</span><br><span class="line"></span><br><span class="line">还可以使用 more --help 查看更多参数。</span><br></pre></td></tr></table></figure>



<h1 id="zgrep"><a href="#zgrep" class="headerlink" title="zgrep"></a>zgrep</h1><p>zgrep 命令与 grep 命令功能一样，只不过 zgrep 可以用来查找压缩文件中的特定内容而不用将文件解压，这对于查询大压缩文件的查找很有帮助。</p>
<p>zgrep 的基本用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. zgrep 待查找内容 压缩文件（若查找的是二进制文件，需要加上参数 -a，下同）</span><br><span class="line">2. zgrep -A n 待查找内容 压缩文件 （获取待查找内容的后面 n 行内容）</span><br><span class="line">3. zgrep -B n 待查找内容 压缩文件 （获取待查找内容的前面 n 行内容）</span><br><span class="line">4. zgrep -C n 待查找内容 压缩文件 （获取待查找内容的前后 n 行内容）</span><br></pre></td></tr></table></figure>

<p>类似的命令还有 zmore、zcat 等，感兴趣的同学可以下去学习一下。</p>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>less  命令与 more 命令类似，但是功能比 more 更强大，它的基本用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less用法：</span><br><span class="line">1. less 文件名 查找指定的文件</span><br><span class="line">常用参数：</span><br><span class="line"> -i：搜索时忽略大小写</span><br><span class="line"> -m：增加百分比的显示</span><br><span class="line"> -s：合并连续空行为一行</span><br><span class="line"> -N：显示行号</span><br><span class="line">2. d 向下翻页</span><br><span class="line">3. u 向上翻页</span><br><span class="line">4. g 跳到第一行</span><br><span class="line">5. G 跳到最后一行</span><br><span class="line">6. &#x2F;字符串：向下搜索字符串</span><br><span class="line">7. ?字符串：向上搜索字符串</span><br></pre></td></tr></table></figure>

<p>less 的更多用法，可以执行 less –help 查看。</p>
<p>以上就是文本查找中可能常用到的几个查找命令。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用三种方式搭建正向代理服务器</title>
    <url>/blog/2020/04/19/%E4%BD%BF%E7%94%A8%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>今天介绍下如何使用 nginx、apache 和 squid 搭建正向代理服务器。下面的操作都是在 centos8.1 上完成的。</p>
<a id="more"></a>

<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>使用 nginx 正向代理时，需要先把 ngx_http_proxy_connect_module 模块编译进 nginx 中，编译方式可参考上一篇文章。</p>
<p>这里我搭建了一个 RSSHub 服务用于发起请求，RSSHub 服务器上的代理环境变量配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PROXY_PROTOCOL&#x3D;http</span><br><span class="line">export PROXY_HOST&#x3D;****</span><br><span class="line">export PROXY_PORT&#x3D;8090</span><br></pre></td></tr></table></figure>

<p>nginx正向代理搭建成功后，在本机请求 RSSHub 服务时，会通过代理向目标网址发送请求。</p>
<p>nginx 配置正向代理时，将下面的配置加到 nginx.conf 中即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8090;                   #监听端口</span><br><span class="line">        resolver 8.8.8.8;      #dns解析地址</span><br><span class="line">        server_name  _;</span><br><span class="line">        proxy_connect;</span><br><span class="line">        proxy_connect_allow 443 563;</span><br><span class="line">        # proxy_connect_connect_timeout 10s;</span><br><span class="line">        # proxy_connect_read_timeout 10s;</span><br><span class="line">        # proxy_connect_send_timeout 10s;</span><br><span class="line">      </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">             proxy_pass $scheme:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">             proxy_set_header HOST $http_host;</span><br><span class="line">             proxy_buffers 256 4k;</span><br><span class="line">             proxy_max_temp_file_size 0k;</span><br><span class="line">             proxy_connect_timeout 30;</span><br><span class="line">             proxy_send_timeout 60;</span><br><span class="line">             proxy_read_timeout 60;</span><br><span class="line">             #proxy_next_upstream error timeout invalid_header http_502;</span><br><span class="line">            #root   html;</span><br><span class="line">            #            #index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">                                                                     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 location 块中，还有很多其他的命令，感兴趣的小伙伴可以查阅相关文档。</p>
<p>ngx_http_proxy_connect_module 模块的 github 地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.github.com&#x2F;chobits&#x2F;ngx_http_proxy_connect_module</span><br></pre></td></tr></table></figure>



<h1 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装：</span><br><span class="line">yum install -y httpd</span><br><span class="line"></span><br><span class="line">启动：</span><br><span class="line">systemctl enable httpd</span><br><span class="line">systemctl start httpd</span><br><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure>



<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改文件 &#x2F;etc&#x2F;httpd&#x2F;conf.modules.d&#x2F;00-proxy.conf，最终内容如下：</span><br><span class="line"># This file configures all the proxy modules:</span><br><span class="line">LoadModule proxy_module modules&#x2F;mod_proxy.so</span><br><span class="line">LoadModule lbmethod_bybusyness_module modules&#x2F;mod_lbmethod_bybusyness.so</span><br><span class="line">LoadModule lbmethod_byrequests_module modules&#x2F;mod_lbmethod_byrequests.so</span><br><span class="line">LoadModule lbmethod_bytraffic_module modules&#x2F;mod_lbmethod_bytraffic.so</span><br><span class="line">LoadModule lbmethod_heartbeat_module modules&#x2F;mod_lbmethod_heartbeat.so</span><br><span class="line">LoadModule proxy_ajp_module modules&#x2F;mod_proxy_ajp.so</span><br><span class="line">LoadModule proxy_balancer_module modules&#x2F;mod_proxy_balancer.so</span><br><span class="line">LoadModule proxy_connect_module modules&#x2F;mod_proxy_connect.so</span><br><span class="line">LoadModule proxy_express_module modules&#x2F;mod_proxy_express.so</span><br><span class="line">LoadModule proxy_fcgi_module modules&#x2F;mod_proxy_fcgi.so</span><br><span class="line">LoadModule proxy_fdpass_module modules&#x2F;mod_proxy_fdpass.so</span><br><span class="line">LoadModule proxy_ftp_module modules&#x2F;mod_proxy_ftp.so</span><br><span class="line">LoadModule proxy_http_module modules&#x2F;mod_proxy_http.so</span><br><span class="line">LoadModule proxy_hcheck_module modules&#x2F;mod_proxy_hcheck.so</span><br><span class="line">LoadModule proxy_scgi_module modules&#x2F;mod_proxy_scgi.so</span><br><span class="line">LoadModule proxy_uwsgi_module modules&#x2F;mod_proxy_uwsgi.so</span><br><span class="line">LoadModule proxy_wstunnel_module modules&#x2F;mod_proxy_wstunnel.so</span><br><span class="line"></span><br><span class="line">ProxyRequests On</span><br><span class="line">ProxyVia On</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Proxy &quot;*&quot;&gt;</span><br><span class="line">&lt;&#x2F;Proxy&gt;</span><br></pre></td></tr></table></figure>

<p>配置完成后，可以执行 systemctl start httpd 命令启动 apache 服务。</p>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Sun Apr 19 02:20:38.711238 2020] [proxy:error] [pid 23913:tid 140212453746432] (13)Permission denied: [client 113.104.182.232:38242] AH00939: CONNECT: attempt to connect to 47.89.66.201:443 (www.jianshu.com) failed</span><br></pre></td></tr></table></figure>

<p>启动 apache 服务后，发起请求时，若代理服务器出现上面的错误，则可能与 centos 的 SELinux 有关，可以执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setsebool -P httpd_can_network_connect&#x3D;1</span><br></pre></td></tr></table></figure>



<h1 id="squid"><a href="#squid" class="headerlink" title="squid"></a>squid</h1><p>squid是一个高性能的代理缓存服务器，squid支持FTP、gopher、HTTPS和HTTP协议。我们也可以使用它来搭建代理服务器。</p>
<p>搭建步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装squid：</span><br><span class="line">yum install squid -y </span><br><span class="line"></span><br><span class="line">配置：</span><br><span class="line">修改文件 &#x2F;etc&#x2F;squid&#x2F;squid.conf ，添加以下内容：</span><br><span class="line">acl local src 192.168.5.0&#x2F;24   	   &#x2F;&#x2F;允许192.168.5.0&#x2F;24网段内所有客户机访问代理服务器</span><br><span class="line">http_access allow local</span><br><span class="line"></span><br><span class="line">启动：驱动squid的服务</span><br><span class="line">systemctl start squid </span><br><span class="line"></span><br><span class="line">查看日志：</span><br><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;squid&#x2F;access.log</span><br><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;squid&#x2F;error.log</span><br></pre></td></tr></table></figure>



<p>上面的代理服务搭建完成并启动后，可以在本地访问  RSSHub 服务，通过查看日志来确认代理服务是否搭建成功。</p>
<p>上面简单介绍了正向代理服务器的搭建，感兴趣的小伙伴可以进一步了解。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>微信公众号开发中的支付流程</title>
    <url>/blog/2020/06/14/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>今天聊一下微信公众号开发在授权网页中的支付流程。</p>
<a id="more"></a>

<h1 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h1><p>微型公众号开发有以下几个步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.获取全局access_token</span><br><span class="line">2.获取网页授权的access_token和refresh_token</span><br><span class="line">3.获取网页授权的签名(前端用于获取调用JSSDK的权限)</span><br><span class="line">4.公众号支付-调用统一下单接口获取prepay_id</span><br><span class="line">5.公众号支付-将签名返回给前端用于请求微信公众号支付</span><br></pre></td></tr></table></figure>

<p>其中步骤1、2根据微信开发文档很容易完成；第3步就开始用到签名了，这一步的签名相对来说比较好做；第4、5步微信支付中的签名对第一次做微信支付开发的小伙伴来说就有点麻烦了。</p>
<h1 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h1><p>下面从第3步开始详细介绍下每个步骤。</p>
<h2 id="获取网页授权签名"><a href="#获取网页授权签名" class="headerlink" title="获取网页授权签名"></a>获取网页授权签名</h2><p>获取网页授权的签名，前端调用JSSDK时，需要使用这个签名。这一步骤中，我们需要给前端返回如下数据（除jsApiList）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">    debug: true, &#x2F;&#x2F; 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">    appId: &#39;&#39;, &#x2F;&#x2F; 必填，公众号的唯一标识</span><br><span class="line">    timestamp: , &#x2F;&#x2F; 必填，生成签名的时间戳</span><br><span class="line">    nonceStr: &#39;&#39;, &#x2F;&#x2F; 必填，生成签名的随机串</span><br><span class="line">    signature: &#39;&#39;,&#x2F;&#x2F; 必填，签名</span><br><span class="line">    jsApiList: [] &#x2F;&#x2F; 必填，需要使用的JS接口列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中，signature是一个关键的参数。生成签名的规则可以去这里 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a> 的 附录1-JS-SDK使用权限签名算法 中查看<br>生成签名的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        url = request.data[<span class="string">"url"</span>]</span><br><span class="line">        logger.debug(<span class="string">"url:%s"</span>, url)</span><br><span class="line">        <span class="comment"># 权限验证配置信息</span></span><br><span class="line">        platform_info = &#123;<span class="string">"appId"</span>: WXConfig.APPID, <span class="string">"timestamp"</span>: <span class="number">0</span>, <span class="string">"nonceStr"</span>: <span class="string">''</span>, <span class="string">"signature"</span>: <span class="string">''</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 时间戳</span></span><br><span class="line">        timestamp = int(time.time())</span><br><span class="line">        <span class="comment"># 随机字符串，改方法自己实现即可</span></span><br><span class="line">        noncestr = ToolToken.generate_noncestr()</span><br><span class="line">        <span class="comment"># jsapi_ticket</span></span><br><span class="line">        ticket = cache.get(<span class="string">"jsapi_ticket"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ticket:</span><br><span class="line">            <span class="comment"># 重新获取jsapi_ticket</span></span><br><span class="line">            wx = WXToken()</span><br><span class="line">            <span class="comment"># 此处根据说明文档获取jsapi_ticket即可</span></span><br><span class="line">            wx.get_jsapi_ticket()</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"ticket:%s"</span>, ticket)</span><br><span class="line">        <span class="comment"># 组合字符串，其中url是需要前端传给我们的</span></span><br><span class="line">        info_string = <span class="string">"jsapi_ticket="</span> + ticket + <span class="string">"&amp;amp;noncestr="</span> + noncestr + <span class="string">"&amp;amp;timestamp="</span> + str(timestamp) + <span class="string">"&amp;amp;url="</span> + url</span><br><span class="line"></span><br><span class="line">        signature = hashlib.sha1(info_string.encode(<span class="string">"utf-8"</span>)).hexdigest()</span><br><span class="line">        platform_info[<span class="string">"signature"</span>] = signature</span><br><span class="line">        platform_info[<span class="string">"timestamp"</span>] = timestamp</span><br><span class="line">        platform_info[<span class="string">"nonceStr"</span>] = noncestr</span><br><span class="line">        <span class="keyword">return</span> Response(platform_info, status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure>

<h2 id="调用支付相关接口"><a href="#调用支付相关接口" class="headerlink" title="调用支付相关接口"></a>调用支付相关接口</h2><p>从这一步就开始调用微信支付的相关接口了。这里一定要注意，调用微信支付接口时，一定要看最新的说明文档，不要看旧的，不然会出现错误，并且不容易找到原因。<br>调用统一下单接口的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">unify_order</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    请求微信统一下单接口</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = <span class="string">"https://api.mch.weixin.qq.com/pay/unifiedorder"</span></span><br><span class="line">    headers = &#123;<span class="string">'Content-Type'</span>: <span class="string">'application/xml'</span>&#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.post(url=url, data=self.xml_data, headers=headers) <span class="keyword">as</span> res:</span><br><span class="line">            ret = <span class="keyword">await</span> res.text()</span><br><span class="line">            logger.debug(<span class="string">"ret:%s"</span>, ret)</span><br><span class="line">            self.unify_order_data = self.xml_to_dict(ret)</span><br><span class="line">            logger.debug(<span class="string">"self.unify_order_data:%s"</span>, self.unify_order_data)</span><br></pre></td></tr></table></figure>

<p>其中，self.xml_data内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line">    &lt;appid&gt;你的appid&lt;&#x2F;appid&gt;</span><br><span class="line">    &lt;attach&gt;pay&lt;&#x2F;attach&gt;</span><br><span class="line">    &lt;body&gt;paytest&lt;&#x2F;body&gt;</span><br><span class="line">    &lt;mch_id&gt;商户号&lt;&#x2F;mch_id&gt;</span><br><span class="line">    &lt;detail&gt;apple&lt;&#x2F;detail&gt;</span><br><span class="line">    &lt;nonce_str&gt;你生成的随机字符串&lt;&#x2F;nonce_str&gt;</span><br><span class="line">    &lt;notify_url&gt;通知地址&lt;&#x2F;notify_url&gt;</span><br><span class="line">    &lt;openid&gt;你的openid&lt;&#x2F;openid&gt;</span><br><span class="line">    &lt;out_trade_no&gt;订单号&lt;&#x2F;out_trade_no&gt;</span><br><span class="line">    &lt;spbill_create_ip&gt;外网可访问ip地址&lt;&#x2F;spbill_create_ip&gt;</span><br><span class="line">    &lt;total_fee&gt;订单金额&lt;&#x2F;total_fee&gt;</span><br><span class="line">    &lt;trade_type&gt;JSAPI&lt;&#x2F;trade_type&gt;</span><br><span class="line">    &lt;sign_type&gt;MD5&lt;&#x2F;sign_type&gt;</span><br><span class="line">    &lt;sign&gt;签名&lt;&#x2F;sign&gt;</span><br><span class="line">&lt;&#x2F;xml&gt;</span><br></pre></td></tr></table></figure>

<p>其中最后一个参数sign的值是需要通过其他参数加密得到的，签名生成规则可以参考微信官方文档。这里需要说明一下，一定要加上sign_type这个参数(虽然官网说明文档中把这个参数标记为不是必须的)，显式指定加密方法，不然可能得到签名错误的结果。</p>
<p>上面xml中的参数可以根据需求添加。</p>
<p>请求成功后，会返回prepay_id这个值，在下一步中会用到。返回结果可能如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;return_code&#39;: &#39;SUCCESS&#39;, &#39;return_msg&#39;: &#39;OK&#39;, &#39;appid&#39;: appid, &#39;mch_id&#39;: 商户号, &#39;nonce_str&#39;: 随机字符串, &#39;sign&#39;: 签名, &#39;result_code&#39;: &#39;SUCCESS&#39;, &#39;prepay_id&#39;: prepay_id, &#39;trade_type&#39;: &#39;JSAPI&#39;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="将信息返回给前端"><a href="#将信息返回给前端" class="headerlink" title="将信息返回给前端"></a>将信息返回给前端</h2><p>这一步中需要将以下信息返回个前端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.chooseWXPay(&#123;</span><br><span class="line">    timestamp: 0, &#x2F;&#x2F; 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符</span><br><span class="line">    nonceStr: &#39;&#39;, &#x2F;&#x2F; 支付签名随机串，不长于 32 位</span><br><span class="line">    package: &#39;&#39;, &#x2F;&#x2F; 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id&#x3D;\*\*\*）</span><br><span class="line">    signType: &#39;&#39;, &#x2F;&#x2F; 签名方式，默认为&#39;SHA1&#39;，使用新版支付需传入&#39;MD5&#39;</span><br><span class="line">    paySign: &#39;&#39;, &#x2F;&#x2F; 支付签名</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">        &#x2F;&#x2F; 支付成功后的回调函数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>除了success，其他参数都需要返回给前端。从 timestamp到paySign这几个参数中，最难处理的又是签名paySign。当你看到上面那段js代码时，可能你看到的文档已经过时了，有可能误导你。生成签名给前端时可能只使用了timestamp,nonceStr,package,signType这几个参数，但是你将这样生成的名返回前端时，前端请求后可能得到签名认证错误的提示。</p>
<p>正确的签名生成方式是timestamp,nonceStr,package,signType和key(微信商户平台配置的key)都需要参与签名；并且package的值不是第4步中返回的prepay_id的值，而是”prepay_id=”+prepay_id这样一个字符串。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appId&#x3D;$&#123;appid&#125;&amp;nonceStr&#x3D;$&#123;nonceStr&#125;&amp;package&#x3D;prepay_id&#x3D;$&#123;prepay_id&#125;&amp;signType&#x3D;MD5&amp;timeStamp&#x3D;$&#123;timeStamp&#125;&amp;key&#x3D;$&#123;key&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的字符串加密即可获得paySign的值。<br>前端获得签名后，再请求微信服务器，下面的支付流程就可以继续下去了。</p>
]]></content>
      <categories>
        <category>Frontend</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用github搭建个人博客</title>
    <url>/blog/2019/11/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>最近使用 hexo + github 搭建了一个博客系统，现总结搭建步骤并记录如下。</p>
<a id="more"></a>

<h2 id="1-安装相关软件"><a href="#1-安装相关软件" class="headerlink" title="1. 安装相关软件"></a>1. 安装相关软件</h2><p>在windows上安装 node.js，npm，git，具体安装步骤可以百度。</p>
<h2 id="2-创建github仓库"><a href="#2-创建github仓库" class="headerlink" title="2. 创建github仓库"></a>2. 创建github仓库</h2><p>在github上创建名称为 你的用户名.github.io 的仓库，后面搭建成功后，可以在浏览器上输入 https://你的用户名.github.io 来访问博客。</p>
<p>仓库创建成功后，需要配置SSH Key，以便后续提交博客到仓库中。在windows下 git 的命令行中输入 ssh-keygen 生成 公钥和私钥（公、私钥的文件名称使用默认的即可，不使用默认的文件名后需提交博客可能提示无权限），生成文件后，将 id_rsa.pub 中的内容添加到 仓库 –&gt; Settings –&gt; Deploy key 中。</p>
<h2 id="3-使用hexo写博客"><a href="#3-使用hexo写博客" class="headerlink" title="3. 使用hexo写博客"></a>3. 使用hexo写博客</h2><p>hexo是一个快速、简单、功能强大的博客框架，在Markdown中写好博客后，hexo可以使用优美的主题将博客生成静态文件。 其官网如下：<a href="http://hexo.io/" target="_blank" rel="noopener">http://hexo.io</a></p>
<h3 id="3-1-安装hexo并初始化"><a href="#3-1-安装hexo并初始化" class="headerlink" title="3.1 安装hexo并初始化"></a>3.1 安装hexo并初始化</h3><p>使用 npm 安装 hexo：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<p>然后在本地文件夹新建 hexo工作目录并初始化该目录：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd D:\hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>初始化过程中会下载一些 js 模块，存放在 node_modules 文件夹下。</p>
<p>然后可以执行下面的命令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hexo g  # hexo generate 的缩写，生成静态页面至public目录下</span><br><span class="line">hexo s  # hexo server 的缩写， 启动服务 （默认 http://localhost:4000）</span><br></pre></td></tr></table></figure>

<p>在浏览器上访问 <a href="http://localhost:4000，可以看到有一篇默认的博客和主题。">http://localhost:4000，可以看到有一篇默认的博客和主题。</a></p>
<h3 id="3-2-更换主题"><a href="#3-2-更换主题" class="headerlink" title="3.2 更换主题"></a>3.2 更换主题</h3><p>官方主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<p>可以到这里寻找自己喜欢的主题，并将其克隆到 hexo工作目录的themes目录下；然后在hexo目录下的_config.yml文件中修改 theme的配置（例如 修改 theme: landscape 为 theme: clean-blog）；最后执行hexo g命令即可。</p>
<p>更改完主题后，可以重启服务，访问 <a href="http://localhost:4000，查看主题的效果。">http://localhost:4000，查看主题的效果。</a></p>
<h3 id="3-3-deploy配置"><a href="#3-3-deploy配置" class="headerlink" title="3.3 deploy配置"></a>3.3 deploy配置</h3><p>在 _config.yml 文件中修改下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:wyzane&#x2F;wyzane.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>将 repository 的值修改成你自己的github仓库名，修改完成后，执行 hexo d（hexo deploy）就可以将代码提交至执行的github仓库中。</p>
<h3 id="3-4-编写博客"><a href="#3-4-编写博客" class="headerlink" title="3.4 编写博客"></a>3.4 编写博客</h3><p>执行 hexo new “文章名称” 会在 hexo的 source\_posts目录下新建一篇文章，文章是Markdown格式，推荐使用Typora软件来编辑md文件。</p>
<p>编辑好文章后，执行 hexo g命令，会将md文件转换成html静态文件并添加到public目录下对应的目录中，最后执行 hexo d将更新提交至github仓库中。</p>
<p>访问上面提到的地址，就可以看到新增的博客文章。</p>
<h3 id="3-5-hexo常用命令"><a href="#3-5-hexo常用命令" class="headerlink" title="3.5 hexo常用命令"></a>3.5 hexo常用命令</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo new "name" # 新建文章</span><br><span class="line">hexo new page "name" # 新建页面</span><br><span class="line">hexo generate # 生成静态页面至public目录</span><br><span class="line">hexo server # 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span><br><span class="line">hexo deploy # 部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  # 查看Hexo的版本</span><br><span class="line"></span><br><span class="line"># 缩写如下：</span><br><span class="line">hexo n == hexo <span class="keyword">new</span></span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>



<h3 id="3-6-config-yml文件"><a href="#3-6-config-yml文件" class="headerlink" title="3.6 _config.yml文件"></a>3.6 _config.yml文件</h3><p>_config.yml文件是 hexo 的配置文件，里面主要有以下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">wyzane's</span> <span class="string">skill</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">wyzane</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://wyzane.cc</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing index.html from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## Use post's date for updated date unless set in front-matter</span></span><br><span class="line"><span class="attr">use_date_for_updated:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the 'source/' folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">clean-blog</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:wyzane/wyzane.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>_config.yml 文件中可以配置标题、主题、分页等参数。</p>
<p>使用 hexo + github 搭建博客有以下优点：</p>
<ol>
<li>简单，成本低，</li>
<li>支持使用Markdown编写博客，</li>
<li>扩展对 node.js，hexo，github等知识的应用。</li>
</ol>
<p>更多详细信息可以参考这篇文章：<a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa</a></p>
]]></content>
  </entry>
  <entry>
    <title>项目开发中接口如何保证幂等性</title>
    <url>/blog/2020/06/21/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    <content><![CDATA[<p>当用户在客户端向服务器发起请求时，如果网络出现问题，用户可能会对同一个接口发起多次请求，幂等性就是要保证多次请求的结果一致。</p>
<a id="more"></a>

<p>幂等性在支付场景中使用的较多，它能保证用户在下单扣款时，不会由于网络原因而出现重复扣款的现象。</p>
<p>那么如何实现幂等性呢？最常用的有两种方式：方式一：代码中通过逻辑判断实现，方式二：给需要幂等的接口加一个唯一id。</p>
<p>下面以支付接口为例。</p>
<h1 id="逻辑判断实现幂等性"><a href="#逻辑判断实现幂等性" class="headerlink" title="逻辑判断实现幂等性"></a>逻辑判断实现幂等性</h1><p>当用户支付完成准备扣款时，可以使用订单id加订单状态来实现幂等性。用户第一次扣款后，由于网络原因，又发起一次支付，这时可以根据客户端传入的订单id加订单表中的订单状态来判断订单是否已支付。若已支付，则返回结果就行，不用再执行一次扣款炒操作。</p>
<h1 id="接口添加唯一id"><a href="#接口添加唯一id" class="headerlink" title="接口添加唯一id"></a>接口添加唯一id</h1><p>用户请求购买接口时，返回一个唯一id，同时将id保存在redis中。用户支付时，需要传入此id，若不传则提示支付失败。用户支付时，支付接口需要校验此id与redis中保存id的一致性，若一致，则支付成功，同时删除redis中的id，否则支付失败。</p>
<p>上面就是两种实现幂等性的方式，若还有其他的方式，欢迎交流。</p>
]]></content>
  </entry>
  <entry>
    <title>操作系统结构及其进程调度</title>
    <url>/blog/2020/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p>大学里面学过的操作系统相关知识都已经忘的差不多了，为了巩固知识，最近重新回顾了一下操作系统的知识。今天整理下操作系统结构和进程调度相关知识。</p>
<a id="more"></a>

<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><p>操作系统主要有以下结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 整体式结构</span><br><span class="line">2. 层次式结构</span><br><span class="line">3. 微内核结构</span><br></pre></td></tr></table></figure>

<h4 id="整体式结构"><a href="#整体式结构" class="headerlink" title="整体式结构"></a>整体式结构</h4><p>整体式结构是以模块为基础的结构，每个模块实现不同的功能，并且模块之间可以相互调用，通过操作系统接口为外部应用程序提供功能服务。</p>
<p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/%E6%95%B4%E4%BD%93%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="整体式结构"></p>
<h4 id="层次式结构"><a href="#层次式结构" class="headerlink" title="层次式结构"></a>层次式结构</h4><p>TCP/IP协议栈的设计就使用了层次结构的思想，不同层之间实现不同的协议，提供不同的功能。</p>
<p><img src="%E5%B1%82%E6%AC%A1%E5%BC%8F%E7%BB%93%E6%9E%841.png" alt="层次式结构"></p>
<p>设计操作系统时，也可以使用层次结构的设计思想。</p>
<p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/%E5%B1%82%E6%AC%A1%E5%BC%8F%E7%BB%93%E6%9E%842.png" alt="层次式结构2"></p>
<p>上图中，最底层提供了最基础的功能，每一层服务都会依赖其下一层提供的功能。</p>
<h4 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h4><p>这种结构中操作系统由微内核和核外服务器组成。</p>
<p>其中微内核只提供操作系统最基本、最核心的功能，包括与硬件的交互、客户端和服务器间的通信等。</p>
<p>核外服务器提供操作系统的服务功能，处理应用程序的请求，它由若干服务器和进程共同组成。</p>
<h4 id="CPU的态"><a href="#CPU的态" class="headerlink" title="CPU的态"></a>CPU的态</h4><p>就是CPU的工作状态，描述了进程能够操作资源和指令的权限。</p>
<p>CPU的态主要有内核态和用户态两种。</p>
<p>处于内核态的进程能够访问所有资源和指令；处于用户态的进程对资源的访问和指令操作会受到限制，仅能访问部分资源。</p>
<p>当进程执行不同的功能时，会进入不同的工作状态，例如当程序需要操作内存分配资源时，用户态不能满足条件，进程就会由用户态切换至内核态，分配完成后，又会从内核态切换为用户态。</p>
<h3 id="操作系统进程调度"><a href="#操作系统进程调度" class="headerlink" title="操作系统进程调度"></a>操作系统进程调度</h3><p>当多个进程在CPU中运行时，CPU有一套调度算法来决定下一时刻执行哪个进程，从而保证每个进程都有可能被调度，保证进程的顺利执行。下面介绍进程调度的几种策略。</p>
<h4 id="进程调度目标"><a href="#进程调度目标" class="headerlink" title="进程调度目标"></a>进程调度目标</h4><p>首先，进程调度的目的是为了保证进程的顺利执行，同时尽可能达到以下目标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 响应速度尽可能快</span><br><span class="line">2. 进程处理的时间尽可能短</span><br><span class="line">3. 系统吞吐量尽可能大</span><br><span class="line">4. 资源利用率尽可能高</span><br><span class="line">5. 对所有进程公平</span><br><span class="line">6. 避免饥饿</span><br><span class="line">7. 避免死锁</span><br></pre></td></tr></table></figure>

<p>对于不同的调度策略，它们所达到的目标是不同的。</p>
<p>进程调度时还有两个可量化指标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 周转时间&#x2F;平均周转时间</span><br><span class="line">2. 带权周转时间&#x2F;带权平均周转时间</span><br><span class="line"></span><br><span class="line">周转时间：</span><br><span class="line">进程周转时间是进程从交给计算机到最终执行完成所花费的时间，进程周转时间表明了进程在系统中停留时间的长短。其计算公式如下:</span><br><span class="line">t &#x3D; tc -ts</span><br><span class="line">t: 表示进程周转时间</span><br><span class="line">tc: 进程完成的时间</span><br><span class="line">ts: 进程提交的时间</span><br><span class="line"></span><br><span class="line">平均周转时间：</span><br><span class="line">t &#x3D; (t1 + t2 + .. + tn) &#x2F; n</span><br><span class="line">平均周转时间越短，意味着这些进程在系统内停留的时间越短，因而系统吞吐量也就越大，资源利用率也越高。</span><br><span class="line"></span><br><span class="line">带权周转时间：</span><br><span class="line">带权周转时间表示进程在系统中停留的相对时间，其计算公式如下：</span><br><span class="line">w &#x3D; t&#x2F;tr</span><br><span class="line">t: 进程周转时间</span><br><span class="line">tr: 进程在CPU上的运行时间</span><br><span class="line"></span><br><span class="line">平均带权周转时间：</span><br><span class="line">w &#x3D; (w1 + w2 + .. + wn) &#x2F; n</span><br></pre></td></tr></table></figure>



<h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><p>常用的进程调度算法有下面这些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 先来先服务调度</span><br><span class="line">2. 短作业优先调度</span><br><span class="line">3. 响应比高者优先调度</span><br><span class="line">4. 优先数调度算法</span><br><span class="line">5. 循环轮转调度算法</span><br><span class="line">6. 可变时间片轮转调度算法</span><br><span class="line">7. 多重时间片循环调度算法</span><br></pre></td></tr></table></figure>



<p>下面介绍其中的几个调度算法。</p>
<p>先来先服务调度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按照进程进入CPU的先后顺序来调度，先进入的进程优先执行。</span><br><span class="line"></span><br><span class="line">不足：仅仅考虑了进程的等待时间而没有考虑进程的执行时间，如果一个进程执行时间很长，则会阻塞下面执行时间较短的那些进程，不利于执行时间短的进程。</span><br></pre></td></tr></table></figure>



<p>短作业优先调度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选取运行时间短的进程优先执行。</span><br><span class="line"></span><br><span class="line">不足：仅仅考虑了进程的执行时间而没有考虑进程的等待时间，不利于执行时间长的进程，对于执行时间长的进程，可能一直不会被执行。</span><br></pre></td></tr></table></figure>



<p>响应比高者优先算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">响应比是进程的响应时间和运行时间的比值：</span><br><span class="line">响应比 &#x3D; (响应时间&#x2F;运行时间) &#x3D; (等待时间 + 运行时间)&#x2F;运行时间 &#x3D; 1 + 等待时间&#x2F;运行时间</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">若进程等待时间相同， 则运行时间越短的进程响应比越高，越容易被执行，此时有利于执行时间短的进程。</span><br><span class="line">若进程的运行时间相同，则等待时间越长，响应比越高，越容易被执行，此时有利于长时间等待的进程。</span><br></pre></td></tr></table></figure>



<p>循环轮转调度算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个就是 Round-Robin 算法，在 Nginx 的负载均衡中也有用到。</span><br><span class="line"></span><br><span class="line">该调度算法是把所有进程放入队列中，然后按照先进先出的顺序依次执行队列中的进程。执行进程时，会以时间片q为单位执行，即每个进程执行时长为q，执行完再把进程放入队尾，去执行下一个进程。</span><br><span class="line">该算法保证了每个进程执行相同的时间和等待相同的时间，但是需要考虑时间片q的大小和进程队列的数量。</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>编码那些事儿</title>
    <url>/blog/2020/06/20/%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<p>软件开发中，编码是一件很重要的工作，它涉及到了数据的传输与读取等方面。今天介绍下编码相关的知识。</p>
<a id="more"></a>

<h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p>ascii码是用0-127这些状态位（即00000000-01111111）表示数字、字母、特殊符号等字符的编码规则，即用8个比特位（1个字节）表示最常用、基础的字符（例如：大写字母 W 用 01010111 表示，转换为十进制就是87，转换为十六进制就是 0x57）。ascii编码刚被创造时，使用计算机的人还不是很多，所以它能满足人们的需求。但是随着技术的进步与发展，科学家们发现ascii码已经不能满足需求了，很多其他国家的文字、符号并不能在计算机上被表示出来，于是将表示范围从127扩大到了256，即新增了128~256这些状态位来表示其他的文字或者符号，这些被称为扩展字符集。</p>
<h1 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h1><p>等到计算机技术传入中国时，我们发现还没有用于表示汉字的状态位，这是不能容忍的。于是勤劳的中国人民创造了GB2312编码，GB2312编码中规定0~127的状态位与原来意义相同，称为”半角”字符，从127以后使用两个字节表示一个汉字。由于中华文化博大精深，随着计算机的普及，GB2312编码也不能满足人们的要求了，随后有相继扩展出了GBK和GB18030编码。GBK是采用单双字节变长编码，英文使用单字节编码，兼容ASCII字符编码，中文则采用双字节编码。</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>首先得知道一点：Unicode 包含两个方面：1. 字符集 2. 编码方式</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>随着计算机在全世界的发展，如果世界各地都使用自己的编码规则，则会阻碍计算机的发展，导致世界不能互相交换信息，这时候Unicode通用字符集就出现了。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码（说白了就是一个数字编号），以满足跨语言、跨平台进行文本转换、处理的要求。Unicode使用两个字节表示一个字符。每个字符都有一个唯一的 Unicode 编号，这个编号一般用十六进制表示。</p>
<p>python3 中，可以使用 encode() 方法对字符串进行编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 &#x3D; &#39;马&#39;</span><br><span class="line">s1.encode(&#39;unicode_escape&#39;)[2:]</span><br><span class="line">b&#39;9a6c&#39;</span><br></pre></td></tr></table></figure>

<p>可以看到 ‘马’ 对应的 Unicode 编码是 9a6c，转换成二进制就是 1001 1010 0110 1100。</p>
<h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><p>Unicode 规定了每个字符对应的编号是多少，但是它没有说明这些编号如何存储。</p>
<p>UTF-8是Unicode字符集的一种实现方式，它规定了如何对 Unicode 字符的编号进行存储（即以何种方式保存 Unicode 字符的编号，保存这些编码是为了能够在网络中传输），它使用一个到四个不等的字节对一个字符进行编码，编码以后再存储。UTF-8可以表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII兼容。通过变长，UTF-8可以节省数据的空间。Unicode 的编号范围与 UTF-8 对应的二进制格式：</p>
<table>
<thead>
<tr>
<th align="center">编号范围</th>
<th align="center">二进制格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x00 - 0x7F（0 - 127）</td>
<td align="center">0XXXXXXX</td>
</tr>
<tr>
<td align="center">0x80 - 0x7FF （128 - 2047）</td>
<td align="center">110XXXXX - 10XXXXXX</td>
</tr>
<tr>
<td align="center">0x800 - 0xFFFF （2048 - 65535）</td>
<td align="center">1110XXXX 10XXXXXX 10XXXXXX</td>
</tr>
<tr>
<td align="center">0x10000 - 0x10FFFF （65536及以上）</td>
<td align="center">11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</td>
</tr>
</tbody></table>
<p>我们保存在内存中的数据都是 Unicode 编码，只有存储到硬盘上或者在网络传输中，才把 Unicode 编码转换成 UTF-8、GBK或者其他编码。</p>
<h1 id="Python3中的编码"><a href="#Python3中的编码" class="headerlink" title="Python3中的编码"></a>Python3中的编码</h1><p>在 python3 中，有文本字符串类型（str对象）和字节字符串类型（byte对象）两种字符串，str类型的对象都是 Unicode，因此对于 str 类型的对象只有encode（）方法，没有decode（）方法（若运行，会报错）。byte对象是由str类型的对象使用 encode() 方法产生的，byte 对象可以进行解码，从而得到真正的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.encode(encoding&#x3D;&quot;utf-8&quot;, errors&#x3D;&quot;strict&quot;)：将 unicode 字符串转换为 byte 字节流</span><br><span class="line">bytes.decode(encoding&#x3D;&quot;utf-8&quot;, errors&#x3D;&quot;strict&quot;)：将 byte 字节流转换为 unicode 字符串</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>jenkins的安装与简单使用</title>
    <url>/blog/2021/08/24/jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>jenkins是一个持续集成和自动化部署的工具，使用它可以快速方便的部署项目。下面介绍下 jenkins 的安装、git中央仓库的创建，及使用 jenkins 实现自动化部署。</p>
<a id="more"></a>

<p>以下例子中使用的服务器是 Ubuntu 18.04。</p>
<h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 去官网下载 jdk: jdk-8u251-linux-i586.tar.gz</span><br><span class="line">2. 解压并配置环境变量，在配置文件 &#x2F;etc&#x2F;profile 中加入以下内容（路径可根据自己情况更改）：</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib:$CLASSPATH</span><br><span class="line">export JAVA_PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JRE_HOME&#125;&#x2F;bin</span><br><span class="line">export PATH&#x3D;$PATH:$&#123;JAVA_PATH&#125;</span><br><span class="line">3. 执行 source &#x2F;etc&#x2F;profile，并执行 java 查看是否安装成功</span><br><span class="line">4. 安装成功后，配置软连接 ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java</span><br><span class="line">5. 安装 jenkins</span><br><span class="line">	1) wget -q -O - https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian&#x2F;jenkins.io.key | sudo apt-key add -</span><br><span class="line">	2) sudo sh -c &#39;echo deb http:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian-stable binary&#x2F; &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;jenkins.list&#39;</span><br><span class="line">	3) sudo apt-get update</span><br><span class="line">	4) sudo apt-get install jenkins</span><br><span class="line">6. 安装完成后，查看jenkins的状态，jenkins默认运行在8080端口（可以在 &#x2F;etc&#x2F;default&#x2F;jenkins文件中修改默认端口）</span><br><span class="line">	service jenkins status</span><br><span class="line">	service jenkins start</span><br><span class="line">	service jenkins restart</span><br></pre></td></tr></table></figure>



<h2 id="git中央仓库的搭建"><a href="#git中央仓库的搭建" class="headerlink" title="git中央仓库的搭建"></a>git中央仓库的搭建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装 git</span><br><span class="line">sudo apt install git</span><br><span class="line">2. 添加 git 用户，添加时输入密码</span><br><span class="line">adduser git</span><br><span class="line">3. 服务器打开 RSA 验证： vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config，添加下面的配置</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile  .ssh&#x2F;authorized_keys</span><br><span class="line">4. 切换到git用户，</span><br><span class="line">1）创建目录：mkdir .ssh</span><br><span class="line">2）生成密钥对：ssh-keygen -t rsa -C &quot;12345678@qq.com&quot;</span><br><span class="line">5. 在 .ssh 目录下添加 authorized_keys 文件，并把客户端的公钥添加到文件中</span><br><span class="line">6. 创建一个裸仓库：git init --bare pro1.git</span><br><span class="line">7. 在客户端克隆仓库： git clone git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;pro1.git</span><br></pre></td></tr></table></figure>



<h2 id="使用jenkins实现自动化部署"><a href="#使用jenkins实现自动化部署" class="headerlink" title="使用jenkins实现自动化部署"></a>使用jenkins实现自动化部署</h2><p>实现功能：使用jenkins将代码从一台服务器拉取到另一台服务器上，并将代码移动到指定目录中。</p>
<p>上面步骤中创建的 git 中央仓库就是此次例子中的源代码仓库。</p>
<p>配置 jenkins 前，我们需要先修改 jenkins 的配置文件，以便使用 jenkins 用户执行 shell 脚本时不会出现权限问题。修改步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 修改配置文件 &#x2F;etc&#x2F;default&#x2F;jenkins，让 jenkins 以 root 用户执行脚本</span><br><span class="line">JENKINS_USER&#x3D;&quot;root&quot;</span><br><span class="line">JENKINS_GROUP&#x3D;&quot;root&quot;</span><br><span class="line"></span><br><span class="line">2. 修改 jenkins 相关目录的属性</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;lib&#x2F;jenkins</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;cache&#x2F;jenkins</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;log&#x2F;jenkins</span><br><span class="line"></span><br><span class="line">3. 重启 jenkins 服务: service jenkins restart</span><br><span class="line">重启后，可能会遇到以下几个问题：</span><br><span class="line">1）mesg: ttyname failed: Inappropriate ioctl for device</span><br><span class="line">处理：使用 root 用户修改文件 &#x2F;root&#x2F;.profile，将 mesg n || true 替换成 tty -s &amp;&amp; mesg n。</span><br><span class="line">2）daemon: fatal: refusing to execute unsafe program: &#x2F;usr&#x2F;bin&#x2F;java (&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin is group and world writable)</span><br><span class="line">处理：执行 chmod -R 755 &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0&#x2F;bin</span><br><span class="line"></span><br><span class="line">4. 执行以上步骤后，重启服务器和 jenkins 服务就行了，下面就能使用 jenkins 执行 shell 脚本了。</span><br></pre></td></tr></table></figure>



<p>启动 jenkins 服务后，访问 127.0.0.1:8080，输入密码后进入jenkins。配置步骤如下：</p>
<p>首先，在 Dashboard 上创建一个 Item，输入 Item 名称并选择 Freestyle project。</p>
<p><img src="new_item.png" alt="new_item"></p>
<p>选择好以后，点击 OK。进入 Item 后，主要配置以下两个部分。</p>
<p>然后，配置源代码的 git 地址，如下图：</p>
<p><img src="source_code_git.png" alt="source_code_git"></p>
<p>配置 git 地址前，需要先在 jenkins 用户下创建秘钥（命令：ssh-keygen -t rsa -C “<a href="mailto:12345678@qq.com">12345678@qq.com</a>“），然后将生成的公钥放入 192.168.0.104 git用户下的 authorized_keys 文件中，否则会报错提示没有权限。</p>
<p>然后，再配置构建时要执行的 shell 脚本，如下图：</p>
<p><img src="build_shell.png" alt="build_shell"></p>
<p>上面的 shell 脚本就一行，将远程服务器上 git 仓库的代码拉取后（test目录，默认情况下，jenkins 会把拉取的代码放到其 workspace 目录下），再将代码放到 /home/wyzane/GitProject 目录下。</p>
<p>上图的 shell 脚本很简单，若需要执行其他的一些部署、重启服务等命令，可以再根据需要添加。</p>
<p>最后，可以保存并 Build 一下 Item，上面例子中控制台的输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Started by user wyzane</span><br><span class="line">Running as SYSTEM</span><br><span class="line">Building in workspace &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;test</span><br><span class="line">[WS-CLEANUP] Deleting project workspace...</span><br><span class="line">[WS-CLEANUP] Deferred wipeout is used...</span><br><span class="line">The recommended git tool is: NONE</span><br><span class="line">No credentials specified</span><br><span class="line">Cloning the remote Git repository</span><br><span class="line">Cloning repository git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git</span><br><span class="line"> &gt; git init &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;test # timeout&#x3D;10</span><br><span class="line">Fetching upstream changes from git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git</span><br><span class="line"> &gt; git --version # timeout&#x3D;10</span><br><span class="line"> &gt; git --version # &#39;git version 2.17.1&#39;</span><br><span class="line"> &gt; git fetch --tags --progress -- git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;* # timeout&#x3D;10</span><br><span class="line"> &gt; git config remote.origin.url git@192.168.0.104:&#x2F;home&#x2F;git&#x2F;GitProject&#x2F;pro1.git # timeout&#x3D;10</span><br><span class="line"> &gt; git config --add remote.origin.fetch +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;* # timeout&#x3D;10</span><br><span class="line">Avoid second fetch</span><br><span class="line"> &gt; git rev-parse refs&#x2F;remotes&#x2F;origin&#x2F;master^&#123;commit&#125; # timeout&#x3D;10</span><br><span class="line">Checking out Revision 8d114db052b5c4914e56a1e5848a2c5df9bca69e (refs&#x2F;remotes&#x2F;origin&#x2F;master)</span><br><span class="line"> &gt; git config core.sparsecheckout # timeout&#x3D;10</span><br><span class="line"> &gt; git checkout -f 8d114db052b5c4914e56a1e5848a2c5df9bca69e # timeout&#x3D;10</span><br><span class="line">Commit message: &quot;add test03&quot;</span><br><span class="line"> &gt; git rev-list --no-walk 8d114db052b5c4914e56a1e5848a2c5df9bca69e # timeout&#x3D;10</span><br><span class="line">[test] $ &#x2F;bin&#x2F;sh -xe &#x2F;tmp&#x2F;jenkins7411340475787087463.sh</span><br><span class="line">+ cp -r &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;test &#x2F;home&#x2F;wyzane&#x2F;GitProject</span><br><span class="line">Finished: SUCCESS</span><br></pre></td></tr></table></figure>



<p>jenkins 中还有很多其他配置项和插件，在后面还会整理一部分它们的使用方法。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux服务器之间免密登录的配置</title>
    <url>/blog/2021/09/04/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>下面的步骤中以 ubuntu1804 为例，介绍服务器之间配置免密登录的步骤。</p>
<a id="more"></a>

<p>三台服务器的 ip 为：192.168.0.101、192.168.0.103、192.168.0.104，配置使101可以在不需要密码（通过配置密钥）的情况下访问103和104。</p>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 三台服务器都安装 ssh 服务端和客户端</span><br><span class="line"></span><br><span class="line">2. 修改 103 和 104 服务器的 ssh 配置 &#x2F;etc&#x2F;ssh&#x2F;sshd_config，增加如下配置：</span><br><span class="line">	PermitRootLogin yes  # 允许 root 用户通过 ssh 登录</span><br><span class="line">   修改完成保存后，重启 ssh 服务：service ssh restart</span><br><span class="line">   </span><br><span class="line">3. 在 101 上切换到 root 用户，然后执行：ssh-keygen -t rsa，执行后一路回车，生成公钥和私钥对</span><br><span class="line"></span><br><span class="line">4. 在 101 上执行：ssh-copy-id 192.168.0.103</span><br><span class="line">   输入 103 的 root 密码后（如果忘记 root 密码，可以使用 sudo passwd root 重新设置 root 密码），会出现如下信息：</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: Source of key(s) to be installed: &quot;&#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub&quot;</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@192.168.0.103&#39;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#39;192.168.0.103&#39;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br><span class="line">  </span><br><span class="line">   上面的信息表示，已经成功将 101 的公钥添加到了 103 服务器的 &#x2F;root&#x2F;.ssh&#x2F;authored_keys 文件中。</span><br><span class="line">   </span><br><span class="line">5. 执行: ssh 192.168.0.103 即可登录 103 服务器，也可以执行 scp file 192.168.0.103:&#x2F;home&#x2F;wyzane 将需要的文件拷贝到 103 服务器上</span><br><span class="line"></span><br><span class="line">6. 配置 104 服务器时， 重复执行步骤 4 即可。</span><br></pre></td></tr></table></figure>

<p>上面就是配置服务器之间免密登录的步骤，当我们在 101 服务器的 /etc/hosts 文件中添加如下配置后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.0.103  app-01</span><br><span class="line">192.168.0.104  app-02</span><br></pre></td></tr></table></figure>

<p>可以使用 ssh app-01 和 ssh app-02 之类的命令通过 DNS 解析来访问 103 和 104 服务器。</p>
<h2 id="ansible的使用"><a href="#ansible的使用" class="headerlink" title="ansible的使用"></a>ansible的使用</h2><p>如果有多台服务器需要配置密钥登录，可以使用Ansible进行批量配置。</p>
<p>Ansible 是一个开源的自动化平台，它用于配置管理、应用部署、任务自动执行等，下面介绍如何使用它进行批量密钥登录的配置。</p>
<p>假设我们有若干个员工，需要密钥登录多台服务器，那么就需要把多个员工的公钥上传到多台服务器上。</p>
<ol>
<li>首先创建一个hosts文件，文件中保存了服务器的信息：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[test]</span><br><span class="line">test_ip ansible_user&#x3D;test_user ansible_ssh_pass&#x3D;test_pass ansible_port&#x3D;22</span><br><span class="line"></span><br><span class="line">[preprod]</span><br><span class="line">preprod_ip ansible_user&#x3D;preprod_user ansible_ssh_pass&#x3D;preprod_pass ansible_port&#x3D;2000</span><br><span class="line"></span><br><span class="line">[prod]</span><br><span class="line">prod_ip ansible_user&#x3D;prod_user ansible_ssh_pass&#x3D;prod_pass ansible_port&#x3D;22</span><br><span class="line"></span><br><span class="line">[nginx]</span><br><span class="line">nginx_ip ansible_user&#x3D;nginx_user ansible_ssh_pass&#x3D;nginx_pass ansible_port&#x3D;22</span><br></pre></td></tr></table></figure>

<p>文件中，中括号的内容可以理解为服务器名称，这个名称在下面的文件中会用到，名称下面分别指定了对应的服务器ip、用户名、密码、端口信息。</p>
<ol start="2">
<li>创建一个 Ansible playbook 配置文件 test.yml，用于保存需要执行的任务</li>
</ol>
<p>内容可以像下面这样：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">SSH</span> <span class="string">Keys</span>   <span class="comment"># 操作的名称</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">test:preprod</span>        <span class="comment"># 指定hosts文件中的哪些服务器执行这个操作</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span>                <span class="comment"># become表示是否使用特权提升，yes表示任务将以超级用户权限运行</span></span><br><span class="line">  <span class="attr">vars:</span>                      <span class="comment"># playbook运行时使用的变量</span></span><br><span class="line">    <span class="attr">ansible_become_pass:</span> <span class="string">"Dy18Zz@!@"</span>   <span class="comment"># 在提升权限时使用的密码</span></span><br><span class="line">  <span class="attr">tasks:</span>                               <span class="comment"># 这个操作中有哪些任务需要执行</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">authorized</span> <span class="string">key</span>         <span class="comment"># 任务名称，设置ssh授权密钥</span></span><br><span class="line">      <span class="attr">authorized_key:</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">lxtech</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('file', item) &#125;&#125;</span>"</span>    <span class="comment"># 使用了lookup从文件中读取密钥</span></span><br><span class="line">      <span class="attr">loop:</span>                                  <span class="comment"># 通过循环添加多个密钥文件，配置这些员工密钥登录test和preprod服务器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../pub/001.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../pub/002.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../pub/003.pub</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ensure</span> <span class="string">PubkeyAuthentication</span> <span class="string">is</span> <span class="string">enabled</span>   <span class="comment"># 任务名称，更新sshd_config文件，设置PubkeyAuthentication yes，允许密钥登录</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PubkeyAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PubkeyAuthentication yes'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Disable</span> <span class="string">Password</span> <span class="string">Authentication</span>   <span class="comment"># 禁止账号密码登录</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PasswordAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PasswordAuthentication no'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Disable</span> <span class="string">Root</span> <span class="string">SSH</span> <span class="string">Login</span>   <span class="comment"># 禁止使用root用户登录</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PermitRootLogin'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PermitRootLogin no'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">SSH</span> <span class="string">service</span>    <span class="comment"># 重启ssh服务</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">sshd</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">Nginx</span> <span class="string">SSH</span> <span class="string">Keys</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">nginx:prod</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">ansible_become_pass:</span> <span class="string">"!zE4s678g@"</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">authorized</span> <span class="string">key</span></span><br><span class="line">      <span class="attr">authorized_key:</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('file', item) &#125;&#125;</span>"</span></span><br><span class="line">      <span class="attr">loop:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/home/dytech/pkgs/ansible/pub/005.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/home/dytech/pkgs/ansible/pub/006.pub</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/home/dytech/pkgs/ansible/pub/007.pub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ensure</span> <span class="string">PubkeyAuthentication</span> <span class="string">is</span> <span class="string">enabled</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PubkeyAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PubkeyAuthentication yes'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Disable</span> <span class="string">Password</span> <span class="string">Authentication</span></span><br><span class="line">      <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">'^#?PasswordAuthentication'</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">'PasswordAuthentication no'</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">SSH</span> <span class="string">service</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">sshd</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，执行命令 ansible-playbook -i hosts test.yml 批量执行任务就行了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>通过cloudflare的tunnel技术实现内网穿透</title>
    <url>/blog/2024/02/02/%E9%80%9A%E8%BF%87cloudflare%E7%9A%84tunnel%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>cloudflare是一家提供一系列面向网站、应用程序和API的互联网安全性和性能增强服务的公司，它提供的服务主要包括内容分发网络（CDN）、分布式域名系统（DNS）服务、防御分布式拒绝服务（DDoS）攻击的解决方案和安全防护措施等。</p>
<a id="more"></a>

<p>我们在cloudflare上购买域名后，可以使用它的 tunnel 技术实现内网穿透，将我们的域名绑定到一个本地服务上。</p>
<p>下面分享一下操作步骤。</p>
<p>操作步骤（以windows为例）：</p>
<ol>
<li><p>安装 cloudflared（在官网或者github下载并安装，<a href="https://github.com/cloudflare/cloudflared/releases）" target="_blank" rel="noopener">https://github.com/cloudflare/cloudflared/releases）</a></p>
</li>
<li><p>执行以下命令，登录到cloudflare进行授权</p>
<p>cloudflared tunnel login<br>执行后会弹出一个页面，进行授权即可。授权完成后，会在 .cloudflare 目录下生成一个 cert.pem 文件</p>
</li>
<li><p>创建隧道 tunnel</p>
<p>cloudflared tunnel create &lt;隧道名字&gt;<br>创建完成后，会在 .cloudflare 目录中生成一个 uuid.json 的文件</p>
</li>
<li><p>把域名指向对应的隧道</p>
<p>cloudflared tunnel route dns &lt;隧道名字&gt; &lt;域名&gt;<br>完成后，cloudflare 会自动添加一条 CNAME 记录到对应的域名</p>
</li>
<li><p>配置 cloudflared</p>
<p>编辑文件 .\cloudflared\config.yml，添加如下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tunnel:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">credentials-file:</span> <span class="string">C:\Users\10579\.cloudflared\e9e54272-7145-485d-af9f-d620558d5c7a.json</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">blog.wangzan.net</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">service:</span> <span class="string">http_status:404</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，可以测试一下文件是否正确：</p>
<p>cloudflared tunnel –config .\cloudflared\config.yml ingress validate</p>
<p>测试规则是否命中：</p>
<p>cloufdlared tunnel –config .\cloudflared\config.yml ingress rule <a href="http://wangzan.net" target="_blank" rel="noopener">http://wangzan.net</a></p>
</li>
<li><p>测试运行</p>
<p>.\cloudflared.exe –loglevel debug –transport-loglevel warn –config C:\Users\wyzane.cloudflared\config.yml tunnel run &lt;隧道UUID&gt;</p>
</li>
</ol>
<p>以上就是通过cloudflare配置内网穿透的步骤。</p>
<p>参考：</p>
<p><a href="https://blog.cloudflare.com/zh-cn/elevate-load-balancing-with-private-ips-and-cloudflare-tunnels-a-secure-path-to-efficient-traffic-distribution-zh-cn/" target="_blank" rel="noopener">https://blog.cloudflare.com/zh-cn/elevate-load-balancing-with-private-ips-and-cloudflare-tunnels-a-secure-path-to-efficient-traffic-distribution-zh-cn/</a></p>
<p><a href="https://bra.live/setup-home-server-with-cloudflare-tunnel/" target="_blank" rel="noopener">https://bra.live/setup-home-server-with-cloudflare-tunnel/</a></p>
<p><a href="https://github.com/anderspitman/awesome-tunneling" target="_blank" rel="noopener">https://github.com/anderspitman/awesome-tunneling</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LangChain的基本使用</title>
    <url>/blog/2024/02/22/LangChain%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>LangChain 是一个开源框架，它的出现是为了简化和加速大语言模型相关应用的开发，比如开发基于OpenAI的应用，开发基于百度千帆大模型的应用。</p>
<a id="more"></a>

<p>那你可能会说，平时我们开发基于大模型的应用或者功能时，比如开发基于OpenAI的的应用时，我们都是直接调用OpenAI的chat接口或者assistants接口，并没有使用LangChain框架和它的接口。是的，平时我们开发时，可以直接调用相应大模型的接口，但当我们考虑到易用性、扩展性，使用LangChain是一个更好地选择，并且LangChain中还整合了很多组件和功能，包括：支持多种大语言模型、支持多种数据源连接、支持文本处理数据分析agent、提供部署和运维工具等。</p>
<p>下面基于Python和OpenAI介绍下LangChain的基本使用方式。</p>
<p>安装LangChain：pip install langchain</p>
<p>执行上面的命令后，会安装langchain、langchain-community、langchain-core等langchain相关的包。</p>
<p>安装openai：pip install openai</p>
<h1 id="创建一个llm"><a href="#创建一个llm" class="headerlink" title="创建一个llm"></a>创建一个llm</h1><p>安装好后，我们就可以使用LangChain就行开发了，先看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个基于OpenAI的llm模块</span></span><br><span class="line">    llm = OpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>, max_tokens=<span class="number">10</span>, model_name=<span class="string">'gpt-3.5-turbo-instruct'</span>)</span><br><span class="line">    <span class="comment"># 调用模块的方法进行提问</span></span><br><span class="line">    resp = llm.predict(prompt)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt = <span class="string">'你是谁？'</span></span><br><span class="line">    resp = call(prompt)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们使用 OpenAI 创建了一个 llm 对象，创建 llm 对象时传入的参数和直接调用 OpneAI Chat 接口时传入的参数几乎是一样的，具体有哪些参数，可以查看Python源码或者 LangChain 文档。</p>
<p>对于上面的例子，我们也可以使用 langchain-openai 库来实现。</p>
<p>首先安装 langchain-openai：pip install langchain-openai</p>
<p>安装好后，使用 langchain-openai 开发：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">    llm = OpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    resp = llm.predict(prompt)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt = <span class="string">'你是谁？'</span></span><br><span class="line">    resp = call(prompt)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure>

<p>使用 langchain.llms 的 OpenAI 和 langchain_openai 的 OpenAI 输出的效果是一样的，通过查看源码可以发现，这两个类最终都是继承的 BaseLLM 类。</p>
<h1 id="创建一个chat-llm"><a href="#创建一个chat-llm" class="headerlink" title="创建一个chat llm"></a>创建一个chat llm</h1><p>在 langchain 中，chat消息有四种类型，分别是：AIMessage, HumanMessage, SystemMessage、ChatMessage，</p>
<p>其中，AIMessage是 llm 的消息，HumanMessage是用户输入的消息，SystemMessage是系统的消息，ChatMessage是自定义的消息。</p>
<p>我们使用 langchain.chat_models 中的 ChatOpenAI 创建一个 chat llm：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个基于Chat OpenAI的llm模块</span></span><br><span class="line">    llm = ChatOpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    resp = llm.predict(prompt)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt = <span class="string">'今天晚饭吃什么'</span></span><br><span class="line">    resp = call(prompt)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure>

<p>当然，也可以将上面的 langchain.chat_models 替换成 langchain_openai，效果是一样的。</p>
<p>创建chat llm后，除了简单的调用 predict() 聊天之外，还可以通过使用 HumanMessage、SystemMessage 进行聊天，具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> HumanMessage, SystemMessage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">    llm = ChatOpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    system_msg = <span class="string">'你是一个非常有经验的高级厨师，请帮我推荐有益健康的菜谱！'</span></span><br><span class="line"></span><br><span class="line">    messages = [SystemMessage(content=system_msg), HumanMessage(content=prompt)]</span><br><span class="line">    resp = llm.predict_messages(messages)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt = <span class="string">'今天晚饭吃什么'</span></span><br><span class="line">    resp = call(prompt)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure>



<p>我们也可以通过 generate() 方法进行多组chat：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> HumanMessage, SystemMessage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(prompt1=<span class="string">''</span>, prompt2=<span class="string">''</span>)</span>:</span></span><br><span class="line">    llm = ChatOpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    system_msg1 = <span class="string">'你是一个非常有经验的高级厨师，轻轻帮我推荐有益健康的菜谱！'</span></span><br><span class="line">    system_msg2 = <span class="string">'你是一个资深训练师，请给出如何保持身材的建议！'</span></span><br><span class="line"></span><br><span class="line">    batch_messages = [</span><br><span class="line">        [</span><br><span class="line">            SystemMessage(content=system_msg1),</span><br><span class="line">            HumanMessage(content=prompt1)</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            SystemMessage(content=system_msg2),</span><br><span class="line">            HumanMessage(content=prompt2)</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">    resp = llm.generate(batch_messages)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prompt1 = <span class="string">'今天晚饭吃什么'</span></span><br><span class="line">    prompt2 = <span class="string">'今天有什么锻炼计划'</span></span><br><span class="line">    resp = call(prompt1, prompt2)</span><br><span class="line">    print(resp.generations[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">"==================="</span>)</span><br><span class="line">    print(resp.generations[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h1 id="使用prompt模板"><a href="#使用prompt模板" class="headerlink" title="使用prompt模板"></a>使用prompt模板</h1><p>上面的几个例子中，都是使用的固定的prompt，如果我们想更加灵活的使用prompt，可以使用prompt模板，看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> LLMChain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(who)</span>:</span></span><br><span class="line">    llm = OpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个prompt模板</span></span><br><span class="line">    prompt = PromptTemplate.from_template(<span class="string">"如果&#123;who&#125;生气了，我该怎么哄她？"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个llm chain对象</span></span><br><span class="line">    chain = LLMChain(llm=llm, prompt=prompt)</span><br><span class="line">    <span class="comment"># 运行chain时，将prompt模板的参数传入</span></span><br><span class="line">    resp = chain.run(who=who)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    resp = call(<span class="string">"女朋友"</span>)</span><br><span class="line">    print(resp)</span><br><span class="line">    print(<span class="string">"========================="</span>)</span><br><span class="line">    resp = call(<span class="string">"小猫"</span>)</span><br><span class="line">    print(resp)</span><br></pre></td></tr></table></figure>

<p>代码中使用 PromptTemplate 创建了一个 prompt 模板，通过使用 LLMChain 模块，将 prompt 和 llm 串联起来，最后执行并获取结果。</p>
<p>上面的例子中我们使用到了 LangChain中的 chain 模块：LLMChain。chain是 LangChain 中非常重要的一部分知识，通过使用 chain，我们将以模块化的方式调用大模型，即把 prompt 分成一个模块，调用 llm 分成一个模块，这两个模块之间互不影响，我们修改 prompt 时不会影响 llm，切换 llm 时也不会影响 prompt。chain 通过把调用大模型的过程切分成几个部分，降低了这几个部分之间的依赖关系，从而更加灵活，降低了后期更新和修改的成本。</p>
<p>LangChain中不只有 LLMChain，还有LLMRouterChain、LLMCheckerChain等，感兴趣的可以查看官方文档了解更多。</p>
<h1 id="创建一个ConversationChain"><a href="#创建一个ConversationChain" class="headerlink" title="创建一个ConversationChain"></a>创建一个ConversationChain</h1><p>在 LangChain 中，我们可以使用 ConversationChain 创建一个用于对话的应用。使用 ConversationChain 的好处在于，它会缓存聊天记录的上下文，使我们在对话时，大模型能够知道之前的聊天数据，从而给出更好地回答。下面看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> ConversationChain</span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line">llm = OpenAI(openai_api_key=OPENAI_API_KEY)</span><br><span class="line">conversion = ConversationChain(llm=llm)</span><br><span class="line">conversion.run(<span class="string">"你好呀"</span>)</span><br><span class="line">conversion.run(<span class="string">"我叫小明"</span>)</span><br><span class="line">conversion.run(<span class="string">"帮我写一份简历"</span>)</span><br><span class="line">conversion.run(<span class="string">"我是谁"</span>)</span><br></pre></td></tr></table></figure>

<p>代码中使用了 ConversationChain ，查看源码会发现，ConversationChain 中有一个 memory 参数，这个参数指定了聊天记录的缓存信息，使大模型能够知道之前对话的内容。memory 参数的默认值就是 ConversationBufferMemory。</p>
<p>我们可以使用下面的方式查看 memory 中缓存的所有内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(conversation.memory.load_memory_variables(&#123;&#125;))</span><br></pre></td></tr></table></figure>



<p>memory 除了使用 ConversationBufferMemory之外，还可以使用 ConversationBufferWindowMemory，它可以指定缓存最后 n 轮的对话内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> ConversationChain</span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferWindowMemory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个llm对象</span></span><br><span class="line">    llm = OpenAI(openai_api_key=OPENAI_API_KEY, temperature=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 只缓存最近一轮的对话内容</span></span><br><span class="line">    memory = ConversationBufferWindowMemory(k=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 创建一个ConversationChain对象</span></span><br><span class="line">    conversation = ConversationChain(llm=llm, memory=memory)</span><br><span class="line">    <span class="comment"># 运行conversation chain</span></span><br><span class="line">    resp = conversation.run(<span class="string">"你好呀"</span>)</span><br><span class="line">    print(resp)</span><br><span class="line">    print(<span class="string">"==========="</span>)</span><br><span class="line">    resp = conversation.run(<span class="string">"我是小明"</span>)</span><br><span class="line">    print(resp)</span><br><span class="line">    print(<span class="string">"==========="</span>)</span><br><span class="line">    resp = conversation.run(<span class="string">"你能做什么"</span>)</span><br><span class="line">    print(resp)</span><br><span class="line">    print(<span class="string">"==========="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查看memory中的内容</span></span><br><span class="line">    print(conversation.memory.load_memory_variables(&#123;&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    call()</span><br></pre></td></tr></table></figure>



<p>以上就是本文介绍的 LangChain 的一些基本用法。</p>
<p>LangChain 官方文档：<a href="https://python.langchain.com/docs/get_started/introduction" target="_blank" rel="noopener">https://python.langchain.com/docs/get_started/introduction</a></p>
<p>LangChain GitHub仓库：<a href="https://github.com/langchain-ai/langchain" target="_blank" rel="noopener">https://github.com/langchain-ai/langchain</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Ollama的介绍和使用</title>
    <url>/blog/2024/02/25/Ollama%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Ollama是一个开源工具，它能帮助我们在本地搭建和运行Llama2、Mistral、Gemma等开源LLM服务，方便我们构建自己的 LLM 应用。</p>
<p>今天介绍下它的使用。</p>
<a id="more"></a>

<h1 id="Ollama的安装"><a href="#Ollama的安装" class="headerlink" title="Ollama的安装"></a>Ollama的安装</h1><p>Linux环境下，Ollama的安装方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;ollama.com&#x2F;install.sh | sh</span><br></pre></td></tr></table></figure>

<p>Mac环境下，去官网下载安装包进行安装，下载地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;ollama.com&#x2F;download&#x2F;mac</span><br></pre></td></tr></table></figure>

<p>安装完成后，我们可以执行 ollama 命令查看到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  ollama [flags]</span><br><span class="line">  ollama [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  serve       Start ollama</span><br><span class="line">  create      Create a model from a Modelfile</span><br><span class="line">  show        Show information for a model</span><br><span class="line">  run         Run a model</span><br><span class="line">  pull        Pull a model from a registry</span><br><span class="line">  push        Push a model to a registry</span><br><span class="line">  list        List models</span><br><span class="line">  cp          Copy a model</span><br><span class="line">  rm          Remove a model</span><br><span class="line">  help        Help about any command</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help      help for ollama</span><br><span class="line">  -v, --version   Show version information</span><br><span class="line"></span><br><span class="line">Use &quot;ollama [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure>

<h1 id="Ollama的使用"><a href="#Ollama的使用" class="headerlink" title="Ollama的使用"></a>Ollama的使用</h1><p>通过查看 Ollama 的命令，可以发现它很像 Docker。</p>
<p>需要拉取模型到本地时，我们可以使用 ollama pull 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ollama pull gemma</span><br><span class="line">ollama pull llama2</span><br><span class="line">ollama pull mistral</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>查看本地已存在的模型时，可以运行：ollama list</p>
<p>在本地运行一个模型时，可以执行：ollama run gemma</p>
<p>运行模型后，会出现这样的对话界面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zanwang@zan ~ % ollama run gemma</span><br><span class="line">&gt;&gt;&gt; hello</span><br><span class="line">Hello, hello! 👋</span><br><span class="line">It&#39;s nice to hear from you. What would you like to talk about today?</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; who are you</span><br><span class="line">I am an AI language model, designed to provide you with information and </span><br><span class="line">engage in conversation on various topics. I am still under development, </span><br><span class="line">but I am constantly learning new things.</span><br><span class="line">Would you like me to tell you more about myself or would you like to ask </span><br><span class="line">me a question?</span><br></pre></td></tr></table></figure>

<p>我们可以输入问题，然后等待模型的回答。</p>
<p>我们还可以使用 ollama create 命令来创建一个 LLM.</p>
<p>首先要编写一个 Modefile 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM qwen</span><br><span class="line"></span><br><span class="line"># set the temperature to 1 [higher is more creative, lower is more coherent]</span><br><span class="line">PARAMETER temperature 1</span><br><span class="line">PARAMETER max_tokens 10</span><br><span class="line"></span><br><span class="line"># set the system message</span><br><span class="line">SYSTEM &quot;&quot;&quot;</span><br><span class="line">You are Tracy, a execllent teacher. Answer as Tracy, the assistant, only.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>我上面基于通义千问qwen模型创建了一个LLM，设置它的 temperature 为1。</p>
<p>执行以下命令创建该模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ollama create tracy(模型名称) -f .&#x2F;Modefile</span><br></pre></td></tr></table></figure>

<p>创建完成后，我们可以执行 ollama list 查看模型列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zanwang@zan ollamaproject % ollama list</span><br><span class="line">NAME                 	ID          	SIZE  	MODIFIED      </span><br><span class="line">codellama:latest     	8fdf8f752f6e	3.8 GB	47 hours ago 	</span><br><span class="line">gemma:latest         	430ed3535049	5.2 GB	47 hours ago 	</span><br><span class="line">llama2:latest        	78e26419b446	3.8 GB	2 days ago   	</span><br><span class="line">llama2-chinese:latest	cee11d703eee	3.8 GB	47 hours ago 	</span><br><span class="line">mistral:latest       	61e88e884507	4.1 GB	47 hours ago 	</span><br><span class="line">qwen:latest          	d53d04290064	2.3 GB	46 hours ago 	</span><br><span class="line">tracy:latest         	e941b7cd9ad8	2.3 GB	9 seconds ago</span><br></pre></td></tr></table></figure>

<p>然后我们就可以使用它了：ollama run tracy</p>
<h1 id="Ollama-API的使用"><a href="#Ollama-API的使用" class="headerlink" title="Ollama API的使用"></a>Ollama API的使用</h1><p>除了直接聊天，ollama 还提供了 REST API 供我们使用，我们可以像调用 OpenAI 接口那样调用 ollama 的接口。启动 ollama 服务以后，我们可以直接调用接口获取 LLM 的响应，</p>
<p>我们可以调用聊天接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zanwang@zan blog % curl http:&#x2F;&#x2F;localhost:11434&#x2F;api&#x2F;chat -d &#39;&#123;</span><br><span class="line">  &quot;model&quot;: &quot;qwen&quot;,</span><br><span class="line">  &quot;messages&quot;: [</span><br><span class="line">    &#123; &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是谁？&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>api/chat 接口可以传入以下参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">model: 模型名称</span><br><span class="line">messages: 消息内容</span><br><span class="line">format: 响应数据的格式，默认是json</span><br><span class="line">template: prompt的模板</span><br><span class="line">stream: 是否流式输出, 默认true</span><br></pre></td></tr></table></figure>



<p>也可以调用 generate 接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:11434&#x2F;api&#x2F;generate -d &#39;&#123;</span><br><span class="line">  &quot;model&quot;: &quot;llama2-chinese&quot;,</span><br><span class="line">  &quot;prompt&quot;:&quot;你好，你是谁&quot;</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>



<p>ollama rest api文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ollama&#x2F;ollama&#x2F;blob&#x2F;main&#x2F;docs&#x2F;api.md</span><br></pre></td></tr></table></figure>

<h1 id="Ollama-UI的使用"><a href="#Ollama-UI的使用" class="headerlink" title="Ollama UI的使用"></a>Ollama UI的使用</h1><p>使用 Ollama 创建好模型后，我们离创建一个聊天应用就差web界面了，下面是几个基于 ollama 的chat ui，有请兴趣的同学可以试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chatbot ollama：https:&#x2F;&#x2F;github.com&#x2F;ivanfioravanti&#x2F;chatbot-ollama</span><br><span class="line">open webui：https:&#x2F;&#x2F;github.com&#x2F;open-webui&#x2F;open-webui</span><br><span class="line">ollama ui：https:&#x2F;&#x2F;github.com&#x2F;ollama-webui&#x2F;ollama-webui-lite</span><br></pre></td></tr></table></figure>





<p>参考链接：</p>
<p>Ollama官网：<a href="https://ollama.com/" target="_blank" rel="noopener">https://ollama.com/</a></p>
<p>Ollama Github：<a href="https://github.com/ollama/ollama" target="_blank" rel="noopener">https://github.com/ollama/ollama</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>AutoGen的介绍和使用</title>
    <url>/blog/2024/02/27/AutoGen%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>AutoGen 是由微软、宾夕法尼亚州立大学和华盛顿大学合作开发的一个框架，它支持使用多个代理来开发 LLM 应用程序，这些代理可以相互对话来完成任务。</p>
<a id="more"></a>

<p>AutoGen 中的代理是可定制的、可对话的，并且无缝地允许人类参与。AutoGen 有如下特点：</p>
<ol>
<li><p>可以轻松构建基于多代理对话的下一代 LLM 应用程序。它简化了复杂的 LLM 工作流程的编排、自动化和优化。它最大限度地提高了 LLM 模型的性能并克服了它们的弱点。</p>
</li>
<li><p>它支持复杂工作流程的多种对话模式。借助可定制和可对话的代理，开发人员可以使用 AutoGen 构建各种涉及对话自主性、代理数量和代理对话拓扑的对话模式。</p>
</li>
<li><p>它提供了一系列具有不同复杂性的工作系统。这些系统涵盖各种领域和复杂性的广泛应用。</p>
</li>
<li><p>它提供增强的 LLM 推理。它提供 API 和缓存等实用程序，以及错误处理、多配置推理、上下文编程等高级使用模式。</p>
</li>
</ol>
<p>AutoGen 的功能类似于 LangChain 中的 agents。</p>
<h1 id="AutoGen的安装"><a href="#AutoGen的安装" class="headerlink" title="AutoGen的安装"></a>AutoGen的安装</h1><p>首先，我们需要安装 AutoGen 的 Python 包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pyautogen docker</span><br></pre></td></tr></table></figure>

<p>安装完成后，我们就可以使用了。</p>
<h1 id="AutoGen的使用"><a href="#AutoGen的使用" class="headerlink" title="AutoGen的使用"></a>AutoGen的使用</h1><h2 id="加载配置数据"><a href="#加载配置数据" class="headerlink" title="加载配置数据"></a>加载配置数据</h2><p>使用 AutoGen 时，我们首先需要加载配置，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> autogen</span><br><span class="line"></span><br><span class="line"><span class="comment"># config_list = [</span></span><br><span class="line"><span class="comment">#     &#123;</span></span><br><span class="line"><span class="comment">#         "model": "gpt-4-32k",</span></span><br><span class="line"><span class="comment">#         "api_key": os.environ["OPENAI_API_KEY"],</span></span><br><span class="line"><span class="comment">#         "tags": ["gpt-4-32"]</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &#123;</span></span><br><span class="line"><span class="comment">#         "model": "gpt-4",</span></span><br><span class="line"><span class="comment">#         "api_key": os.environ["OPENAI_API_KEY"],</span></span><br><span class="line"><span class="comment">#         "tags": ["gpt-4"]</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &#123;</span></span><br><span class="line"><span class="comment">#          "model": "llama2",</span></span><br><span class="line"><span class="comment">#          "tags": ["llama2"]</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择需要使用的模型</span></span><br><span class="line">filter_dict = &#123;</span><br><span class="line">    <span class="string">"model"</span>: <span class="string">"gpt-4"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config_list = autogen.config_list_from_json(</span><br><span class="line">    <span class="string">"OAI_CONFIG_LIST"</span>,</span><br><span class="line">    filter_dict=filter_dict,   <span class="comment"># 指定需要使用的模型</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># agent访问 LLM 的相关配置</span></span><br><span class="line">llm_config = &#123;</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="number">600</span>,</span><br><span class="line">    <span class="string">"cache_seed"</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="string">"config_list"</span>: config_list,   <span class="comment"># LLM 配置列表</span></span><br><span class="line">    <span class="string">"temperature"</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 config_list 中，可以配置很多模型供不同的 task 使用。config_list 可以直接是一个列表，也可以使用 autogen.config_list_from_json() 从 OAI_CONFIG_LIST 中加载配置数据，OAI_CONFIG_LIST 可以是一个json文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;model&quot;: &quot;gpt-4-32k&quot;,</span><br><span class="line">        &quot;api_key&quot;: &quot;xxx&quot;,</span><br><span class="line">        &quot;tags&quot;: [&quot;gpt-4-32&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;model&quot;: &quot;gpt-4&quot;,</span><br><span class="line">        &quot;api_key&quot;: &quot;xxx&quot;,</span><br><span class="line">        &quot;tags&quot;: [&quot;gpt-4&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;model&quot;: &quot;llama2&quot;,</span><br><span class="line">        &quot;tage&quot;: [&quot;llama2&quot;, &quot;local&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>agent 会使用 config_list 中可用的第一个模型，并针对该模型进行 LLM 调用。如果第一个模型调用失败，agent 将针对第二个模型重试请求，依此类推，直到收到提示完成消息。</p>
<p>如果我们有多个 LLM，但是想指定使用其中的一个，可以使用 filter_dict 进行过滤，比如要指定使用 gpt-4 这个模型，就可以这样配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择需要使用的模型</span></span><br><span class="line">filter_dict = &#123;</span><br><span class="line">    <span class="string">"model"</span>: <span class="string">"gpt-4"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config_list = autogen.config_list_from_json(</span><br><span class="line">    <span class="string">"OAI_CONFIG_LIST"</span>,</span><br><span class="line">    filter_dict=filter_dict,   <span class="comment"># 指定需要使用的模型</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用 tags 进行过滤：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filter_dict = &#123;</span><br><span class="line">    <span class="string">"tags"</span>: [<span class="string">"gpt-4"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 tags 进行过滤时，tags 的值是一个列表，列表中可以指定多个 LLM。</p>
<h2 id="创建并运行agent"><a href="#创建并运行agent" class="headerlink" title="创建并运行agent"></a>创建并运行agent</h2><p>创建 agent 时，上面的 llm_config 配置需要作为参数传入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">assistant = autogen.AssistantAgent(</span><br><span class="line">    name=<span class="string">"assistant"</span>,   <span class="comment"># agent名称</span></span><br><span class="line">    llm_config=llm_config,   <span class="comment"># agent配置</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个用户代理，该代理可以执行代码，并将结果反馈给其他代理</span></span><br><span class="line">user_proxy = autogen.UserProxyAgent(</span><br><span class="line">    name=<span class="string">"user_proxy"</span>,</span><br><span class="line">    human_input_mode=<span class="string">"NEVER"</span>,</span><br><span class="line">    max_consecutive_auto_reply=<span class="number">10</span>,</span><br><span class="line">    is_termination_msg=<span class="keyword">lambda</span> x: x.get(<span class="string">"content"</span>, <span class="string">""</span>).rstrip().endswith(<span class="string">"TERMINATE"</span>),</span><br><span class="line">    code_execution_config=&#123;</span><br><span class="line">        <span class="string">"work_dir"</span>: <span class="string">"web"</span>,</span><br><span class="line">        <span class="string">"use_docker"</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;, </span><br><span class="line">    llm_config=llm_config,</span><br><span class="line">    system_message=<span class="string">"""Reply TERMINATE if the task has been solved at full satisfaction.</span></span><br><span class="line"><span class="string">Otherwise, reply CONTINUE, or the reason why the task is not solved yet."""</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>创建 UserProxyAgent 对象时，参数的含义为：</p>
<p>name：指定用户代理的名称</p>
<p>human_input_mode：用户输入的模式，即是否在每次收到消息时请求人工输入。可能的值有 “ALWAYS”，”NEVER”，”TERMINATE”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALWAYS：表示每次收到消息时，代理都会提示人工输入，这种模式下，当用户输入 exit 或者 is_termination_msg 参数为 True 时，对话会退出。</span><br><span class="line">NEVER：表示代理永远不会提示人工输入，这种模式下，当自动回复次数达到 max_consecutive_auto_reply 设置的值或者 is_termination_msg 为 True 时，对话会停止。</span><br><span class="line">TERMINATE：表示仅当收到终止消息或自动回复数量达到 max_consecutive_auto_reply 设置的值时，代理才会提示人工输入。</span><br></pre></td></tr></table></figure>

<p>max_consecutive_auto_reply：一个 int 值，设置最大连续自动回复数，默认为 None，没有限制。该限制仅在 human_input_mode 不是“ALWAYS”时起作用。</p>
<p>is_termination_msg：该参数值是一个函数，它接受字典形式的消息并返回一个布尔值，指示收到的消息是否是终止消息，该字典可以包含以下键：“content”、“role”、“name”、“function_call”。</p>
<p>code_execution_config：是一个字典或者 False，表示执行的代码需要的配置。字典中的配置项有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">work_dir（可选，str）：代码执行的工作目录。如果没有，将使用默认工作目录。默认工作目录是“path_to_autogen”下的“extensions”目录。</span><br><span class="line">use_docker（可选，list、str 或 bool）：用于执行代码的 docker 容器。默认值为 True，这意味着代码将在 docker 容器中执行。将使用默认的镜像列表。如果提供了镜像名称的列表或字符串，则代码将在 docker 容器中执行，并成功拉取第一个镜像。如果为 False，则代码将在当前环境中执行。</span><br><span class="line">timeout（可选，int类型）：最大执行时间（以秒为单位）。</span><br><span class="line">last_n_messages（可选，int类型）：要回顾代码执行的消息数。默认为 1。</span><br></pre></td></tr></table></figure>

<p>llm_config：LLM 的配置信息</p>
<p>system_message：str 或者 list 类型，用于 ChatCompletion 聊天的系统消息，仅当 llm_config 不为 False 时使用。</p>
<p>最后，执行 user agent 初始化聊天：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_proxy.initiate_chat(</span><br><span class="line">    assistant,   <span class="comment"># 接收消息的 agent，就是我们上面创建的 assistant agent</span></span><br><span class="line">    message=<span class="string">"""帮我分析一下过去一个月A股中药明康德这只股票的变化情况"""</span>,   <span class="comment"># 传递的消息内容</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>下面是它的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user_proxy[0m (to assistant):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">帮我分析一下过去一个月A股中药明康德这只股票的变化情况</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[assistant[0m (to user_proxy):</span><br><span class="line"></span><br><span class="line">首先，我们需要从网络上获取股票数据。我们可以使用Python的pandas_datareader库来获取这些数据。以下是获取过去一个月药明康德（股票代码：603259.SH）股票数据的代码。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># filename: stock_analysis.py</span><br><span class="line"></span><br><span class="line">import pandas_datareader as pdr</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># Define the stock to be analyzed</span><br><span class="line">stock_code &#x3D; &#39;603259.SS&#39;</span><br><span class="line"></span><br><span class="line"># Define the time period</span><br><span class="line">end_date &#x3D; datetime.datetime.now()</span><br><span class="line">start_date &#x3D; end_date - datetime.timedelta(days&#x3D;30)</span><br><span class="line"></span><br><span class="line"># Get the stock data</span><br><span class="line">stock_data &#x3D; pdr.get_data_yahoo(stock_code, start_date, end_date)</span><br><span class="line"></span><br><span class="line"># Print the stock data</span><br><span class="line">print(stock_data)</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">请运行这段代码，它将输出过去一个月药明康德的股票数据，包括每天的开盘价、最高价、最低价、收盘价和成交量。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[31m</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; EXECUTING CODE BLOCK 0 (inferred language is python)...[0m</span><br><span class="line">[33muser_proxy[0m (to assistant):</span><br><span class="line"></span><br><span class="line">exitcode: 1 (execution failed)</span><br><span class="line">Code output: </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;stock_analysis.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    stock_data &#x3D; pdr.get_data_yahoo(stock_code, start_date, end_date)</span><br><span class="line">                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;zanwang&#x2F;dev&#x2F;AutoGenproject&#x2F;pyautogen&#x2F;lib&#x2F;python3.11&#x2F;site-packages&#x2F;pandas_datareader&#x2F;data.py&quot;, line 80, in get_data_yahoo</span><br><span class="line">    return YahooDailyReader(*args, **kwargs).read()</span><br><span class="line">           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;zanwang&#x2F;dev&#x2F;AutoGenproject&#x2F;pyautogen&#x2F;lib&#x2F;python3.11&#x2F;site-packages&#x2F;pandas_datareader&#x2F;base.py&quot;, line 253, in read</span><br><span class="line">    df &#x3D; self._read_one_data(self.url, params&#x3D;self._get_params(self.symbols))</span><br><span class="line">         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;zanwang&#x2F;dev&#x2F;AutoGenproject&#x2F;pyautogen&#x2F;lib&#x2F;python3.11&#x2F;site-packages&#x2F;pandas_datareader&#x2F;yahoo&#x2F;daily.py&quot;, line 153, in _read_one_data</span><br><span class="line">    data &#x3D; j[&quot;context&quot;][&quot;dispatcher&quot;][&quot;stores&quot;][&quot;HistoricalPriceStore&quot;]</span><br><span class="line">           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">TypeError: string indices must be integers, not &#39;str&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[33massistant[0m (to user_proxy):</span><br><span class="line"></span><br><span class="line">看起来我们在获取Yahoo财经数据时遇到了问题。这可能是由于Yahoo财经的API发生了变化或者是由于网络问题。我们可以尝试使用另一个库，如yfinance，它专门用于从Yahoo财经获取数据。</span><br><span class="line"></span><br><span class="line">以下是使用yfinance库获取过去一个月药明康德（股票代码：603259.SS）股票数据的代码。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># filename: stock_analysis.py</span><br><span class="line"></span><br><span class="line">import yfinance as yf</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># Define the stock to be analyzed</span><br><span class="line">stock_code &#x3D; &#39;603259.SS&#39;</span><br><span class="line"></span><br><span class="line"># Define the time period</span><br><span class="line">end_date &#x3D; datetime.datetime.now()</span><br><span class="line">start_date &#x3D; end_date - datetime.timedelta(days&#x3D;30)</span><br><span class="line"></span><br><span class="line"># Get the stock data</span><br><span class="line">stock_data &#x3D; yf.download(stock_code, start_date, end_date)</span><br><span class="line"></span><br><span class="line"># Print the stock data</span><br><span class="line">print(stock_data)</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">请运行这段代码，它将输出过去一个月药明康德的股票数据，包括每天的开盘价、最高价、最低价、收盘价和成交量。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[31m</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; EXECUTING CODE BLOCK 0 (inferred language is python)...[0m</span><br><span class="line">[33muser_proxy[0m (to assistant):</span><br><span class="line"></span><br><span class="line">exitcode: 0 (execution succeeded)</span><br><span class="line">Code output: </span><br><span class="line">                 Open       High        Low      Close  Adj Close     Volume</span><br><span class="line">Date                                                                        </span><br><span class="line">2024-01-29  63.000000  63.980000  59.360001  59.360001  59.360001  106097922</span><br><span class="line">2024-01-30  56.400002  58.599998  56.180000  56.849998  56.849998   87396491</span><br><span class="line">2024-01-31  56.000000  56.549999  53.900002  54.200001  54.200001   65697194</span><br><span class="line">2024-02-01  54.560001  56.939999  53.730000  55.799999  55.799999   58337298</span><br><span class="line">2024-02-02  56.910000  57.430000  50.220001  50.220001  50.220001   65707485</span><br><span class="line">2024-02-05  46.279999  51.730000  45.200001  48.230000  48.230000  159302508</span><br><span class="line">2024-02-06  46.860001  52.810001  45.369999  52.250000  52.250000  113259142</span><br><span class="line">2024-02-07  53.610001  56.380001  53.610001  55.250000  55.250000  111295644</span><br><span class="line">2024-02-08  53.650002  54.500000  52.000000  53.119999  53.119999   99007432</span><br><span class="line">2024-02-19  50.500000  51.279999  48.619999  50.049999  50.049999  132806402</span><br><span class="line">2024-02-20  49.849998  51.639999  49.330002  51.570000  51.570000  100319873</span><br><span class="line">2024-02-21  51.000000  55.500000  50.820000  53.740002  53.740002  108874573</span><br><span class="line">2024-02-22  53.090000  54.360001  52.880001  54.110001  54.110001   62886204</span><br><span class="line">2024-02-23  54.040001  54.180000  52.549999  53.580002  53.580002   69410659</span><br><span class="line">2024-02-26  53.840000  55.299999  53.750000  55.000000  55.000000   50604459</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[assistant[0m (to user_proxy):</span><br><span class="line"></span><br><span class="line">根据输出的数据，我们可以看到过去一个月药明康德（股票代码：603259.SS）的股票每天的开盘价、最高价、最低价、收盘价和成交量。这些数据可以帮助我们了解股票的变化情况。</span><br><span class="line"></span><br><span class="line">接下来，我们可以对这些数据进行一些基本的分析，例如计算平均收盘价、最高价和最低价，以及成交量。以下是进行这些计算的代码：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># filename: stock_analysis.py</span><br><span class="line"></span><br><span class="line">import yfinance as yf</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># Define the stock to be analyzed</span><br><span class="line">stock_code &#x3D; &#39;603259.SS&#39;</span><br><span class="line"></span><br><span class="line"># Define the time period</span><br><span class="line">end_date &#x3D; datetime.datetime.now()</span><br><span class="line">start_date &#x3D; end_date - datetime.timedelta(days&#x3D;30)</span><br><span class="line"></span><br><span class="line"># Get the stock data</span><br><span class="line">stock_data &#x3D; yf.download(stock_code, start_date, end_date)</span><br><span class="line"></span><br><span class="line"># Calculate the average close price</span><br><span class="line">average_close &#x3D; stock_data[&#39;Close&#39;].mean()</span><br><span class="line"></span><br><span class="line"># Calculate the highest price</span><br><span class="line">highest_price &#x3D; stock_data[&#39;High&#39;].max()</span><br><span class="line"></span><br><span class="line"># Calculate the lowest price</span><br><span class="line">lowest_price &#x3D; stock_data[&#39;Low&#39;].min()</span><br><span class="line"></span><br><span class="line"># Calculate the average volume</span><br><span class="line">average_volume &#x3D; stock_data[&#39;Volume&#39;].mean()</span><br><span class="line"></span><br><span class="line"># Print the results</span><br><span class="line">print(f&#39;Average close price: &#123;average_close&#125;&#39;)</span><br><span class="line">print(f&#39;Highest price: &#123;highest_price&#125;&#39;)</span><br><span class="line">print(f&#39;Lowest price: &#123;lowest_price&#125;&#39;)</span><br><span class="line">print(f&#39;Average volume: &#123;average_volume&#125;&#39;)</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">请运行这段代码，它将输出过去一个月药明康德的平均收盘价、最高价、最低价和平均成交量。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[31m</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; EXECUTING CODE BLOCK 0 (inferred language is python)...[0m</span><br><span class="line">[33muser_proxy[0m (to assistant):</span><br><span class="line"></span><br><span class="line">exitcode: 0 (execution succeeded)</span><br><span class="line">Code output: </span><br><span class="line">Average close price: 53.55533345540365</span><br><span class="line">Highest price: 63.97999954223633</span><br><span class="line">Lowest price: 45.20000076293945</span><br><span class="line">Average volume: 92733552.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[assistant[0m (to user_proxy):</span><br><span class="line"></span><br><span class="line">根据输出的结果，我们可以得到以下分析：</span><br><span class="line"></span><br><span class="line">- 过去一个月药明康德的平均收盘价为53.56元。</span><br><span class="line">- 过去一个月药明康德的最高价为63.98元。</span><br><span class="line">- 过去一个月药明康德的最低价为45.20元。</span><br><span class="line">- 过去一个月药明康德的平均成交量为92733552.4股。</span><br><span class="line"></span><br><span class="line">这些数据可以帮助我们了解药明康德在过去一个月的股票表现。然而，这只是基本的分析，如果需要更深入的分析，可能需要考虑更多的因素，如市场环境、公司基本面、行业动态等。</span><br><span class="line"></span><br><span class="line">TERMINATE</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>从上面的输出可以看出，assistant agent 编写了数据抓取代码和数据分析代码并执行了它们，并且可以处理遇到的错误，还是非常强大的。这个问题如果直接问 ChatGPT，它是不会直接给出答案的，但是通过使用 AutoGen 就可以获取答案，用来获取和分析实时数据是非常不错的。</p>
<p>我们还可以创建一个 chat group，这个 chat group 中可以有多个 assistant agent，每个 assistant agent 可以有不同的功能。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_proxy = autogen.UserProxyAgent(</span><br><span class="line">    name=<span class="string">"User_proxy"</span>,</span><br><span class="line">    system_message=<span class="string">"A human admin."</span>,</span><br><span class="line">    code_execution_config=&#123;</span><br><span class="line">        <span class="string">"last_n_messages"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">"work_dir"</span>: <span class="string">"groupchat"</span>,</span><br><span class="line">        <span class="string">"use_docker"</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    human_input_mode=<span class="string">"TERMINATE"</span>,</span><br><span class="line">)</span><br><span class="line">coder = autogen.AssistantAgent(</span><br><span class="line">    name=<span class="string">"Coder"</span>,</span><br><span class="line">    llm_config=llm_config,</span><br><span class="line">)</span><br><span class="line">pm = autogen.AssistantAgent(</span><br><span class="line">    name=<span class="string">"Product_manager"</span>,</span><br><span class="line">    system_message=<span class="string">"Creative in software product ideas."</span>,</span><br><span class="line">    llm_config=llm_config,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个聊天组</span></span><br><span class="line">groupchat = autogen.GroupChat(agents=[user_proxy, coder, pm], messages=[], max_round=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 创建一个管理员</span></span><br><span class="line">manager = autogen.GroupChatManager(groupchat=groupchat, llm_config=llm_config)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始聊天</span></span><br><span class="line">user_proxy.initiate_chat(</span><br><span class="line">    manager, message=<span class="string">"Find a latest paper about gpt-4 on arxiv and find its potential applications in software."</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>关于 AutoGen 使用的更多例子，可以查看官方文档：<a href="https://microsoft.github.io/autogen/docs/Examples" target="_blank" rel="noopener">https://microsoft.github.io/autogen/docs/Examples</a></p>
]]></content>
  </entry>
  <entry>
    <title>LlamaIndex的介绍</title>
    <url>/blog/2024/03/01/LlamaIndex%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>LlamaIndex 是一个基于 LLM 应用程序的数据框架，受益于上下文增强。它提供了必要的抽象，可以更轻松地摄取、构建和访问私有或特定领域的数据，以便将这些数据安全可靠地注入 LLM 中，以实现更准确的文本生成。</p>
<a id="more"></a>

<p>LlamaIndex 可以在 Python 和 Typescript 中使用。</p>
<p>为什么要进行上下文增强呢？<br>LLM 在人类和数据之间提供自然语言接口。广泛可用的模型是根据大量公开数据（如维基百科、邮件列表、教科书、源代码等）进行预训练的。<br>然而，虽然 LLM 接受了大量数据的培训，但他们并没有接受你的数据的培训，这些数据可能是私有的或特定于您试图解决的问题。它位于 API 后面、SQL 数据库中，或者隐藏在 PDF 和幻灯片中。<br>您可以选择用您的数据微调 LLM，但是： </p>
<ol>
<li>训练 LLM 的费用很高，</li>
<li>由于培训成本的原因，很难用最新信息更新 LLM，</li>
<li>缺乏可观察性。当你向 LLM 提出问题时，LLM 是如何得出答案的并不明显。</li>
</ol>
<p>我们可以使用一种称为检索增强生成 (RAG) 的上下文增强模式来代替微调，以获得与您的特定数据相关的更准确的文本生成。 RAG 涉及以下高级步骤：</p>
<ol>
<li>首先从数据源检索信息</li>
<li>将其作为上下文添加到您的问题中，并且</li>
<li>请 LLM 根据丰富的提示进行回答</li>
</ol>
<p>通过这样做，RAG 克服了微调方法的三个弱点：</p>
<ol>
<li>不需要训练 LLM，所以很便宜</li>
<li>仅当您请求数据时才会获取数据，因此数据始终是最新的</li>
<li>LlamaIndex可以向您显示检索到的文档，因此更值得信赖</li>
</ol>
<p>为什么使用 LlamaIndex 进行上下文增强？<br>首先，LlamaIndex 对您如何使用 LLM 没有任何限制。您仍然可以将 LLM 用作自动完成、聊天机器人、半自主代理等。它只会让 LLM 与您更相关。<br>LlamaIndex 提供以下工具来帮助您快速建立可用于生产的 RAG 系统：</p>
<ol>
<li>Data Connector 从其本机源和格式获取现有数据。这些可以是 API、PDF、SQL 等等。</li>
<li>Data Index 以中间表示形式构建数据，这些中间表示形式对于 LLM 来说既简单又高效</li>
<li>Engines 提供对数据的自然语言访问，例如<br>查询引擎是用于知识增强输出的强大检索接口。<br>聊天引擎是用于与数据进行多消息、“来回”交互的对话界面。</li>
<li>Data Agents 是由 LLM 提供支持的知识工作者，并通过工具进行增强，从简单的辅助函数到 API 集成等。</li>
<li>Application integrations 将 LlamaIndex 重新融入生态系统的其余部分。这可以是 LangChain、Flask、Docker、ChatGPT，或者……其他任何东西！</li>
</ol>
<p>LlamaIndex 适合谁？</p>
<ol>
<li>LlamaIndex 为初学者、高级用户以及介于两者之间的每个人提供工具。 </li>
<li>我们的高级 API 允许初学者使用 LlamaIndex 通过 5 行代码获取和查询他们的数据。</li>
<li>对于更复杂的应用程序，我们的较低级别 API 允许高级用户自定义和扩展任何模块（数据连接器、索引、检索器、查询引擎、重新排名模块）以满足他们的需求。</li>
</ol>
<h1 id="LlamaIndex的安装"><a href="#LlamaIndex的安装" class="headerlink" title="LlamaIndex的安装"></a>LlamaIndex的安装</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install llama-index</span><br></pre></td></tr></table></figure>

<p>这个包中包含了以下包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">llama-index-core</span><br><span class="line">llama-index-legacy  # temporarily included</span><br><span class="line">llama-index-llms-openai</span><br><span class="line">llama-index-embeddings-openai</span><br><span class="line">llama-index-program-openai</span><br><span class="line">llama-index-question-gen-openai</span><br><span class="line">llama-index-agent-openai</span><br><span class="line">llama-index-readers-file</span><br><span class="line">llama-index-multi-modal-llms-openai</span><br></pre></td></tr></table></figure>

<p>LlamaIndex 可以下载并存储各种软件包的本地文件（NLTK、HuggingFace 等）。使用环境变量“LLAMA_INDEX_CACHE_DIR”来控制这些文件的保存位置。</p>
<p>默认情况下，llamaIndex 使用 OpenAI gpt-3.5-turbo 模型进行文本生成，使用 text-embedding-ada-002 进行检索和嵌入。为了使用它，必须将 OPENAI_API_KEY 设置为环境变量。</p>
<h1 id="LlamaIndex的使用"><a href="#LlamaIndex的使用" class="headerlink" title="LlamaIndex的使用"></a>LlamaIndex的使用</h1><p>下面是一个在 LlamaIndex 中使用 Ollama 的例子，需要首先安装 llama-index-llms-ollama：pip install llama-index-llms-ollama。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> SummaryIndex, SimpleDirectoryReader</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> llama_index.llms.ollama <span class="keyword">import</span> Ollama</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 llm</span></span><br><span class="line">Settings.llm = Ollama(model=<span class="string">"llama2"</span>, request_timeout=<span class="number">60.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">"./data"</span>).load_data()</span><br><span class="line"><span class="comment"># 根据数据创建index</span></span><br><span class="line">index = SummaryIndex.from_documents(documents)</span><br><span class="line"><span class="comment"># 创建查询引擎</span></span><br><span class="line">query_engine = index.as_query_engine()</span><br><span class="line"><span class="comment"># 查询数据</span></span><br><span class="line">response = query_engine.query(<span class="string">"What did the author do growing up?"</span>)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出，使用 LlamaIndex 开发的大致步骤如下：</p>
<ol>
<li>创建一个 LLM 对象</li>
<li>加载数据</li>
<li>根据数据创建索引</li>
<li>创建查询引擎</li>
<li>查询引擎调用接口获取接口</li>
</ol>
<p>下面具体介绍每个步骤如何执行。</p>
<h2 id="如何加载数据"><a href="#如何加载数据" class="headerlink" title="如何加载数据"></a>如何加载数据</h2><h3 id="从目录中加载数据"><a href="#从目录中加载数据" class="headerlink" title="从目录中加载数据"></a>从目录中加载数据</h3><p>最容易使用的 reader 是我们的 SimpleDirectoryReader，它可以根据给定目录中的每个文件创建文档。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> SimpleDirectoryReader</span><br><span class="line"><span class="comment"># 从 data 目录中加载数据</span></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">"./data"</span>).load_data()</span><br></pre></td></tr></table></figure>



<h3 id="从数据库查询数据"><a href="#从数据库查询数据" class="headerlink" title="从数据库查询数据"></a>从数据库查询数据</h3><p>可以使用 DatabaseReader 连接器，该连接器对 SQL 数据库运行查询并将结果的每一行作为文档返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> download_loader</span><br><span class="line"><span class="keyword">from</span> llama_index.readers.database <span class="keyword">import</span> DatabaseReader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库连接器</span></span><br><span class="line">reader = DatabaseReader(</span><br><span class="line">    scheme=os.getenv(<span class="string">"DB_SCHEME"</span>),</span><br><span class="line">    host=os.getenv(<span class="string">"DB_HOST"</span>),</span><br><span class="line">    port=os.getenv(<span class="string">"DB_PORT"</span>),</span><br><span class="line">    user=os.getenv(<span class="string">"DB_USER"</span>),</span><br><span class="line">    password=os.getenv(<span class="string">"DB_PASS"</span>),</span><br><span class="line">    dbname=os.getenv(<span class="string">"DB_NAME"</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">query = <span class="string">"SELECT * FROM users"</span></span><br><span class="line">documents = reader.load_data(query=query)</span><br></pre></td></tr></table></figure>



<h2 id="如何处理数据"><a href="#如何处理数据" class="headerlink" title="如何处理数据"></a>如何处理数据</h2><p>加载数据后，您需要处理和转换数据，然后再将其放入存储系统。这些转换包括分块、提取元数据和嵌入每个块。这是确保 LLM 能够检索和最佳使用数据所必需的。<br>处理和转换输入/输出是 Node 对象（Document 是 Node 的子类），也可以对它们进行堆叠和重新排序。</p>
<p>加载数据的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex</span><br><span class="line"></span><br><span class="line">vector_index = VectorStoreIndex.from_documents(documents)</span><br><span class="line">vector_index.as_query_engine()</span><br></pre></td></tr></table></figure>

<p>上面的代码是没有经过文本分割处理的，from_documents() 方法可以接受 Document 对象数组，并正确解析它们并将它们分块。但是，有时您需要更好地控制文档的拆分方式，此时可以自定义文本拆分对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义文档拆分对象</span></span><br><span class="line">text_splitter = SentenceSplitter(chunk_size=<span class="number">512</span>, chunk_overlap=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex</span><br><span class="line"></span><br><span class="line">Settings.text_splitter = text_splitter</span><br><span class="line"></span><br><span class="line">index = VectorStoreIndex.from_documents(</span><br><span class="line">    documents, transformations=[text_splitter]</span><br></pre></td></tr></table></figure>



<h2 id="创建索引index"><a href="#创建索引index" class="headerlink" title="创建索引index"></a>创建索引index</h2><p>加载数据后，我们已经拥有文档对象列表（或节点列表）。是时候为这些对象构建索引了，以便您可以开始查询它们。<br>在 LlamaIndex 中，索引是由 Document 对象组成的数据结构，旨在支持 LLM 进行查询。您的索引旨在补充您的查询策略。<br>LlamaIndex 提供了几种不同的索引类型，包括：VectorStoreIndex、SummaryIndex。</p>
<p>VectorStoreIndex 是最常见的索引类型。矢量存储索引获取您的文档并将它们分成节点。然后，它创建每个节点文本的向量嵌入，以供 LLM 查询。<br>VectorStoreIndex 的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex</span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br></pre></td></tr></table></figure>



<p>什么是向量嵌入？<br>向量嵌入是 LLM 应用程序运行的核心。<br>向量嵌入（通常简称为嵌入）是文本语义或含义的数字表示，具有相似含义的两段文本将具有数学上相似的嵌入，即使实际文本完全不同。<br>这种数学关系支持语义搜索，用户提供查询术语，LlamaIndex 可以定位与查询术语含义相关的文本，而不是简单的关键字匹配。这是检索增强生成的工作原理以及 LLM 的一般运作方式的重要组成部分。<br>嵌入有多种类型，它们的效率、有效性和计算成本各不相同。默认情况下，LlamaIndex 使用 text-embedding-ada-002，这是 OpenAI 使用的默认嵌入。如果您使用不同的 LLM，您通常会想要使用不同的嵌入。<br>VectorStoreIndex 使用 LLM 的 API 将所有文本转换为嵌入；这就是我们说它“嵌入您的文本”的意思。如果您有大量文本，则生成嵌入可能需要很长时间，因为它涉及许多往返 API 调用。<br>当您想要搜索嵌入时，您的查询本身会转换为向量嵌入，然后由 VectorStoreIndex 执行数学运算，根据所有嵌入与您的查询在语义上的相似程度对它们进行排名。<br>排名完成后，VectorStoreIndex 会返回最相似的嵌入作为相应的文本块。它返回的嵌入数量称为 k，因此控制返回多少嵌入的参数称为 top_k。因此，整个类型的搜索通常被称为“top-k 语义检索”。Top-k 检索是查询向量索引的最简单形式。<br>也可以查看一下 OpenAI 关于 embeddings 的文档：<a href="https://platform.openai.com/docs/guides/embeddings" target="_blank" rel="noopener">https://platform.openai.com/docs/guides/embeddings</a></p>
<p>SummaryIndex 是一种更简单的索引形式，最适合查询，顾名思义，您试图生成文档中文本的摘要。它只是存储所有文档并将它们全部返回到您的查询引擎。</p>
<h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><p>加载数据并建立索引后，您可能需要存储它以避免重新索引的时间和成本。默认情况下，索引数据仅存储在内存中，也可以将数据存储到磁盘中或者存储到向量数据库中。</p>
<h3 id="使用磁盘存储"><a href="#使用磁盘存储" class="headerlink" title="使用磁盘存储"></a>使用磁盘存储</h3><p>存储索引数据的最简单方法是使用每个 Index 的内置 .persist() 方法，该方法将所有数据写入磁盘的指定位置。这适用于任何类型的索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index.storage_context.persist(persist_dir=<span class="string">"&lt;persist_dir&gt;"</span>)</span><br></pre></td></tr></table></figure>

<p>然后，你可以通过加载持久索引来避免重新加载和重新索引数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> StorageContext, load_index_from_storage</span><br><span class="line">storage_context = StorageContext.from_defaults(persist_dir=<span class="string">"&lt;persist_dir&gt;"</span>)</span><br><span class="line">index = load_index_from_storage(storage_context)</span><br></pre></td></tr></table></figure>

<h3 id="使用向量存储"><a href="#使用向量存储" class="headerlink" title="使用向量存储"></a>使用向量存储</h3><p>正如索引中所讨论的，最常见的索引类型之一是 VectorStoreIndex。在 VectorStoreIndex 中创建嵌入的 API 调用在时间和金钱方面可能会很昂贵，因此您需要存储它们以避免不断地重新索引。<br>LlamaIndex 支持大量向量存储，这些向量存储的架构、复杂性和成本各不相同。下面将使用 Chroma，一个开源矢量存储数据库。<br>安装 Chroma：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install chromadb</span><br></pre></td></tr></table></figure>

<p>使用 Chroma 存储 VectorStoreIndex 中嵌入的步骤：</p>
<ol>
<li>初始化 Chroma 客户端 </li>
<li>创建一个集合来将您的数据存储在 Chroma 中 </li>
<li>将 Chroma 指定为 StorageContext 中的 vector_store</li>
<li>使用 StorageContext 初始化您的 VectorStoreIndex</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> chromadb</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex, SimpleDirectoryReader</span><br><span class="line"><span class="keyword">from</span> llama_index.vector_stores.chroma <span class="keyword">import</span> ChromaVectorStore</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> StorageContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">"./data"</span>).load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Chroma 客户端</span></span><br><span class="line">db = chromadb.PersistentClient(path=<span class="string">"./chroma_db"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建集合或者获取集合</span></span><br><span class="line">chroma_collection = db.get_or_create_collection(<span class="string">"quickstart"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 chroma 作为 vector_store</span></span><br><span class="line">vector_store = ChromaVectorStore(chroma_collection=chroma_collection)</span><br><span class="line">storage_context = StorageContext.from_defaults(vector_store=vector_store)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建索引</span></span><br><span class="line">index = VectorStoreIndex.from_documents(</span><br><span class="line">    documents, storage_context=storage_context</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询</span></span><br><span class="line">query_engine = index.as_query_engine()</span><br><span class="line">response = query_engine.query(<span class="string">"What is the meaning of life?"</span>)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure>



<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>现在已经加载了数据，构建了索引，并存储了该索引以供以后使用，可以进行查询了。<br>LlamaIndex 中查询就是调用 LLM 时传入一个 prompt：它可以是一个问题并获得答案，或者是一个总结请求，或者是一个更复杂的指令。<br>更复杂的查询可能涉及重复/链式的 prompt + LLM 调用，甚至跨多个组件的推理循环。<br>所有查询的基础是 QueryEngine。获取 QueryEngine 最简单的方法是让索引为您创建一个，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">query_engine = index.as_query_engine()</span><br><span class="line">response = query_engine.query(</span><br><span class="line">    <span class="string">"Write an email to the user given their background information."</span></span><br><span class="line">)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure>

<p>查询由三个不同的阶段组成：</p>
<ol>
<li>Retrieval 是指您从索引中找到并返回与您的查询最相关的文档。最常见的 Retrieval 类型是“top-k”语义检索，但还有许多其他检索策略。</li>
<li>Postprocessing 是指对检索到的数据进行可选的重新排序、转换或过滤，例如要求它们具有特定的元数据，例如附加的关键字。</li>
<li>Response Synthesis 是将您的查询、最相关的数据和提示组合起来并发送给您的法学硕士以返回响应。</li>
</ol>
<p>LlamaIndex 有更低级的 API，可以对上面查询的三个阶段进行精细控制。下面是例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex, get_response_synthesizer</span><br><span class="line"><span class="keyword">from</span> llama_index.core.retrievers <span class="keyword">import</span> VectorIndexRetriever</span><br><span class="line"><span class="keyword">from</span> llama_index.core.query_engine <span class="keyword">import</span> RetrieverQueryEngine</span><br><span class="line"><span class="keyword">from</span> llama_index.core.postprocessor <span class="keyword">import</span> SimilarityPostprocessor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建索引</span></span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 retriever</span></span><br><span class="line">retriever = VectorIndexRetriever(</span><br><span class="line">    index=index,   <span class="comment"># 配置 index</span></span><br><span class="line">    similarity_top_k=<span class="number">10</span>,   <span class="comment"># 设置返回最相似的10个embedding</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 response</span></span><br><span class="line">response_synthesizer = get_response_synthesizer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组成一个 query engine</span></span><br><span class="line">query_engine = RetrieverQueryEngine(</span><br><span class="line">    retriever=retriever,</span><br><span class="line">    response_synthesizer=response_synthesizer,</span><br><span class="line">    node_postprocessors=[SimilarityPostprocessor(similarity_cutoff=<span class="number">0.7</span>)],  <span class="comment"># 设置检索到的节点达到要包含的最小相似度分数。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询</span></span><br><span class="line">response = query_engine.query(<span class="string">"What did the author do growing up?"</span>)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure>



<h3 id="配置Postprocessor"><a href="#配置Postprocessor" class="headerlink" title="配置Postprocessor"></a>配置Postprocessor</h3><p>上面的例子中，使用到了 node_postprocessors，在 LlamaIndex 中支持高级节点过滤和增强，可以进一步提高检索到的节点对象的相关性。这可以帮助减少 LLM 执行的时间/次数/成本或提高响应质量。<br>node 的 Postprocessor 有下面几个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeywordNodePostprocessor: 通过required_keywords和exclusion_keywords过滤节点。</span><br><span class="line">SimilarityPostprocessor: 通过设置相似度分数的阈值来过滤节点（因此仅受基于嵌入的检索器支持）</span><br><span class="line">PrevNextNodePostprocessor：使用基于节点关系的附加相关上下文来增强检索到的节点对象。</span><br></pre></td></tr></table></figure>

<p>配置一个 KeywordNodePostprocessor 的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">node_postprocessors = [</span><br><span class="line">    KeywordNodePostprocessor(</span><br><span class="line">        required_keywords=[<span class="string">"Combinator"</span>], exclude_keywords=[<span class="string">"Italy"</span>]</span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line">query_engine = RetrieverQueryEngine.from_args(</span><br><span class="line">    retriever, node_postprocessors=node_postprocessors</span><br><span class="line">)</span><br><span class="line">response = query_engine.query(<span class="string">"What did the author do growing up?"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="配置Response-synthesis"><a href="#配置Response-synthesis" class="headerlink" title="配置Response synthesis"></a>配置<strong>Response synthesis</strong></h3><p>检索器获取相关节点后，BaseSynthesizer 通过组合信息来合成最终响应，可以通过一下代码配置它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">query_engine = RetrieverQueryEngine.from_args(</span><br><span class="line">    retriever, response_mode=response_mode</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的配置中，我们的 response synthesis 使用的是默认的 BaseSynthesizer，response_mode 参数有如下可选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default：通过顺序遍历每个检索到的节点来“创建和完善”答案；这使得每个节点都有一个单独的 LLM 调用。适合更详细的答案。</span><br><span class="line">compact：在每次 LLM 调用期间“压缩”提示，通过填充尽可能多的节点文本块来适应最大提示大小。如果一个提示中的内容太多，无法填充，通过多个提示来“创建和完善”答案。</span><br><span class="line">tree_summarize：给定一组 Node 对象和查询，递归构造一棵树并返回根节点作为响应。适合总结目的。</span><br><span class="line">no_text：仅运行检索器来获取本应发送到 LLM 的节点，而不实际发送它们。然后可以通过检查response.source_nodes来检查。</span><br><span class="line">accumulate：给定一组 Node 对象和查询，将查询应用于每个 Node 文本块，同时将响应累积到数组中。返回所有响应的串联字符串。适合当您需要对每个文本块单独运行相同的查询时。</span><br></pre></td></tr></table></figure>



<p>以上是对 LlamaIndex 的一个简单介绍，从上面的介绍可以看出 LlamaIndex 与 LangChain 中 Retrieval 模块的使用基本上是类似的。</p>
<p>参考文档：</p>
<p><a href="https://docs.llamaindex.ai/en/stable/" target="_blank" rel="noopener">https://docs.llamaindex.ai/en/stable/</a></p>
<p><a href="https://python.langchain.com/docs/modules/data_connection/" target="_blank" rel="noopener">https://python.langchain.com/docs/modules/data_connection/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>FastAPI框架的使用</title>
    <url>/blog/2024/03/04/FastAPI%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>FastAPI 是一个现代、快速（高性能）的 Web 框架，基于标准的 Python 类型提示并使用 Python 3.8+ 构建 API。</p>
<a id="more"></a>

<p>它有如下特点：<br>快速：非常高的性能，与 NodeJS 和 Go 相当<br>快速编码：将开发功能的速度提高约 200% 到 300%。<br>更少的 bug：减少约 40% 的人为（开发人员）引起的 bug。<br>直观：强大的编辑器支持，随时随地都可以完成。调试时间更少。<br>简单：旨在易于使用和学习。阅读文档的时间更少。<br>简洁：最大限度地减少代码重复。每个参数声明具有多个功能。更少的错误。<br>健壮：获取可用于生产的代码。具有自动交互式文档。<br>基于标准：基于（并完全兼容）API 开放标准：OpenAPI（以前称为 Swagger）和 JSON Schema。</p>
<p>FastAPI 基于 Python 3.8+ 的类型注释和异步编程特性，使得代码更具表达能力。它使用声明式的语法，支持基于函数的 API 定义和异步请求处理，这可提高性能特别是在 IO 密集型应用程序中。它拥有内置强大的依赖注入系统，你可以使用它来提供共享逻辑、数据提供、安全依赖（如用户认证）等，在处理请求时它能够自动解析和注入。<br>此外，FastAPI 还集成了 Swagger，它可以根据你的代码自动创建一份 OpenAPI 文档。</p>
<h1 id="FastAPI的使用"><a href="#FastAPI的使用" class="headerlink" title="FastAPI的使用"></a>FastAPI的使用</h1><p>使用前我们需要安装相关的包，包括 fastapi 包和 uvicorn（一个 ASGI Server，异步网关接口服务器）包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install fastapi</span><br><span class="line">pip install <span class="string">"uvicorn[standard]"</span></span><br></pre></td></tr></table></figure>

<h2 id="创建一个简单的服务"><a href="#创建一个简单的服务" class="headerlink" title="创建一个简单的服务"></a>创建一个简单的服务</h2><p>安装完成后，看一个简单的例子 main.py ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个枚举类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserGender</span><span class="params">(str, Enum)</span>:</span></span><br><span class="line">    male = <span class="string">'male'</span></span><br><span class="line">    female = <span class="string">'female'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"index"</span>: <span class="string">"hello fastapi"</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求 http://127.0.0.1:8090/userinfo/1</span></span><br><span class="line"><span class="meta">@app.get("/userinfo/&#123;user_id&#125;")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">userinfo</span><span class="params">(user_id: int)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    param user_id: 指定了user_id是int类型，也可以不指定参数类型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"user_id"</span>: user_id, <span class="string">"userinfo"</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求 http://127.0.0.1:8090/userlist/male</span></span><br><span class="line"><span class="meta">@app.get("/userlist/&#123;gender&#125;")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">user_list</span><span class="params">(gender: UserGender)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param gender: 定义参数为枚举类型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"gender"</span>: gender&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求 http://127.0.0.1:8090/users?page_index=1&amp;page_size=10，page_size是一个可选参数，有一个默认值</span></span><br><span class="line"><span class="meta">@app.get("/users")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">users</span><span class="params">(page_index: int, page_size:  Optional[int] = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"page_index"</span>: page_index, <span class="string">"page_size"</span>: page_size&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求 http://127.0.0.1:8090/users/1/friends?page_index=1</span></span><br><span class="line"><span class="meta">@app.get("/users/&#123;user_id&#125;/friends")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">friends</span><span class="params">(user_id: int, page_index: int, page_size: Optional[int] = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"user_id"</span>: user_id, <span class="string">"page_index"</span>: page_index, <span class="string">"page_size"</span>: page_size&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>启动服务时，执行：python3 main.py 即可，还可以执行 uvicorn main:app –reload 启动服务。</p>
<h2 id="请求参数的处理"><a href="#请求参数的处理" class="headerlink" title="请求参数的处理"></a>请求参数的处理</h2><p>请求参数包括 请求 url 中的路径参数、请求 url 中的查询字符串参数以及请求体中的参数。</p>
<p>那么如何处理请求 url 中的路径参数和查询字符串参数呢？<br>我们还可以给接口中的参数添加验证的逻辑，需要使用到 FastAPI 下的 Path 和 Query 两个库。<br>给请求 url 中的路径参数添加验证，需要使用 Path 库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/userinfo/&#123;age&#125;")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(age: int = Path<span class="params">(..., title=<span class="string">"user age"</span>, ge=<span class="number">18</span>, lt=<span class="number">60</span>)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"user_age"</span>: age&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/customers/&#123;username&#125;")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(username: str = Path<span class="params">(..., title=<span class="string">"user name"</span>, min_length=<span class="number">6</span>, max_length=<span class="number">20</span>)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"username"</span>: username&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>Path 中的第一个参数使用 … 表示这个参数是必选的。Path 中还可以使用 regex 参数加上正则表达式的验证方式，如果传入的参数值不满足验证条件，会返回类似下面的错误信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"detail"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string_too_short"</span>,</span><br><span class="line">            <span class="attr">"loc"</span>: [</span><br><span class="line">                <span class="string">"path"</span>,</span><br><span class="line">                <span class="string">"username"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"msg"</span>: <span class="string">"String should have at least 6 characters"</span>,</span><br><span class="line">            <span class="attr">"input"</span>: <span class="string">"ndfs"</span>,</span><br><span class="line">            <span class="attr">"ctx"</span>: &#123;</span><br><span class="line">                <span class="attr">"min_length"</span>: <span class="number">6</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"https://errors.pydantic.dev/2.5/v/string_too_short"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>给查询字符串参数添加验证，需要使用 Query 库，其中 Query(None) 表示参数是可选的，Query(…) 表示参数是必选的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/userinfo")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(age: int = Query<span class="params">(<span class="number">18</span>, title=<span class="string">"user age"</span>, ge=<span class="number">18</span>, lt=<span class="number">60</span>)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"user_age"</span>: age&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>上面的 Query 中的第一个参数表示该查询参数是可选的，并且他的默认值是 18。<br>还可以给查询字符串参数添加别名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/userinfo")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(user_interest: str = Query<span class="params">(None, title=<span class="string">"user interest"</span>, alias=<span class="string">"user-interest"</span>)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"user_interest"</span>: user_interest&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>指定别名以后，我们的请求 url 就必须是 alias 指定的参数名：<a href="http://127.0.0.1:8090/userinfo?user-interest=篮球" target="_blank" rel="noopener">http://127.0.0.1:8090/userinfo?user-interest=篮球</a></p>
<p>如何处理请求体中的参数呢？<br>我们可以通过定义模型，让 FastAPI 框架为我们从请求体中提取对应的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gender</span><span class="params">(str, Enum)</span>:</span></span><br><span class="line">    male = <span class="string">'male'</span></span><br><span class="line">    female = <span class="string">'female'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义用户模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    username: str</span><br><span class="line">    gender: Gender   <span class="comment"># 定义一个枚举类型的数据</span></span><br><span class="line">    desc: Optional[str] = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post("/users")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(user_model: UserModel)</span>:</span></span><br><span class="line">    <span class="comment"># 使用 model_dump() 方法将 model 中的数据转换成一个 dict</span></span><br><span class="line">    user_dict = user_model.model_dump()</span><br><span class="line">    <span class="keyword">return</span> user_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put("/users/&#123;user_id&#125;")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">modify_user</span><span class="params">(user_id: int, user_model: UserModel)</span>:</span></span><br><span class="line">    user_dict = user_model.model_dump()</span><br><span class="line">    user_dict.update(&#123;<span class="string">"user_id"</span>: user_id&#125;)</span><br><span class="line">    <span class="keyword">return</span> user_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>上面 post 接口的请求 url 是：<a href="http://127.0.0.1:8090/users，请求参数" target="_blank" rel="noopener">http://127.0.0.1:8090/users</a>，请求参数是 json 格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"小美"</span>,</span><br><span class="line">    <span class="attr">"gender"</span>: <span class="string">"male"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 接口的请求 url 是：<a href="http://127.0.0.1:8090/users，请求参数" target="_blank" rel="noopener">http://127.0.0.1:8090/users</a>/1，请求参数是 json 格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"小美"</span>,</span><br><span class="line">    <span class="attr">"gender"</span>: <span class="string">"male"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面的例子介绍在一个接口中如何使用多个模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    username: str</span><br><span class="line">    desc: str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cart</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    goods_name: str</span><br><span class="line">    price: float</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post("/users")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">user_cart</span><span class="params">(cart_id: int, user: User, cart: Cart)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"cart_id"</span>: cart_id,</span><br><span class="line">        <span class="string">"user"</span>: user.model_dump(),</span><br><span class="line">        <span class="string">"cart"</span>: cart.model_dump()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>上面的接口中，请求体是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"小美"</span>,</span><br><span class="line">        <span class="attr">"desc"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"cart"</span>: &#123;</span><br><span class="line">        <span class="attr">"goods_name"</span>: <span class="string">"篮球"</span>,</span><br><span class="line">        <span class="attr">"price"</span>: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们还可以使用 fastapi.Body 来处理请求体中的参数，它支持我们在请求体中传入除了 user，cart 的其它参数，比如我们的请求体是下面这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"小美"</span>,</span><br><span class="line">        <span class="attr">"desc"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"cart"</span>: &#123;</span><br><span class="line">        <span class="attr">"goods_name"</span>: <span class="string">"篮球"</span>,</span><br><span class="line">        <span class="attr">"price"</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"date"</span>: <span class="string">"2024-03-03"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的请求中增加了一个 date 数据，我们使用 Body 来处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.post("/users")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">user_cart</span><span class="params">(cart_id: int, user: User, cart: Cart, date: str = Body<span class="params">(...)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"cart_id"</span>: cart_id,</span><br><span class="line">        <span class="string">"user"</span>: user.model_dump(),</span><br><span class="line">        <span class="string">"cart"</span>: cart.model_dump(),</span><br><span class="line">        <span class="string">"date"</span>: date</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当然。Body 中也支持添加验证逻辑。</p>
<p>如果想要对模型中的数据添加验证逻辑，需要这样使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    username: str = Field(<span class="string">'test'</span>, min_length=<span class="number">6</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    desc: str = Field(<span class="literal">None</span>, max_length=<span class="number">255</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们需要在一个模型中嵌套其它的模型，可以这样使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    address: str</span><br><span class="line">    postcode: str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    username: str = Field(<span class="string">'test'</span>, min_length=<span class="number">6</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    desc: str = Field(<span class="literal">None</span>, max_length=<span class="number">255</span>)</span><br><span class="line">    address: Address</span><br></pre></td></tr></table></figure>



<p>如果我们想在模型中使用 list、set 等数据类型，可以这样使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cart</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    goods: list   <span class="comment"># 或者写成 List[str]</span></span><br><span class="line">    price: float</span><br></pre></td></tr></table></figure>



<h2 id="Cookie与Header参数"><a href="#Cookie与Header参数" class="headerlink" title="Cookie与Header参数"></a>Cookie与Header参数</h2><p>FastAPI中提供了 fastapi.Cookie 和 fastapi.Header 库供我们获取 cookie 参数和 header 参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Union, Optional</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Cookie, Header</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post("/users")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">user_cart</span><span class="params">(api_token:  Optional[str] = Header<span class="params">(..., alias=<span class="string">'api-token'</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    user_type: Union[str, None] = Cookie<span class="params">(..., alias=<span class="string">"user-type"</span>)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"api_token"</span>: api_token,</span><br><span class="line">        <span class="string">"user_type"</span>: user_type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码中，Optional[str] 与 Union[str, None] 的功能一样，都是表示参数是可选参数。</p>
<p>我们也可以通过 response 对象设置 cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Union, Optional</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Cookie, Header, Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post("/users")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">user_cart</span><span class="params">(response: Response, api_token:  Optional[str] = Header<span class="params">(..., alias=<span class="string">'api-token'</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    user_type: Union[str, None] = Cookie<span class="params">(..., alias=<span class="string">"user-type"</span>)</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">"api_token"</span>: api_token,</span><br><span class="line">        <span class="string">"user_type"</span>: user_type</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 设置 cookie</span></span><br><span class="line">    response.set_cookie(key=<span class="string">"user-type"</span>, value=<span class="string">'2222'</span>, expires=<span class="number">60</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>



<h2 id="响应数据的处理"><a href="#响应数据的处理" class="headerlink" title="响应数据的处理"></a>响应数据的处理</h2><p>响应数据的格式也可以通过模型进行指定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Cookie, Header, Response</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GOODS_LIST = &#123;</span><br><span class="line">    <span class="string">"1"</span>: &#123;<span class="string">"goods_id"</span>: <span class="string">"1"</span>, <span class="string">"goods_name"</span>: <span class="string">"g1"</span>, <span class="string">"price"</span>: <span class="number">12</span>, <span class="string">"desc"</span>: <span class="string">"dd"</span>&#125;,</span><br><span class="line">    <span class="string">"2"</span>: &#123;<span class="string">"goods_id"</span>: <span class="string">"2"</span>, <span class="string">"goods_name"</span>: <span class="string">"g2"</span>, <span class="string">"price"</span>: <span class="number">13</span>, <span class="string">"desc"</span>: <span class="string">"dd"</span>&#125;,</span><br><span class="line">    <span class="string">"3"</span>: &#123;<span class="string">"goods_id"</span>: <span class="string">"3"</span>, <span class="string">"goods_name"</span>: <span class="string">"g3"</span>, <span class="string">"price"</span>: <span class="number">14</span>, <span class="string">"desc"</span>: <span class="string">"dd"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsResponseModel</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    goods_id: str</span><br><span class="line">    goods_name: str</span><br><span class="line">    price: float</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post("/goods/&#123;goods_id&#125;", response_model=GoodsResponseModel, response_model_include=&#123;"goods_name"&#125;)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">goods</span><span class="params">(goods_id: str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> GOODS_LIST.get(goods_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>通过 response_model 参数指定响应数据的格式，通过 response_model_include 参数指定在 response_model 的基础上只输出哪些数据。</p>
<h2 id="状态码与异常处理"><a href="#状态码与异常处理" class="headerlink" title="状态码与异常处理"></a>状态码与异常处理</h2><p>状态码与异常处理的例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path, HTTPException, status</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBase</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    id: Optional[int] = <span class="literal">None</span></span><br><span class="line">    username: str</span><br><span class="line">    user_age: int</span><br><span class="line">    desc: Optional[str] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRequestModel</span><span class="params">(UserBase)</span>:</span></span><br><span class="line">    password: str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserResponseModel</span><span class="params">(UserBase)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_list = &#123;</span><br><span class="line">    <span class="string">"ttt"</span>: &#123;<span class="string">"id"</span>: <span class="number">1</span>, <span class="string">"username"</span>: <span class="string">"ttt"</span>, <span class="string">"user_age"</span>: <span class="number">22</span>&#125;,</span><br><span class="line">    <span class="string">"zzz"</span>: &#123;<span class="string">"id"</span>: <span class="number">2</span>, <span class="string">"username"</span>: <span class="string">"zzz"</span>, <span class="string">"user_age"</span>: <span class="number">24</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 status_code 参数指定成功响应的状态码</span></span><br><span class="line"><span class="meta">@app.post("/user/create", status_code=201, response_model=UserResponseModel)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(user: UserRequestModel)</span>:</span></span><br><span class="line">    userinfo = user.model_dump()</span><br><span class="line">    userinfo.update(&#123;<span class="string">"id"</span>: <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> userinfo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/user/&#123;username&#125;", status_code=200, response_model=UserResponseModel)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_user</span><span class="params">(username: str = Path<span class="params">(..., min_length=<span class="number">3</span>)</span>)</span>:</span></span><br><span class="line">    user_detail = user_list.get(username)</span><br><span class="line">    <span class="keyword">if</span> user_detail:</span><br><span class="line">        <span class="keyword">return</span> user_detail</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不存在则抛出异常</span></span><br><span class="line">    <span class="keyword">raise</span> HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=<span class="string">f"<span class="subst">&#123;username&#125;</span> not found"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>我们还可以自定义返回的异常类和异常处理函数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path, Request</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> JSONResponse</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBase</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    id: Optional[int] = <span class="literal">None</span></span><br><span class="line">    username: str</span><br><span class="line">    user_age: int</span><br><span class="line">    desc: Optional[str] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRequestModel</span><span class="params">(UserBase)</span>:</span></span><br><span class="line">    password: str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserResponseModel</span><span class="params">(UserBase)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span><span class="params">(Exception)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, username: str)</span>:</span></span><br><span class="line">        self.username = username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_list = &#123;</span><br><span class="line">    <span class="string">"ttt"</span>: &#123;<span class="string">"id"</span>: <span class="number">1</span>, <span class="string">"username"</span>: <span class="string">"ttt"</span>, <span class="string">"user_age"</span>: <span class="number">22</span>&#125;,</span><br><span class="line">    <span class="string">"zzz"</span>: &#123;<span class="string">"id"</span>: <span class="number">2</span>, <span class="string">"username"</span>: <span class="string">"zzz"</span>, <span class="string">"user_age"</span>: <span class="number">24</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 status_code 参数指定成功响应的状态码</span></span><br><span class="line"><span class="meta">@app.post("/user/create", status_code=201, response_model=UserResponseModel)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(user: UserRequestModel)</span>:</span></span><br><span class="line">    userinfo = user.model_dump()</span><br><span class="line">    userinfo.update(&#123;<span class="string">"id"</span>: <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> userinfo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/user/&#123;username&#125;", status_code=200, response_model=UserResponseModel)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_user</span><span class="params">(username: str = Path<span class="params">(..., min_length=<span class="number">3</span>)</span>)</span>:</span></span><br><span class="line">    user_detail = user_list.get(username)</span><br><span class="line">    <span class="keyword">if</span> user_detail:</span><br><span class="line">        <span class="keyword">return</span> user_detail</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不存在则抛出异常</span></span><br><span class="line">    <span class="comment"># raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"&#123;username&#125; not found")</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 抛出自定义异常</span></span><br><span class="line">    <span class="keyword">raise</span> UserNotFoundException(username)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当抛出 UserNotFoundException 异常时, FastAPI 会调用这个方法进行处理</span></span><br><span class="line"><span class="meta">@app.exception_handler(UserNotFoundException)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">user_not_found_exception_handler</span><span class="params">(request: Request, exc: UserNotFoundException)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> JSONResponse(status_code=<span class="number">404</span>, content=&#123;</span><br><span class="line">        <span class="string">"error_code"</span>: <span class="number">404</span>,</span><br><span class="line">        <span class="string">"message"</span>: <span class="string">f"<span class="subst">&#123;exc.username&#125;</span> not found"</span>,</span><br><span class="line">        <span class="string">"data"</span>: &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码中，自定义了一个异常类 UserNotFoundException 和一个异常处理函数 user_not_found_exception_handler()，当 fastapi 中捕获到 UserNotFoundException 异常时，会调用 user_not_found_exception_handler() 函数去处理异常。<br>或者我们可以定义一个通用的异常模型，通过这个异常模型返回错误信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> JSONResponse</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBase</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    id: Optional[int] = <span class="literal">None</span></span><br><span class="line">    username: str</span><br><span class="line">    user_age: int</span><br><span class="line">    desc: Optional[str] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRequestModel</span><span class="params">(UserBase)</span>:</span></span><br><span class="line">    password: str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserResponseModel</span><span class="params">(UserBase)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义错误模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorMessage</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    err_code: int</span><br><span class="line">    message: str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_list = &#123;</span><br><span class="line">    <span class="string">"ttt"</span>: &#123;<span class="string">"id"</span>: <span class="number">1</span>, <span class="string">"username"</span>: <span class="string">"ttt"</span>, <span class="string">"user_age"</span>: <span class="number">22</span>&#125;,</span><br><span class="line">    <span class="string">"zzz"</span>: &#123;<span class="string">"id"</span>: <span class="number">2</span>, <span class="string">"username"</span>: <span class="string">"zzz"</span>, <span class="string">"user_age"</span>: <span class="number">24</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 status_code 参数指定成功响应的状态码</span></span><br><span class="line"><span class="meta">@app.post("/user/create", status_code=201, response_model=UserResponseModel,</span></span><br><span class="line">          responses=&#123;<span class="number">400</span>: &#123;<span class="string">"model"</span>: ErrorMessage&#125;&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(user: UserRequestModel)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> user_list.get(user.username, <span class="literal">None</span>):</span><br><span class="line">        error_message = ErrorMessage(err_code=<span class="number">400</span>, message=<span class="string">f"<span class="subst">&#123;user.username&#125;</span> already exists"</span>)</span><br><span class="line">        <span class="keyword">return</span> JSONResponse(status_code=<span class="number">400</span>, content=error_message.model_dump())</span><br><span class="line"></span><br><span class="line">    userinfo = user.model_dump()</span><br><span class="line">    userinfo.update(&#123;<span class="string">"id"</span>: <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> userinfo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>



<h2 id="依赖注入的使用"><a href="#依赖注入的使用" class="headerlink" title="依赖注入的使用"></a>依赖注入的使用</h2><p>我们使用 fastapi 提供的 Depends 实现依赖注入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Depends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">page_params</span><span class="params">(page_index: Optional[int] = <span class="number">1</span>, page_num: Optional[int] = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"page_index"</span>: page_index, <span class="string">"page_num"</span>: page_num&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/users")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_users</span><span class="params">(page_info: dict = Depends<span class="params">(page_params)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> page_info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>上面的例子中，把函数进行了注入，下面介绍把类进行注入的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Depends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageParams</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, page_index: Optional[int] = <span class="number">1</span>, page_num: Optional[int] = <span class="number">10</span>)</span>:</span></span><br><span class="line">        self.page_index = page_index</span><br><span class="line">        self.page_num = page_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/users")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_users</span><span class="params">(page_info: PageParams = Depends<span class="params">(PageParams)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"page_index"</span>: page_info.page_index, <span class="string">"page_num"</span>: page_info.page_num&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>也可以使用 dependencies 来添加依赖注入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Depends, Header, HTTPException</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_auth</span><span class="params">(api_token: Optional[str] = Header<span class="params">(..., alias=<span class="string">'api-token'</span>)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> api_token:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">401</span>, detail=<span class="string">"Unauthorized"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageParams</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, page_index: Optional[int] = <span class="number">1</span>, page_num: Optional[int] = <span class="number">10</span>)</span>:</span></span><br><span class="line">        self.page_index = page_index</span><br><span class="line">        self.page_num = page_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 dependencies 添加依赖</span></span><br><span class="line"><span class="meta">@app.get("/users", dependencies=[Depends(verify_auth)])</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_users</span><span class="params">(page_info: PageParams = Depends<span class="params">(PageParams)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"page_index"</span>: page_info.page_index, <span class="string">"page_num"</span>: page_info.page_num&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>

<p>也可以在创建 app 时（即全局）添加依赖注入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_auth</span><span class="params">(api_token: Optional[str] = Header<span class="params">(..., alias=<span class="string">'api-token'</span>)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> api_token:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">401</span>, detail=<span class="string">"Unauthorized"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI(dependencies=[Depends(verify_auth)])</span><br></pre></td></tr></table></figure>



<h2 id="API的身份认证"><a href="#API的身份认证" class="headerlink" title="API的身份认证"></a>API的身份认证</h2><p>下面使用 JWT Token 进行身份验证，例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta, timezone, datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Depends, Header, HTTPException</span><br><span class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> OAuth2PasswordBearer, OAuth2PasswordRequestForm</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TOKEN_KEY = <span class="string">'wz745jd8j237#ma9ds%nd'</span></span><br><span class="line">ALGORITHMS = <span class="string">'HS256'</span></span><br><span class="line"><span class="comment"># 指定获取 token 的接口</span></span><br><span class="line">token_url = OAuth2PasswordBearer(tokenUrl=<span class="string">"/login"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line"></span><br><span class="line">    access_token: str</span><br><span class="line">    token_type: str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_user</span><span class="params">(username: str, password: str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">'wz'</span> <span class="keyword">and</span> password == <span class="string">'1'</span>:</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># token_url 会自动从 Header 中获取 Token</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_username</span><span class="params">(token: str = Depends<span class="params">(token_url)</span>)</span>:</span></span><br><span class="line">    username = <span class="literal">None</span></span><br><span class="line">    token_failed_exception = HTTPException(status_code=<span class="number">401</span>, detail=<span class="string">"鉴权失败"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 解析 jwt token</span></span><br><span class="line">        token_data = jwt.decode(token, TOKEN_KEY, ALGORITHMS)</span><br><span class="line">        <span class="keyword">if</span> token_data:</span><br><span class="line">            username = token_data.get(<span class="string">"username"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> token_failed_exception</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">        <span class="keyword">raise</span> token_failed_exception</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 dependencies 添加依赖</span></span><br><span class="line"><span class="meta">@app.post("/login")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(login_form: OAuth2PasswordRequestForm = Depends<span class="params">()</span>)</span>:</span></span><br><span class="line">    username = validate_user(login_form.username, login_form.password)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">401</span>, detail=<span class="string">"用户名或者密码不正确"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成 jwt token</span></span><br><span class="line">    token_expires = datetime.now(timezone.utc) + timedelta(minutes=<span class="number">10</span>)</span><br><span class="line">    token_data = &#123;</span><br><span class="line">        <span class="string">"username"</span>: username,</span><br><span class="line">        <span class="string">"exp"</span>: token_expires</span><br><span class="line">    &#125;</span><br><span class="line">    token = jwt.encode(token_data, TOKEN_KEY, ALGORITHMS)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Token(access_token=token, token_type=<span class="string">"tmp"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post("/users")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">users</span><span class="params">(username: str = Depends<span class="params">(get_current_username)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"username"</span>: username&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>



<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>连接数据库，我们使用 SQLAlchemy 这个库，还需要 mysqlclient 或者 PyMySQL。<br>其中，mysqlclient 对应的数据库连接串是：mysql+mysqldb://username:password@ip:port/db<br>PyMySQL 对应的数据库连接串是：mysql+pymysql://username:password@ip:port/db<br>安装相关库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install SQLAlchemy</span><br><span class="line">pip install mysqlclient</span><br><span class="line">pip install PyMySQL</span><br></pre></td></tr></table></figure>



<p>下面是在 FastAPI 中操作数据库的例子，包括数据库的增删改查操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Depends, HTTPException, Path</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Integer, String, select, asc</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> DeclarativeBase, sessionmaker, Mapped, mapped_column</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(DeclarativeBase)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据库模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"users"</span></span><br><span class="line"></span><br><span class="line">    id: Mapped[int] = mapped_column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name: Mapped[str] = mapped_column(String(<span class="number">50</span>), unique=<span class="literal">True</span>, nullable=<span class="literal">False</span>)</span><br><span class="line">    gender: Mapped[str] = mapped_column(String(<span class="number">10</span>), nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:admin123456@127.0.0.1:3306/testdb"</span>, echo=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义接口的模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersBaseModel</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    name: str</span><br><span class="line">    gender: str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCreateModel</span><span class="params">(UsersBaseModel)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserUpdateModel</span><span class="params">(UsersBaseModel)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserResponseModel</span><span class="params">(UsersBaseModel)</span>:</span></span><br><span class="line">    id: int</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库连接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db_session</span><span class="params">()</span>:</span></span><br><span class="line">    db = Session()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> db</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        db.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_attrs</span><span class="params">(obj, data: dict)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> data.items():</span><br><span class="line">            setattr(obj, key, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询用户接口</span></span><br><span class="line"><span class="meta">@app.get("/user/list", response_model=List[UserResponseModel])</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_users</span><span class="params">(db: Session = Depends<span class="params">(get_db_session)</span>)</span>:</span></span><br><span class="line">    query = select(UserEntity).order_by(asc(UserEntity.id))</span><br><span class="line">    results = db.execute(query).scalars().all()</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户接口</span></span><br><span class="line"><span class="meta">@app.post("/user/create", response_model=UserResponseModel)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(user: UserCreateModel, db: Session = Depends<span class="params">(get_db_session)</span>)</span>:</span></span><br><span class="line">    query = select(UserEntity).where(UserEntity.name == user.name)</span><br><span class="line">    records = db.execute(query).scalars().all()</span><br><span class="line">    <span class="keyword">if</span> records:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">"用户已存在"</span>)</span><br><span class="line"></span><br><span class="line">    user = UserEntity(name=user.name, gender=user.gender)</span><br><span class="line">    db.add(user)</span><br><span class="line">    db.commit()</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新用户接口</span></span><br><span class="line"><span class="meta">@app.put("/user/&#123;user_id&#125;", response_model=UserResponseModel)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_user</span><span class="params">(*, user_id: int = Path<span class="params">(...)</span>, user: UserUpdateModel, db: Session = Depends<span class="params">(get_db_session)</span>)</span>:</span></span><br><span class="line">    query = select(UserEntity).where(UserEntity.id == user_id)</span><br><span class="line">    record = db.execute(query).scalars().one()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> record:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">"用户不存在"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新数据 方式一</span></span><br><span class="line">    <span class="comment"># record.name = user.name</span></span><br><span class="line">    <span class="comment"># record.gender = user.gender</span></span><br><span class="line">    <span class="comment"># db.commit()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新数据 方式二</span></span><br><span class="line">    set_attrs(record, user.model_dump())</span><br><span class="line">    db.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> record</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户接口</span></span><br><span class="line"><span class="meta">@app.delete("/user/&#123;user_id&#125;")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">delete_user</span><span class="params">(user_id: int = Path<span class="params">(...)</span>, db: Session = Depends<span class="params">(get_db_session)</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    query = select(UserEntity).where(UserEntity.id == user_id)</span><br><span class="line">    record = db.execute(query).scalars().one()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> record:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">"用户不存在"</span>)</span><br><span class="line"></span><br><span class="line">    db.delete(record)</span><br><span class="line">    db.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"main:app"</span>, reload=<span class="literal">True</span>, port=<span class="number">8090</span>)</span><br></pre></td></tr></table></figure>



<p>上面介绍了 FastAPI 中的一些基本用法，有兴趣的同学可以看看以下相关的 Github 仓库：</p>
<p><a href="https://github.com/tiangolo/fastapi" target="_blank" rel="noopener">https://github.com/tiangolo/fastapi</a></p>
<p><a href="https://github.com/mjhea0/awesome-fastapi" target="_blank" rel="noopener">https://github.com/mjhea0/awesome-fastapi</a></p>
<p>以及 FastAPI 的官方文档：<a href="https://fastapi.tiangolo.com/" target="_blank" rel="noopener">https://fastapi.tiangolo.com/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>《Build a Large Language Model (From Scratch)》第一章</title>
    <url>/blog/2024/03/18/%E3%80%8ABuild-a-Large-Language-Model-From-Scratch-%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<p>这篇博客是 《<em>Build a Large Language Model (From Scratch)</em>》第一章的译文，中文书名是《从头开始创建一个大语言模型》。</p>
<a id="more"></a>

<p>这本书的作者是 Sebastian Raschka，他是一名<strong>机器学习和人工智能研究员</strong>，对教育有着强烈的热情。 作为Lightning AI 的首席AI 教育家，他让关于AI 和深度学习相关的内容更加容易获得，并教人们如何大规模利用这些技术。</p>
<p>关于他的其它著作有：Python Machine Learning》、《Machine Learning with PyTorch and Scikit-Learn》等。</p>
<p>《<em>Build a Large Language Model (From Scratch)</em>》这本书目前还在创作当中，它是在 Manning 上发布的，原版的可以到 <a href="http://www.manning.com" target="_blank" rel="noopener">www.manning.com</a> 上去看。这本书介绍了什么是大语言模型（LLM），并通过从头开始构建大语言模型 (LLM)，让读者了解如何创建、训练和调整大语言模型 (LLM)。在构建大型语言模型的过程中，我们将发现它如何从内到外地工作。</p>
<p>下面是这本书第一章的翻译。</p>
<h1 id="理解大语言模型"><a href="#理解大语言模型" class="headerlink" title="理解大语言模型"></a>理解大语言模型</h1><p>像 ChatGPT 这样的大语言模型 (LLM) 是过去几年开发的深度神经网络模型。他们开创了自然语言处理（NLP）的新时代。在大型语言模型出现之前，传统方法擅长分类任务，例如电子邮件垃圾邮件分类和直接模式识别，这些任务可以通过手工规则或更简单的模型捕获。然而，它们通常在需要复杂理解和生成能力的语言任务中表现不佳，例如解析详细指令、进行上下文分析或创建连贯且上下文适当的原始文本。例如，前几代语言模型无法根据关键字列表编写电子邮件，这对于当代LLM 来说是微不足道的任务。</p>
<p>LLM 具有理解、生成和解释人类语言的卓越能力。然而，需要澄清的是，当我们说语言模型“理解”时，我们的意思是它们可以以连贯且上下文相关的方式处理和生成文本，而不是说它们拥有类似人类的意识或理解。</p>
<p>凭借深度学习（专注于神经网络的机器学习和人工智能 (AI) 的子集）的进步，LLM 接受了大量文本数据的训练。与以前的方法相比，这使得 LLM 能够捕获更深入的上下文信息和人类语言的微妙之处。因此，LLM 在各种 NLP 任务中显着提高了性能，包括文本翻译、情感分析、问答等。</p>
<p>当代 LLM 和早期 NLP 模型之间的另一个重要区别是后者通常是为特定任务而设计的。虽然那些早期的 NLP 模型在其狭窄的应用中表现出色，但 LLM 在广泛的 NLP 任务中表现出了更广泛的熟练程度。</p>
<p>LLM 背后的成功可以归因于支撑许多 LLM 的转换架构，以及 LLM 接受的大量数据训练，使他们能够捕捉各种语言的细微差别、上下文和模式，而这些对手动编码来说是具有挑战性的。</p>
<p>这种基于转换架构实现模型并使用大型训练数据集来训练 LLM 的转变从根本上改变了 NLP，为理解人类语言并与之交互提供了更强大的工具。</p>
<p>从本章开始，我们为实现本书的主要目标奠定了基础：通过在代码中逐步实现基于 Transformer 架构的类似 ChatGPT 的 LLM 来理解 LLM。</p>
<h2 id="什么是LLM"><a href="#什么是LLM" class="headerlink" title="什么是LLM"></a>什么是LLM</h2><p>LLM 是一种大型语言模型，是一种旨在理解、生成和响应类人文本的神经网络。这些模型是在大量文本数据上训练的深度神经网络，有时涵盖互联网上整个公开文本的大部分。</p>
<p>大语言模型中的“大”指的是模型的参数大小和训练它的巨大数据集。像这样的模型通常有数百甚至数千亿个参数，这些参数是网络中的可调整权重，在训练期间进行优化以预测序列中的下一个单词。下一个单词的预测很敏感，因为它利用语言固有的顺序性质来训练模型来理解文本中的上下文、结构和关系。然而，这是一项非常简单的任务，因此许多研究人员对它能够产生如此强大的模型感到惊讶。我们将在后面的章节中逐步讨论和实现下一个单词的训练过程。</p>
<p>LLM 使用一种称为 Transformer 的架构（在 1.4 节中有更详细的介绍），这使得它们在进行预测时能够选择性地关注输入的不同部分，从而使它们特别擅长处理人类语言的细微差别和复杂性。</p>
<p>由于 LLM 能够生成文本，因此 LLM 通常也被称为生成人工智能 (AI) 的一种形式，通常缩写为生成 AI 或 GenAI。如图 1.1 所示，人工智能涵盖了更广泛的领域，即创建能够执行需要类人智能的任务的机器，包括理解语言、识别模式和做出决策，还包括机器学习和深度学习等子领域。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图 1.1 正如对不同领域之间关系的分层描述所示， LLM 代表了深度学习技术的具体应用，利用了其处理和生成类人文本的能力。深度学习是机器学习的一个专门分支，专注于使用多层神经网络。机器学习和深度学习是旨在实现算法的领域，使计算机能够从数据中学习并执行通常需要人类智能的任务。如今，人工智能领域以机器学习和深度学习为主，但也包括其他方法，例如使用基于规则的系统、遗传算法、专家系统、模糊逻辑或符号推理。</span><br></pre></td></tr></table></figure>

<p><img src="./01__image001.png" alt="01__image001"></p>
<p>用于实现人工智能的算法是机器学习领域的焦点。具体来说，机器学习涉及算法的开发，这些算法可以根据数据进行学习并做出预测或决策，而无需显式编程。为了说明这一点，请将垃圾邮件过滤器想象为机器学习的实际应用。机器学习算法不需要手动编写规则来识别垃圾邮件，而是输入标记为垃圾邮件和合法电子邮件的电子邮件示例。通过最大限度地减少对训练数据集的预测误差，该模型可以学习识别表明垃圾邮件的模式和特征，从而能够将新电子邮件分类为垃圾邮件或合法邮件。</p>
<p>深度学习是机器学习的一个子集，专注于利用三层或多层神经网络（也称为深度神经网络）对数据中的复杂模式和抽象进行建模。与深度学习相比，传统机器学习需要手动提取特征。这意味着人类专家需要识别并选择与模型最相关的特征。</p>
<p>回到垃圾邮件分类示例，在传统的机器学习中，人类专家可能会手动从电子邮件文本中提取特征，例如某些触发词（“奖品”、“获胜”、“免费”）的频率、感叹号的数量、使用所有大写单词，或存在可疑链接。然后，根据这些专家定义的特征创建的数据集将用于训练模型。与传统机器学习相比，深度学习不需要手动提取特征。这意味着人类专家不需要识别和选择深度学习模型最相关的特征。</p>
<p>接下来的部分将涵盖 LLM 今天可以解决的一些问题、 LLM 要解决的挑战以及我们将在本书中实现的一般 LLM 架构。</p>
<h2 id="LLM的应用"><a href="#LLM的应用" class="headerlink" title="LLM的应用"></a>LLM的应用</h2><p>由于其解析和理解非结构化文本数据的先进能力， LLM 在各个领域拥有广泛的应用。如今， LLM 被用于机器翻译、小说文本生成、情感分析、文本摘要和许多其他任务。 LLM 最近被用于内容创作，例如撰写小说、文章，甚至计算机代码。</p>
<p> LLM 还可以为复杂的聊天机器人和虚拟助手提供支持，例如 OpenAI 的 ChatGPT 或 Google 的 Bard，它们可以回答用户查询并增强传统搜索引擎（例如 Google Search 或 Microsoft Bing）。</p>
<p>此外， LLM 可用于从医学或法律等专业领域的大量文本中进行有效的知识检索。这包括筛选文档、总结冗长的段落以及回答技术问题。</p>
<p>简而言之， LLM 对于自动化几乎所有涉及解析和生成文本的任务来说都是无价的。它们的应用几乎是无穷无尽的，随着我们不断创新和探索使用这些模型的新方法，很明显， LLM 有可能重新定义我们与技术的关系，使其更加对话、直观和易于理解。</p>
<p>在本书中，我们将重点了解 LLM 如何从头开始工作，编写可以生成文本的 LLM 。我们还将学习允许 LLM 进行查询的技术，从回答问题到总结文本、将文本翻译成不同的语言等等。换句话说，在本书中，我们将通过一步步构建来了解ChatGPT等复杂的LLM助手是如何工作的。</p>
<h2 id="建立和使用LLM的步骤"><a href="#建立和使用LLM的步骤" class="headerlink" title="建立和使用LLM的步骤"></a>建立和使用LLM的步骤</h2><p>我们为什么要建立自己的 LLM ？从头开始编写 LLM 课程是了解其机制和局限性的绝佳练习。此外，它还为我们提供了根据我们自己的特定领域数据集或任务保留或微调现有开源 LLM 架构所需的知识。</p>
<p>研究表明，在建模性能方面，定制的 LLM（针对特定任务或领域量身定制的 LLM）可以胜过 ChatGPT 等通用 LLM，后者是为广泛的应用程序而设计的。这方面的例子包括专门针对金融的 BloombergGPT 和专门针对医学问答的 LLM （请参阅附录 B 中的进一步阅读和参考资料部分以了解更多详细信息）。</p>
<p>创建LLM的一般过程包括预训练和微调。 “预训练”中的术语“预”指的是初始阶段，在该阶段，LLM 等模型在大型、多样化的数据集上进行训练，以形成对语言的广泛理解。然后，该预训练模型将作为基础资源，可以通过微调进一步细化，在微调过程中，模型在更针对特定任务或领域的更窄数据集上进行专门训练。这种由预训练和微调组成的两阶段训练方法如图 1.3 所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图 1.3 预训练 LLM 涉及对大型未标记文本语料库（原始文本）进行下一个单词预测。然后可以使用较小的标记数据集对预训练的 LLM 进行微调。</span><br></pre></td></tr></table></figure>

<p><img src="./01__image005.png" alt="01__image005"></p>
<p>如图 1.3 所示，创建 LLM 的第一步是在大型文本数据语料库（有时称为原始文本）上对其进行训练。这里的“原始”是指这些数据只是普通文本，没有任何标签信息[1]。 （可以应用过滤，例如删除未知语言的格式字符或文档。）</p>
<p>LLM 的第一个训练阶段也称为预训练，创建初始预训练的 LLM，通常称为基础或基础模型。这种模型的典型例子是GPT-3模型（ChatGPT的前身）。该模型能够完成文本补全，即完成用户提供的写了一半的句子。它还具有有限的小样本功能，这意味着它可以仅根据几个示例来学习执行新任务，而不需要大量的训练数据。下一节将进一步说明这一点，将 Transformer 用于不同的任务。</p>
<p>通过未标记文本的训练获得预训练的 LLM 后，我们可以进一步在标记数据上训练 LLM，也称为微调。</p>
<p> LLM 微调的两个最流行的类别包括指令微调和分类任务微调。在指令微调中，标记的数据集由指令和答案对组成，例如翻译文本的查询以及正确翻译的文本。在分类微调中，标记数据集由文本和关联的类标签组成，例如与垃圾邮件和非垃圾邮件标签关联的电子邮件。</p>
<p>在本书中，我们将介绍预训练和微调 LLM 的代码实现，并且在预训练基础 LLM 后，我们将在本书后面深入研究指令微调和分类微调的细节。</p>
<h2 id="使用LLM完成多种任务"><a href="#使用LLM完成多种任务" class="headerlink" title="使用LLM完成多种任务"></a>使用LLM完成多种任务</h2><p>大多数现代 LLM 都依赖于 Transformer 架构，这是 2017 年论文《Attention Is All You Need》中介绍的一种深度神经网络架构。为了理解 LLM ，我们必须简要回顾一下最初的转换器，它最初是为机器翻译而开发的，将英语文本翻译成德语和法语。图 1.4 描述了 Transformer 架构的简化版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图 1.4 原始 Transformer 架构的简化描述，这是一种用于语言翻译的深度学习模型。转换器由两部分组成：一个编码器，用于处理输入文本并生成文本的嵌入表示（一种捕获不同维度中许多不同因素的数字表示），解码器可以使用该嵌入表示一次生成一个单词的翻译文本。请注意，该图显示了翻译过程的最后阶段，其中解码器必须仅生成最终单词（“Beispiel”），给定原始输入文本（“这是一个示例”）和部分翻译的句子（“Das ist”） ein”），完成翻译。图形编号指示数据处理的顺序，并提供有关读取图形的最佳顺序的指导。</span><br></pre></td></tr></table></figure>

<p><img src="./01__image007.png" alt="01__image007"></p>
<p>图 1.4 所示的 Transformer 架构由两个子模块组成：编码器和解码器。编码器模块处理输入文本并将其编码为一系列数字表示或向量，以捕获输入的上下文信息。然后，解码器模块获取这些编码向量并从中生成输出文本。例如，在翻译任务中，编码器将源语言的文本编码为向量，解码器将这些向量解码以生成目标语言的文本。编码器和解码器都由通过所谓的自注意力机制连接的许多层组成。您可能对如何预处理和编码输入有很多疑问。这些将在后续章节中逐步实现。</p>
<p>Transformer 和 LLM 的一个关键组成部分是自注意力机制（未显示），它允许模型权衡序列中不同单词或标记相对于彼此的重要性。这种机制使模型能够捕获输入数据中的远程依赖性和上下文关系，从而增强其生成连贯且上下文相关的输出的能力。但由于其复杂性，我们将推迟到第3章进行解释，我们将在其中逐步讨论和实现。此外，我们还将在第 2 章“使用文本数据”中讨论和实现创建模型输入的数据预处理步骤。</p>
<p>Transformer 架构的后续变体，例如所谓的 BERT（Transformer 双向编码器表示的缩写）和各种 GPT 模型（生成式预训练 Transformer 的缩写），基于此概念构建，以使该架构适应不同的任务。 （参考文献可在附录 B 中找到。）</p>
<p>BERT 建立在原始 Transformer 的编码器子模块之上，其训练方法与 GPT 不同。虽然 GPT 是为生成任务而设计的，但 BERT 及其变体专注于屏蔽词预测，其中模型预测给定句子中的屏蔽词或隐藏词，如图 1.5 所示。这种独特的训练策略使 BERT 具备了文本分类任务的优势，包括情感预测和文档分类。作为其功能的应用，截至撰写本文时，Twitter 使用 BERT 来检测有毒内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图 1.5  Transformer 编码器和解码器子模块的直观表示。左侧，编码器部分举例说明了类似 BERT 的 LLM，它专注于掩码词预测，主要用于文本分类等任务。右侧的解码器部分展示了类似 GPT 的 LLM，专为生成任务和生成连贯的文本序列而设计。</span><br></pre></td></tr></table></figure>

<p><img src="./01__image009.png" alt="01__image009"></p>
<p>另一方面，GPT 专注于原始 Transformer 架构的解码器部分，专为需要生成文本的任务而设计。这包括机器翻译、文本摘要、小说写作、编写计算机代码等等。我们将在本章的剩余部分中更详细地讨论 GPT 架构，并在本书中从头开始实现它。</p>
<p>GPT 模型主要是为执行文本完成任务而设计和训练的，也表现出了非凡的多功能性。这些模型擅长执行零样本和少样本学习任务。零样本学习是指在没有任何先前具体示例的情况下泛化到完全未见过的任务的能力。另一方面，小样本学习涉及从用户提供的最少数量的示例作为输入进行学习，如图 1.6 所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图 1.6 除了文本补全之外，类似 GPT 的 LLM 可以根据输入解决各种任务，而无需重新训练、微调或特定于任务的模型架构更改。有时，在输入中提供目标示例会很有帮助，这称为“少数镜头设置”。然而，类似 GPT 的 LLM 也能够在没有具体示例的情况下执行任务，这称为零样本设置。</span><br></pre></td></tr></table></figure>

<p><img src="./01__image011.png" alt="01__image011"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Transformer 与 LLM </span><br><span class="line">今天的 LLM 基于上一节中介绍的 Transformer 架构。因此， Transformer 和 LLM 是文献中经常作为同义词使用的术语。但请注意，并非所有 Transformer 都是 LLM ，因为 Transformer 也可用于计算机视觉。此外，并非所有 LLM 都是转换器，因为存在基于循环和卷积架构的大型语言模型。这些替代方法背后​​的主要动机是提高 LLM 的计算效率。然而，这些替代的 LLM 架构是否可以与基于 Transformer 的 LLM 的功能竞争以及它们是否会在实践中被采用还有待观察。 （有兴趣的读者可以在本章末尾的进一步阅读部分找到描述这些架构的文献参考。）</span><br></pre></td></tr></table></figure>

<h2 id="利用大型数据集"><a href="#利用大型数据集" class="headerlink" title="利用大型数据集"></a>利用大型数据集</h2><p>流行的 GPT 和 BERT 类模型的大型训练数据集代表了包含数万亿个单词的多样化且全面的文本语料库，其中包括大量主题以及自然语言和计算机语言。为了提供一个具体的例子，表 1.1 总结了用于预训练 GPT-3 的数据集，它作为 ChatGPT 第一个版本的基础模型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1.1 流行的GPT-3 LLM的预训练数据集</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Dataset name</th>
<th>Dataset description</th>
<th>Number of tokens</th>
<th>Proportion in  training data</th>
</tr>
</thead>
<tbody><tr>
<td>CommonCrawl (filtered)</td>
<td>Web crawl data</td>
<td>410 billion</td>
<td>60%</td>
</tr>
<tr>
<td>WebText2</td>
<td>Web crawl data</td>
<td>19 billion</td>
<td>22%</td>
</tr>
<tr>
<td>Books1</td>
<td>Internet-based book corpus</td>
<td>12 billion</td>
<td>8%</td>
</tr>
<tr>
<td>Books2</td>
<td>Internet-based book corpus</td>
<td>55 billion</td>
<td>8%</td>
</tr>
<tr>
<td>Wikipedia</td>
<td>High-quality text</td>
<td>3 billion</td>
<td>3%</td>
</tr>
</tbody></table>
<p>表 1.1 报告了 token 的数量，其中 token 是模型读取的文本单位，数据集中的 token 数量大致相当于文本中的单词和标点字符的数量。我们将在下一章更详细地介绍标记化（将文本转换为标记的过程）。</p>
<p>主要结论是，该训练数据集的规模和多样性使这些模型能够在各种任务上表现良好，包括语言语法、语义和上下文，甚至一些需要常识的任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPT-3 数据集详细信息</span><br><span class="line">在表 1.1 中，值得注意的是，每个数据集中只有一小部分数据（总计 3000 亿个令牌）用于训练过程。这种采样方法意味着训练并未涵盖每个数据集中可用的每一条数据。相反，使用了从所有数据集中提取的 3000 亿个代币的选定子集。此外，虽然某些数据集并未完全包含在此子集中，但其他数据集可能已包含多次，以达到 3000 亿个代币的总数。表中比例一栏，在不考虑四舍五入误差的情况下，合计占本次抽样数据的100%。</span><br><span class="line"></span><br><span class="line">对于上下文，请考虑 CommonCrawl 数据集的大小，仅该数据集就包含 4100 亿个令牌，并且需要大约 570 GB 的存储空间。相比之下，GPT-3 等模型的后续迭代（例如 Meta 的 LLaMA）已经扩大了其训练范围，以包括其他数据源，例如 Arxiv 研究论文（92 GB）和 StackExchange 的代码相关问答（78 GB）。</span><br><span class="line"></span><br><span class="line">维基百科语料库由英语维基百科组成。虽然 GPT-3 论文的作者没有进一步说明细节，但 Books1 很可能是来自 Project Gutenberg (https:&#x2F;&#x2F;www.gutenberg.org&#x2F;) 的样本，而 Books2 很可能来自 Libgen (https:&#x2F;&#x2F;en .wikipedia.org&#x2F;wiki&#x2F;Library_Genesis）。 CommonCrawl 是 CommonCrawl 数据库 (https:&#x2F;&#x2F;commoncrawl.org&#x2F;) 的过滤子集，WebText2 是来自具有 3 个以上赞成票的帖子的所有出站 Reddit 链接的网页文本。</span><br><span class="line"></span><br><span class="line">GPT-3 论文的作者没有共享训练数据集，但公开的可比较数据集是 The Pile (https:&#x2F;&#x2F;pile.eleuther.ai&#x2F;)。但是，该集合可能包含受版权保护的作品，并且确切的使用条款可能取决于预期的使用案例和国家&#x2F;地区。有关更多信息，请参阅 HackerNews 讨论：https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id&#x3D;25607809。</span><br></pre></td></tr></table></figure>

<p>这些模型的预训练性质使其具有难以置信的通用性，可用于进一步微调下游任务，这就是为什么它们也被称为基础或基础模型。 LLM 预培训需要大量资源，而且非常昂贵。例如，以云计算积分计算，GPT-3 预训练成本估计为 460 万美元[2]。</p>
<p>好消息是，许多预训练的 LLM （作为开源模型）可以用作通用工具来编写、提取和编辑不属于训练数据的文本。此外，LLM 可以针对具有相对较小数据集的特定任务进行微调，从而减少所需的计算资源并提高特定任务的性能。</p>
<p>在本书中，我们将实现预训练代码，并使用它来预训练 LLM 以用于教育目的。所有计算都可以在消费类硬件上执行。实现预训练代码后，我们将学习如何重用公开可用的模型权重并将其加载到我们将实现的架构中，从而使我们能够在本书后面微调 LLM 时跳过昂贵的预训练阶段。</p>
<h2 id="仔细看看GPT的架构"><a href="#仔细看看GPT的架构" class="headerlink" title="仔细看看GPT的架构"></a>仔细看看GPT的架构</h2><p>在本章前面，我们提到了类似 GPT 模型、GPT-3 和 ChatGPT 等术语。现在让我们仔细看看一般的 GPT 架构。首先，GPT 代表 Generative Pretrained Transformer，最初是在以下论文中介绍的：</p>
<ul>
<li>通过生成预训练提高语言理解 (2018) Radford 等人。来自 OpenAI，<a href="http://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf" target="_blank" rel="noopener">http://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf</a></li>
</ul>
<p>GPT-3 是该模型的放大版本，具有更多参数并在更大的数据集上进行训练。原始的 ChatGPT 模型是通过使用 OpenAI 的 InstructGPT 论文中的方法在大型指令数据集上微调 GPT-3 创建的，我们将在第 8 章“使用人类反馈进行微调以遵循指令”中详细介绍该模型。正如我们之前在图 1.6 中看到的，这些模型是有能力的文本完成模型，并且可以执行其他任务，例如拼写纠正、分类或语言翻译。这实际上是非常值得注意的，因为 GPT 模型是在相对简单的下一个单词预测任务上进行预训练的，如图 1.7 所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图 1.7 在 GPT 模型的下一个单词预训练任务中，系统通过查看句子之前的单词来学习预测句子中即将出现的单词。这种方法有助于模型理解单词和句子通常如何在语言中组合在一起，形成可应用于各种其他任务的基础。</span><br></pre></td></tr></table></figure>

<p><img src="./01__image013.png" alt="01__image013"></p>
<p>下一个单词预测任务是自我监督学习的一种形式，也是自我标记的一种形式。这意味着我们不需要明确地收集训练数据的标签，而是可以利用数据本身的结构：我们可以使用句子或文档中的下一个单词作为模型应该预测的标签。由于这个下一个单词预测任务允许我们“即时”创建标签，因此可以利用大量未标记的文本数据集来训练 LLM，如前面第 1.5 节“利用大型数据集”中所述。</p>
<p>与我们在 1.4 节“使用 LLM 执行不同任务”中介绍的原始 Transformer 架构相比，通用 GPT 架构相对简单。本质上，它只是解码器部分，没有编码器，如图 1.8 所示。由于像 GPT 这样的解码器式模型通过一次预测一个单词来生成文本，因此它们被认为是一种自回归模型。</p>
<p>GPT-3 等架构也比原始 Transformer 模型大得多。例如，原始 Transformer 将编码器和解码器块重复六次。 GPT-3有96个 Transformer 层，总共1750亿个参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图 1.8 GPT 架构仅采用原始 Transformer 的解码器部分。它专为单向、从左到右的处理而设计，非常适合文本生成和下一个单词预测任务，以迭代方式一次一个单词地生成文本。</span><br></pre></td></tr></table></figure>

<p><img src="./01__image015.png" alt="01__image015"></p>
<p>GPT-3 于 2020 年推出，按照深度学习和 LLM 开发标准来说已经是很久以前的事了，最近的架构（例如 Meta 的 Llama 模型）仍然基于相同的底层概念，只引入了较小的修改。因此，理解 GPT 仍然与以往一样重要，本书重点关注实现 GPT 背后的突出架构，同时提供替代 LLM 所采用的特定调整的指导。</p>
<p>最后，值得注意的是，尽管原始 Transformer 模型是专门为语言翻译而设计的，但 GPT 模型（尽管其架构更大但更简单，旨在预测下一个单词）也能够执行翻译任务。这种能力最初出乎研究人员的意料，因为它来自主要针对下一个单词预测任务训练的模型，该任务并不专门针对翻译。</p>
<p>执行模型未经过明确训练的任务的能力称为“新兴属性”。这种能力在训练期间并未明确教授，而是作为模型在各种环境下接触大量多语言数据的自然结果而出现的。事实上，GPT 模型可以“学习”语言之间的翻译模式并执行翻译任务，即使它们没有经过专门训练，这一事实证明了这些大规模生成语言模型的优势和功能。我们可以执行不同的任务，而无需为每个任务使用不同的模型。</p>
<h2 id="构建LLM"><a href="#构建LLM" class="headerlink" title="构建LLM"></a>构建LLM</h2><p>在本章中，我们为理解 LLM 奠定了基础。在本书的其余部分，我们将从头开始编写代码。我们将以 GPT 背后的基本思想为蓝图，分三个阶段解决这个问题，如图 1.9 所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图1.9 本书涵盖的构建LLM的阶段包括实现LLM架构和数据准备过程、预训练LLM以创建基础模型，以及微调基础模型以成为个人助理或文本分类器。</span><br></pre></td></tr></table></figure>

<p><img src="./01__image017.png" alt="01__image017"></p>
<p>首先，我们将了解基本的数据预处理步骤，并对作为每个 LLM 核心的注意力机制进行编码。</p>
<p>接下来，在第二阶段，我们将学习如何编码和预训练能够生成新文本的类似 GPT 的 LLM。我们还将回顾评估 LLM 的基础知识，这对于开发强大的 NLP 系统至关重要。</p>
<p>请注意，从头开始预训练大型 LLM 是一项艰巨的任务，对于类似 GPT 的模型需要数千到数百万美元的计算成本。因此，第二阶段的重点是使用小数据集实施用于教育目的的培训。此外，本书还将提供加载公开可用的模型权重的代码示例。</p>
<p>最后，在第三阶段，我们将采用预训练的 LLM 并对其进行微调，以遵循回答查询或文本分类等指令——这是许多现实世界应用和研究中最常见的任务。</p>
]]></content>
  </entry>
  <entry>
    <title>LLM相关应用和开发工具整理</title>
    <url>/blog/2024/03/26/LLM%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>最近使用了很多大语言模型（LLM）相关的应用和开发工具，在这篇博客中将它们汇总一下。</p>
<a id="more"></a>

<p>LLM 相关的应用和工具大致可以分为以下几类：</p>
<ul>
<li>AI Agent 开发平台</li>
<li>LLM 应用开发平台</li>
<li>LLM 管理工具</li>
<li>LLM Python 开发库</li>
</ul>
<p>下面分别介绍下每个分类都有哪些应用和工具。</p>
<h1 id="AI-Agent开发平台"><a href="#AI-Agent开发平台" class="headerlink" title="AI Agent开发平台"></a>AI Agent开发平台</h1><p>AI Agent 应用是 LLM 比较火的一个应用方向，也是一个在未来非常有潜力的方向。</p>
<p>AI Agent 是指能够在其环境中自动执行任务或达成目标的软件实体。这些代理能够通过感知环境并在此基础上进行决策来执行动作，以实现特定的目标或任务。AI Agent的工作原理和目的可以根据其设计和应用场景而有很大差异，但一般来说，它们都具备以下几个关键特性：</p>
<ol>
<li><strong>感知能力（Perception）</strong>：AI Agent能够通过内置或外部的传感器感知其所处的环境。这包括从环境中收集数据和信息，如图像、声音、温度等，以帮助代理理解当前的状况。</li>
<li><strong>决策能力（Decision Making）</strong>：基于对环境的感知，AI Agent能够评估不同的行动方案，并选择最佳的方案来执行。这个过程通常涉及到某种形式的智能算法，如机器学习、深度学习或逻辑推理等。</li>
<li><strong>行动能力（Action）</strong>：AI Agent可以通过执行器对环境产生影响，执行各种动作。这些执行器可以是物理的（如机器人的手臂）或软件上的（如网络请求）。</li>
<li><strong>自主性（Autonomy）</strong>：AI Agent具有一定程度的自主性，意味着它们能够在没有人类直接干预的情况下，根据自己的判断和策略进行操作和决策。</li>
<li><strong>学习能力（Learning）</strong>：许多AI Agent具备学习能力，可以通过经验改进其行为。这通常是通过机器学习和深度学习实现的，使得代理能够基于过去的行为和结果来优化其未来的决策和动作。</li>
<li><strong>适应性（Adaptability）</strong>：与学习能力密切相关，适应性是指AI Agent能够适应环境的变化，并据此调整其行为的能力。</li>
</ol>
<p>目前比较流行的 AI Agent 应用开发平台有：AutoGen、MetaGPT、CrewAI、XAgent、AutoGPT、OpenAgents 等。</p>
<h2 id="AutoGen"><a href="#AutoGen" class="headerlink" title="AutoGen"></a>AutoGen</h2><p>AutoGen 是由微软、宾夕法尼亚州立大学和华盛顿大学合作开发的一个框架，它支持使用多个代理来开发 LLM 应用程序，这些代理可以相互对话来完成任务。AutoGen 中的代理是可定制的、可对话的，并且无缝地允许人类参与。AutoGen 有如下特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 可以轻松构建基于多代理对话的 LLM 应用程序。它简化了复杂的 LLM 工作流程的编排、自动化和优化。它最大限度地提高了 LLM 模型的性能并克服了它们的弱点。</span><br><span class="line">2. 它支持复杂工作流程的多种对话模式。借助可定制和可对话的代理，开发人员可以使用 AutoGen 构建各种涉及对话自主性、代理数量和代理对话拓扑的对话模式。</span><br><span class="line">3. 它提供了一系列具有不同复杂性的工作系统。这些系统涵盖各种领域和复杂性的广泛应用。</span><br><span class="line">4. 它提供增强的 LLM 推理。它提供 API 和缓存等实用程序，以及错误处理、多配置推理、上下文编程等高级使用模式。</span><br></pre></td></tr></table></figure>

<p>Github：<a href="https://github.com/microsoft/autogen" target="_blank" rel="noopener">https://github.com/microsoft/autogen</a></p>
<p>官网：<a href="https://microsoft.github.io/autogen/" target="_blank" rel="noopener">https://microsoft.github.io/autogen/</a></p>
<h2 id="MetaGPT"><a href="#MetaGPT" class="headerlink" title="MetaGPT"></a>MetaGPT</h2><p>MetaGPT 是一个 Multi-Agent 框架，它为GPT分配不同的角色，形成一个协作实体来完成复杂的任务。MetaGPT 将一行需求作为输入并输出用户故事/竞争分析/需求/数据结构/API/文档等。在内部，MetaGPT 包括产品经理/架构师/项目经理/工程师。它提供了软件公司的整个流程以及精心策划的 SOP。</p>
<p>Code=SOP(Team)是核心理念。我们具体化SOP并将其应用于由 LLM 组成的团队。</p>
<p>LLM 是大脑，Agent 是手、脚、眼睛、耳朵等。</p>
<p>MetaGPT 一个集产品经理、架构师、项目经理、程序员于一体的 AI Agent 工具。</p>
<p>Github：<a href="https://github.com/geekan/MetaGPT" target="_blank" rel="noopener">https://github.com/geekan/MetaGPT</a></p>
<h2 id="XAgent"><a href="#XAgent" class="headerlink" title="XAgent"></a>XAgent</h2><p>XAgent 是由清华大学开发的一个开源的基于大型语言模型（LLM）的自主智能体，可以自动解决各种任务。 它被设计为一个通用的智能体，可以应用于各种任务。它具有以下特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自主性：XAgent可以在没有人类参与的情况下自动解决各种任务。</span><br><span class="line">安全性：XAgent被设计为安全运行。所有的行为都被限制在一个docker容器内。不用担心你的主机环境受到影响</span><br><span class="line">可扩展性：XAgent被设计为可扩展的。您可以轻松地添加新的工具来增强智能体的能力，甚至是新的智能体！</span><br><span class="line">GUI：XAgent为用户提供了友好的GUI来与智能体交互。您也可以使用命令行界面与智能体交互。</span><br><span class="line">与人类的合作：XAgent可以与您合作解决任务。它不仅有能力在行进中遵循您的指导来解决复杂的任务，而且在遇到挑战时还可以寻求您的帮助。</span><br></pre></td></tr></table></figure>

<p>XAgent由三部分组成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调度器 负责动态实例化和分派任务给不同的智能体。它允许我们添加新的智能体和改进智能体的能力。</span><br><span class="line">规划器 负责为任务生成和校正计划。它将任务分解为子任务，并为它们生成里程碑，使智能体能够逐步解决任务。</span><br><span class="line">行动者 负责采取行动实现目标和完成子任务。行动者利用各种工具来解决子任务，它也可以与人类合作来解决任务。</span><br></pre></td></tr></table></figure>

<p>Github：<a href="https://github.com/OpenBMB/XAgent" target="_blank" rel="noopener">https://github.com/OpenBMB/XAgent</a></p>
<h2 id="CrewAI"><a href="#CrewAI" class="headerlink" title="CrewAI"></a>CrewAI</h2><p>CrewAI 是用于编排角色扮演、自主人工智能代理的框架。通过促进协作智能，CrewAI 使代理能够无缝协作，处理复杂的任务。</p>
<p>GIthub：<a href="https://github.com/joaomdmoura/crewAI" target="_blank" rel="noopener">https://github.com/joaomdmoura/crewAI</a></p>
<h2 id="AutoGPT"><a href="#AutoGPT" class="headerlink" title="AutoGPT"></a>AutoGPT</h2><p>AutoGPT 的宗旨是为每个人提供易于使用和构建的人工智能。它们提供工具，以便我们可以专注于重要的事情。</p>
<p>AutoGPT 项目由四个主要部分组成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Agent：是 AutoGPT 的核心以及启动这一切的项目：由 LLM 支持的半自主 agent，可以为我们执行任何任务</span><br><span class="line">Benchmark（基准）：又名 agbenchmark，衡量你的 agent 的表现！ agbenchmark 可与任何支持 agent 协议的 agent 一起使用，并且与项目的 CLI 集成使得与 AutoGPT 和基于 forge 的代理一起使用变得更加容易。</span><br><span class="line">Forge（熔炉）：打造你自己的 agent！ Forge 是适合您的 agent 应用程序的现成模板。所有样板代码都已处理完毕，让您可以将所有创造力投入到使您的代理与众不同的事情中。</span><br><span class="line">Frontend（前端）：适用于任何符合 agent 协议的 agent 的易于使用的开源前端。</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://docs.agpt.co/" target="_blank" rel="noopener">https://docs.agpt.co/</a></p>
<p>Github：<a href="https://github.com/Significant-Gravitas/AutoGPT" target="_blank" rel="noopener">https://github.com/Significant-Gravitas/AutoGPT</a></p>
<h2 id="OpenAgents"><a href="#OpenAgents" class="headerlink" title="OpenAgents"></a>OpenAgents</h2><p>由于当前的语言代理框架旨在促进构建概念证明语言智能体（Language Agent）的搭建，但是同时忽视了非专家用户的使用，对应用级设计也关注较少。 OpenAgents 是一个用于在日常生活中使用和托管语言智能体的开放平台。</p>
<p>OpenAgents中实现了三个智能体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 数据智能体-用于用Python&#x2F;SQL和数据工具进行数据分析；</span><br><span class="line">2. 插件智能体-具有200多个日常工具，并且可供拓展；</span><br><span class="line">3. 网络智能体-用于自动上网。</span><br></pre></td></tr></table></figure>

<p>OpenAgents可以分析数据，调用插件，像ChatGPT Plus一样控制浏览器，并且它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 易于部署</span><br><span class="line">2. 全栈代码</span><br><span class="line">3. 聊天Web UI</span><br><span class="line">4. 代理方法</span><br></pre></td></tr></table></figure>

<p>OpenAgents 使普通用户通过为快速响应和常见失败进行优化的web UI与智能体功能进行交互，同时为开发人员和研究人员在本地设置上提供无缝部署体验，为制作创新的语言代理和实现现实世界评估提供了基础。 </p>
<p>Github：<a href="https://github.com/xlang-ai/OpenAgents" target="_blank" rel="noopener">https://github.com/xlang-ai/OpenAgents</a></p>
<h1 id="LLM-应用开发平台"><a href="#LLM-应用开发平台" class="headerlink" title="LLM 应用开发平台"></a>LLM 应用开发平台</h1><p>LLM 应用开发平台允许我们创建自己的知识库，并基于这些知识库快速开发个人或者企业的 RAG （检索增强生成）应用。这类平台应用有 Dify、Flowise、FastGPT、TaskingAI、ChatGPT-Next-Web、LobeChat、PrivateGPT 等。</p>
<h2 id="Dify"><a href="#Dify" class="headerlink" title="Dify"></a>Dify</h2><p>Dify 是一个 LLM 应用程序开发平台，它集成了 BaaS （后端即服务）和 LLMOps，涵盖了构建生成式 AI 原生应用程序的基本技术堆栈，包括内置的 RAG 引擎。Dify 允许我们基于任何 LLM 部署自己版本的 Assistants API 和 GPT。</p>
<p>Dify 有以下特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLM支持：与 OpenAI 的 GPT 系列模型集成,或者与开源的 Llama2 系列模型集成。事实上，Dify支持主流的商业模型和开源模型(本地部署或基于 MaaS)。</span><br><span class="line">Prompt IDE：和团队一起在 Dify 协作，通过可视化的 Prompt 和应用编排工具开发 AI 应用。 支持无缝切换多种大型语言模型。</span><br><span class="line">RAG引擎：包括各种基于全文索引或向量数据库嵌入的 RAG 能力，允许直接上传 PDF、TXT 等各种文本格式。</span><br><span class="line">AI Agent：基于 Function Calling 和 ReAct 的 Agent 推理框架，允许用户自定义工具，所见即所得。Dify 提供了十多种内置工具调用能力，如谷歌搜索、DELL·E、Stable Diffusion、WolframAlpha 等。</span><br><span class="line">持续运营：监控和分析应用日志和性能，使用生产数据持续改进 Prompt、数据集或模型。</span><br></pre></td></tr></table></figure>

<p>官网：<a href="https://dify.ai/" target="_blank" rel="noopener">https://dify.ai/</a></p>
<p>Github：<a href="https://github.com/langgenius/dify" target="_blank" rel="noopener">https://github.com/langgenius/dify</a></p>
<h2 id="Flowise"><a href="#Flowise" class="headerlink" title="Flowise"></a>Flowise</h2><p>Flowise 是一种低代码/无代码拖放工具，可以让我们轻松可视化和构建 LLM 应用程序。</p>
<p>文档：<a href="https://docs.flowiseai.com/" target="_blank" rel="noopener">https://docs.flowiseai.com/</a></p>
<p>Github：<a href="https://github.com/FlowiseAI/Flowise" target="_blank" rel="noopener">https://github.com/FlowiseAI/Flowise</a></p>
<h2 id="FastGPT"><a href="#FastGPT" class="headerlink" title="FastGPT"></a>FastGPT</h2><p>FastGPT 是一个基于 LLM 大语言模型的知识库问答系统，提供开箱即用的数据处理、模型调用等能力。同时可以通过 Flow 可视化进行工作流编排，从而实现复杂的问答场景！</p>
<p>FastGPT 有如下特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">独特的 QA 结构：针对客服问答场景设计的 QA 结构，提高在大量数据场景中的问答准确性。</span><br><span class="line">可视化工作流：通过 Flow 模块展示了从问题输入到模型输出的完整流程，便于调试和设计复杂流程。</span><br><span class="line">无限扩展：基于 API 进行扩展，无需修改 FastGPT 源码，也可快速接入现有的程序中。</span><br><span class="line">便于调试：提供搜索测试、引用修改、完整对话预览等多种调试途径。</span><br><span class="line">支持多种模型：支持 GPT、Claude、文心一言等多种 LLM 模型，未来也将支持自定义的向量模型。</span><br></pre></td></tr></table></figure>

<p>官网：<a href="https://fastgpt.run/" target="_blank" rel="noopener">https://fastgpt.run/</a></p>
<p>Github：<a href="https://github.com/labring/FastGPT" target="_blank" rel="noopener">https://github.com/labring/FastGPT</a></p>
<h2 id="TaskingAI"><a href="#TaskingAI" class="headerlink" title="TaskingAI"></a>TaskingAI</h2><p>TaskingAI 将 Firebase 的简单性带入 AI 原生应用程序开发中。该平台支持使用来自不同提供商的各种 LLM 来创建类似 GPT 的多租户应用程序。它具有独特的模块化功能，例如推理、检索、助手和工具，无缝集成以增强开发过程。TaskingAI 的凝聚力设计确保了人工智能应用程序开发中的高效、智能和用户友好的体验。</p>
<p>TaskingAI 有如下特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 一体化 LLM 平台：通过统一的 API 访问数百个 AI 模型。</span><br><span class="line">2. 直观的 UI 控制台：简化项目管理并允许控制台内工作流程测试。</span><br><span class="line">3. BaaS 启发的工作流程：将 AI 逻辑（服务器端）与产品开发（客户端）分开，提供从基于控制台的原型设计到使用 RESTful API 和客户端 SDK 的可扩展解决方案的清晰途径。</span><br><span class="line">4. 可定制的集成：通过可定制的工具和先进的检索增强生成（RAG）系统增强 LLM 的功能。</span><br><span class="line">5. 异步效率：利用Python FastAPI的异步特性实现高性能、并发计算，增强应用程序的响应能力和可扩展性。</span><br></pre></td></tr></table></figure>

<p>TaskingAI 的架构设计以模块化和灵活性为核心，能够与各种 LLM 兼容。这种适应性使其能够轻松支持各种应用程序，从简单的演示到复杂的多租户人工智能系统。TaskingAI 以开源原则为基础，融合了众多开源工具，确保该平台不仅多功能，而且可定制。</p>
<p>文档：<a href="https://docs.tasking.ai/" target="_blank" rel="noopener">https://docs.tasking.ai/</a></p>
<p>Github：<a href="https://github.com/TaskingAI/TaskingAI" target="_blank" rel="noopener">https://github.com/TaskingAI/TaskingAI</a></p>
<h2 id="ChatGPT-Next-Web"><a href="#ChatGPT-Next-Web" class="headerlink" title="ChatGPT-Next-Web"></a>ChatGPT-Next-Web</h2><p>ChatGPT-Next-Web 可以让我们一键免费部署你的私人 ChatGPT 网页应用，支持 GPT3, GPT4 &amp; Gemini Pro 模型。</p>
<p>它有如下特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 只需在 1 分钟内即可在 Vercel 上一键免费部署</span><br><span class="line">2. 提供Linux&#x2F;Windows&#x2F;MacOS 上的紧凑型客户端下载</span><br><span class="line">3. 与自行部署的LLM完全兼容，推荐与RWKV-Runner或LocalAI一起使用</span><br><span class="line">4. 隐私第一，所有数据都存储在浏览器本地</span><br><span class="line">5. Markdown 支持：LaTex、mermaid、代码高亮等。</span><br><span class="line">6. 响应式设计、深色模式和 PWA </span><br><span class="line">7. 首屏加载速度快（~100kb），支持流式响应</span><br><span class="line">8. v2 中的新增功能：使用提示模板（掩码）创建、共享和调试您的聊天工具 </span><br><span class="line">9. 由 Awesome-chatgpt-prompts-zh 和 Awesome-chatgpt-prompts 提供支持的很棒的 prompt</span><br><span class="line">10. 自动压缩聊天历史记录以支持长时间对话，同时保存您的令牌</span><br><span class="line">11. 国际化：英语、西班牙语、意大利语、土耳其语、德语、Tiếng Việt、Русский、Čeština、한국어、印度尼西亚</span><br></pre></td></tr></table></figure>

<p>Github：<a href="https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web" target="_blank" rel="noopener">https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web</a></p>
<h2 id="LobeChat"><a href="#LobeChat" class="headerlink" title="LobeChat"></a>LobeChat</h2><p>Lobe Chat - 一个开源、现代设计的 LLM / 人工智能聊天框架。支持多AI提供商（OpenAI / Claude 3 / Gemini / Perplexity / Bedrock / Azure / Mistral / Ollama），多模态（Vision / TTS）和插件系统。一键免费部署您的私人 ChatGPT 聊天应用程序。</p>
<p>Lobe Chat 有以下特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 多模式服务提供商支持，支持了AWS Bedrock、Google AI、Anthropic、ChatGLM、Moonshot AI、Groq等模型服务商</span><br><span class="line">2. 本地大语言模型 (LLM) 支持，LobeChat 基于 Ollama 支持了本地模型的使用，让用户能够更灵活地使用自己的或第三方的模型</span><br><span class="line">3. 模型视觉识别，LobeChat 已经支持 OpenAI 最新的 gpt-4-vision 支持视觉识别的模型，这是一个具备视觉识别能力的多模态应用。 用户可以轻松上传图片或者拖拽图片到对话框中，助手将能够识别图片内容，并在此基础上进行智能对话，构建更智能、更多元化的聊天场景</span><br><span class="line">4. TTS 和 STT 语音会话，LobeChat 支持文字转语音（Text-to-Speech，TTS）和语音转文字（Speech-to-Text，STT）技术，这使得我们的应用能够将文本信息转化为清晰的语音输出，用户可以像与真人交谈一样与我们的对话助手进行交流。 用户可以从多种声音中选择，给助手搭配合适的音源。 同时，对于那些倾向于听觉学习或者想要在忙碌中获取信息的用户来说，TTS 提供了一个极佳的解决方案</span><br><span class="line">5. 文本生成图像，支持最新的文本到图片生成技术，LobeChat 现在能够让用户在与助手对话中直接调用文生图工具进行创作。 通过利用 DALL-E 3、MidJourney 和 Pollinations 等 AI 工具的能力， 助手们现在可以将你的想法转化为图像。 同时可以更私密和沉浸式地完成你的创作过程</span><br><span class="line">6. 插件系统（函数调用），LobeChat 的插件生态系统是其核心功能的重要扩展，它极大地增强了 ChatGPT 的实用性和灵活性。通过利用插件，ChatGPT 能够实现实时信息的获取和处理，例如自动获取最新新闻头条，为用户提供即时且相关的资讯</span><br><span class="line">7. Agent 市场 (GPTs)，在 LobeChat 的助手市场中，创作者们可以发现一个充满活力和创新的社区，它汇聚了众多精心设计的助手，这些助手不仅在工作场景中发挥着重要作用，也在学习过程中提供了极大的便利。 我们的市场不仅是一个展示平台，更是一个协作的空间。在这里，每个人都可以贡献自己的智慧，分享个人开发的助手</span><br><span class="line">8. 使用渐进式Web应用程序 (PWA)，采用了渐进式 Web 应用 PWA 技术， 这是一种能够将网页应用提升至接近原生应用体验的现代 Web 技术。通过 PWA，LobeChat 能够在桌面和移动设备上提供高度优化的用户体验，同时保持轻量级和高性能的特点。 在视觉和感觉上，我们也经过精心设计，以确保它的界面与原生应用无差别，提供流畅的动画、响应式布局和适配不同设备的屏幕分辨率</span><br><span class="line">9. 移动设备适配，针对移动设备进行了一系列的优化设计，以提升用户的移动体验</span><br><span class="line">10. 可以自定义主题，LobeChat 在界面设计上充分考虑用户的个性化体验，因此引入了灵活多变的主题模式，其中包括日间的亮色模式和夜间的深色模式。 除了主题模式的切换，还提供了一系列的颜色定制选项，允许用户根据自己的喜好来调整应用的主题色彩。无论是想要沉稳的深蓝，还是希望活泼的桃粉，或者是专业的灰白，用户都能够在 LobeChat 中找到匹配自己风格的颜色选择</span><br></pre></td></tr></table></figure>

<p>Github：<a href="https://github.com/lobehub/lobe-chat" target="_blank" rel="noopener">https://github.com/lobehub/lobe-chat</a></p>
<h2 id="PrivateGPT"><a href="#PrivateGPT" class="headerlink" title="PrivateGPT"></a>PrivateGPT</h2><p>PrivateGPT 是一个可投入生产的 AI 项目，可让您利用大型语言模型 (LLM) 的功能提出有关文档的问题，即使在没有互联网连接的情况下。 100% 私有，任何数据都不会离开您的执行环境。该项目提供了一个 API，提供构建私有的、上下文感知的 AI 应用程序所需的所有原语。它遵循并扩展了 OpenAI API 标准，支持普通响应和流式响应。这意味着，如果您可以在您的工具之一中使用 OpenAI API，则可以使用您自己的 PrivateGPT API，无需更改代码，并且如果您在本地设置中运行 privateGPT，则免费。</p>
<p>PrivateGPT 是一项服务，它将一组 AI RAG 原语包装在一组全面的 API 中，提供私有、安全、可定制且易于使用的 GenAI 开发框架。</p>
<p>它使用FastAPI和LLamaIndex作为其核心框架。这些可以通过更改代码库本身来定制。</p>
<p>它支持各种本地和远程的 LLM 提供商、嵌入提供商和向量存储。这些可以轻松更改，而无需更改代码库。</p>
<p>API 分为两个逻辑块： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 高级 API，抽象了 RAG（检索增强生成）管道实现的所有复杂性：</span><br><span class="line">1）文档摄取：内部管理文档解析、分割、元数据提取、嵌入生成和存储。</span><br><span class="line">2）使用所摄取文档中的上下文进行聊天和完成：抽象上下文检索、提示工程和响应生成</span><br><span class="line"></span><br><span class="line">2. 低级 API，允许高级用户实现自己的复杂管道：</span><br><span class="line">1）嵌入生成：基于一段文本。</span><br><span class="line">2）上下文块检索：给定查询，从摄取的文档中返回最相关的文本块。</span><br></pre></td></tr></table></figure>

<p>除此之外，还提供了一个可用的 Gradio UI 客户端来测试 API，以及一组有用的工具，例如批量模型下载脚本、摄取脚本、文档文件夹监视等。</p>
<p>Github：<a href="https://github.com/zylon-ai/private-gpt" target="_blank" rel="noopener">https://github.com/zylon-ai/private-gpt</a></p>
<p>文档：<a href="https://docs.privategpt.dev/overview/welcome/introduction" target="_blank" rel="noopener">https://docs.privategpt.dev/overview/welcome/introduction</a></p>
<h1 id="LLM-管理工具"><a href="#LLM-管理工具" class="headerlink" title="LLM 管理工具"></a>LLM 管理工具</h1><p>LLM 管理工具可以帮助我们管理开源大语言模型，它们可以下载、删除、运行开源大模型，并且提供调用 LLM 服务的API，使我们可以很容易的构建基于本地的 LLM 应用。</p>
<p>这类管理工具有 Ollama、LM Studio、LocalAI 等。</p>
<h2 id="Ollama"><a href="#Ollama" class="headerlink" title="Ollama"></a>Ollama</h2><p>Ollama是一个开源工具，它能帮助我们在本地搭建和运行Llama2、Mistral、Gemma等开源LLM服务，Ollama也允许我们基于一个 LLM 去创建另一个LLM，就像使用 Dockerfile 那样，它还提供了 REST API 供我们调用。</p>
<p>官网：<a href="https://ollama.com/" target="_blank" rel="noopener">https://ollama.com/</a></p>
<p>Github：<a href="https://github.com/ollama/ollama" target="_blank" rel="noopener">https://github.com/ollama/ollama</a></p>
<h2 id="LM-Studio"><a href="#LM-Studio" class="headerlink" title="LM Studio"></a>LM Studio</h2><p>LM Studio 可以帮我们发现、下载 LLM，并在本地运行它，它还能帮我们做以下工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 通过应用内聊天 UI 或 OpenAI 兼容的本地服务器使用模型</span><br><span class="line">2. 从 HuggingFace 存储库下载任何兼容的模型文件</span><br><span class="line">3. 在应用程序的主页中发现新的和值得注意的 LLM</span><br></pre></td></tr></table></figure>

<p>官网：<a href="https://lmstudio.ai/" target="_blank" rel="noopener">https://lmstudio.ai/</a></p>
<h2 id="LocalAI"><a href="#LocalAI" class="headerlink" title="LocalAI"></a>LocalAI</h2><p>LocalAI 允许我们使用消费级硬件在本地或本地运行 LLM 、生成图像、音频（不仅如此），支持多种模型系列和架构，并且不需要 GPU。LocalAI 致力于让任何人都能使用人工智能。</p>
<p>文档：<a href="https://localai.io/" target="_blank" rel="noopener">https://localai.io/</a></p>
<h1 id="LLM-Python开发库"><a href="#LLM-Python开发库" class="headerlink" title="LLM Python开发库"></a>LLM Python开发库</h1><p>LLM Python 开发库提供了通用的 API 让我们来调用各种大模型服务，除了 LangChain、LlamaIndex 这这些常用的库，还有下面一些很好用的库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 提供统一接口调用 LLM 的库：transformers、vllm、litellm 等</span><br><span class="line">2. 开发 web 界面的库：streamlit、chainlit 等</span><br></pre></td></tr></table></figure>



<p>以上就是 LLM 相关的应用和开发工具，后面还会持续补充 …</p>
]]></content>
  </entry>
</search>
